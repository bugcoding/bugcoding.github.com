<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="keep coding, keep moving..."><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>使用SIGCHLD信号异步清理子进程</title><link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="author"><div class="author-name"><a href="/">bugcode's note</a></div><div class="about-me">思绪如风，来去匆匆。</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">Archives</a></li><li><a href="/about">About</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.jpg"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/bugcoding"></span><a href="https://github.com/bugcoding" target="_blank" title="https://github.com/bugcoding">https://github.com/bugcoding</a></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">使用SIGCHLD信号异步清理子进程</div><span class="date">2015年04月19日</span><span>   </span><span class="tags"><a class="tag-link" href="/tags/Linux/">Linux</a></span><div class="content"><p>首先说为什么要清理子进程（由父进程），在Unix系统中经常会听到一个词“僵尸进程”(Zombie Process[可不是植物大战僵尸^_*])，而“僵尸进程”就是由子进程而来的。</p>
<a id="more"></a>
<p>“僵尸子进程”产生的原因，简单来说，就是子进程结束的时候，它的父进程没有wait它，内核释放了这个子进程的空间但进程却没有从进程表中被删除（空占进程表），而Unix保证每个进程都可以访问其子进程的退出信息，但必须wait它才可以取出对应进程的退出信息，这样儿就出现了一个问题，父进程可能太忙没有wait子进程，子进程却结束了，子进程对应的退出信息就会一直保留（包括进程ID等），资源会一直被占用，小数量的可能没有危害，一旦“僵尸进程”数量变多，主要是进程数限制，可能就会造成无法产生新的进程。</p>
<p>这就是典型的“僵尸进程”的危害。（另外说明一种情况，如果在子进程结束前，父进程已经结束，这样不会造成“僵尸进程”，因为Unix提供一种机制，如果一个进程结束，系统会检查进程，如果有进程正好是已经结束进程的子进程，那么这个进程就会被init进程接管，也就是说init进程变成了它的父进程。）</p>
<p>下面是一个小例子，先对“僵尸进程”有一个视觉的了解：(zombie.c)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//产生子进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spawn_process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">pid_t</span> child_pid;</span><br><span class="line">     child_pid = fork();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//父进程返回子进程ID</span></span><br><span class="line">     <span class="keyword">if</span> (child_pid != <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> child_pid;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span><span class="comment">//子进程中，做一些事情</span></span><br><span class="line">     &#123;</span><br><span class="line">          sleep(<span class="number">10</span>);</span><br><span class="line">          <span class="built_in">abort</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> child_status;</span><br><span class="line">     <span class="comment">//产生子进程并wait</span></span><br><span class="line">     spawn_process();</span><br><span class="line">     wait(&amp;child_status);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"child_process finished!\n"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常编译运行，主程序会sleep一分钟。<br>此时打开另一个终端窗口，输入：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps –e –o pid,ppid,state,cmd</span><br></pre></td></tr></table></figure></p>
<p>查看所有进程，包括进程ID，父进程ID，进程状态，进程命令行，如果不出什么差错，应该可以看到类似下面的信息：<br><img src="/chapimages/zombie.png" alt="">         </p>
<p>这个进程状态为Z，命令行为defunct的就是大名鼎鼎的“僵尸进程”了(Z-&gt;Zombie)。而我们应该怎么避免呢？根据上面，首先肯定想到，由父进程wait子进程，直接到子进程结束，再由父进程wait到其状态。但是这样又带来一个问题，父进程与子进程的运行本身就是一个异步的过程，父进程没法预料什么时候子进程结束，一直wait子进程？那父进程就会一直挂起到子进程结束的那一刻，下面看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//产生子进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spawn_process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> child_pid;</span><br><span class="line">    child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父进程返回子进程ID</span></span><br><span class="line">    <span class="keyword">if</span> (child_pid != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> child_pid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//子进程中，做一些事情</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child_status;</span><br><span class="line">    <span class="comment">//产生子进程并wait</span></span><br><span class="line">    spawn_process();</span><br><span class="line">    wait(&amp;child_status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child_process finished!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常编译运行，可以看到，直到子进程结束，父进程也就是main中的printf才打印出child_process finished!，在此之前进程一直处于挂起状态(Hang Up)，也就是父进程要一直等，等子进程结束，父进程才会结束，这显然不是我们想要的优雅的解决方式。 </p>
<p>一种优雅的解决方式就是，当每个子进程结束的时候，通知父进程（儿子出去玩不知道什么时候回来，父亲不知道什么时候该做饭等他，如果儿子回来的时候打电话告诉父亲，父亲再等他，这样儿父亲还不耽误其他时间），而子进程怎么通知父进程呢？通知的方法有几种，进程间通信(将在以后讨论)，现在最容易想到的就是信号，Linux下一个子进程结束的时候，会向父进程发送一个SIGCHLD信号，而Linux系统对这个信号的默认是什么也不做，于是，我们就可以通过捕获SIGCHLD信号，再去让父进程wait子进程，这样就可以父进程就可以异步的清理子进程，也就是只在子进程结束的时候才去wait子进程退出状态。接下来的问题就是如何捕获对应的信号，设置对应的信号处理了。这里我们使用sigaction，简单说一下sigaction，它是用来设定对应信号处理的函数，三个参数，第一个设置要处理信号的信号值，第二个参数，设置对应的sigaction结构，结构中最重要的是信号处理函数，也就是对应的handler域，第三个也是一个sigaction结构，可以理解为保存上一个的信号处理的sigaction结构，如果第二个参数不为空则当前使用第二个参数中的处理，如果第三个参数不空，上一个处理的sigaction就会保存在这里（如要具体了解，参见man 2 sigaction）。</p>
<p>下面给出例子，父进程通过捕获SIGCHLD信号，wait子进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量保存退出状态</span></span><br><span class="line"><span class="keyword">sig_atomic_t</span> exit_status;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spawn_process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> child_pid;</span><br><span class="line">    child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父进程返回子进程ID</span></span><br><span class="line">    <span class="keyword">if</span> (child_pid != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> child_pid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//子进程中，做一些事情</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SIGCHLD信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup_child_process</span><span class="params">(<span class="keyword">int</span> sig_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    wait(&amp;status);<span class="comment">//wait子进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child_process prepare terminate!"</span>);</span><br><span class="line">    exit_status = status;<span class="comment">//保存退出状态信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 通过调用cleanup_child_process处理SIGCHLD信号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigchild_action</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sigchild_action, <span class="number">0</span>, <span class="keyword">sizeof</span>(sigchild_action));</span><br><span class="line">    sigchild_action.sa_handler = &amp;cleanup_child_process;</span><br><span class="line">    sigaction(SIGCHLD, &amp;sigchild_action, <span class="literal">NULL</span>);<span class="comment">//设置对应的信号处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生子进程并wait</span></span><br><span class="line">    spawn_process();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent_process do something!\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，可以看到，这次父进程没有一直Hang Up等待子进程结束，父进程一直在做自己的事，直接接收到了SIGCHLD信号，才对子进程做出处理，这样儿，就通过对SIGCHLD信号的处理达到了对子进程异步清理（wait）的目的。</p>
</div></section></div><div class="container"><ul class="nav"><li>上一篇：<a href="/2015/05/16/Linux下的umask.html">Linux下的umask</a></li><li>下一篇：<a href="/2015/03/29/Lua简要笔记-2.html">Lua简要笔记-2</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><center class="span">2014-2018 bugcode.</center></div></footer><script src="/script/jquery.min.js"></script><script src="/script/index.js"></script><script src="/script/jquery.min.js"></script><script src="/script/index.js"></script><script src="/script/post.js"></script></body></html>