<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="keep coding, keep moving..."><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>SwiftNote-6</title><link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="author"><div class="author-name"><a href="/">bugcode's note</a></div><div class="about-me">keep coding, keep moving...</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/">Home</a></li><li><a href="/archives">Archives</a></li><li><a href="/about">About</a></li><li><a href="/atom.xml">RSS</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.jpg"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/bugcoding"></span><a href="https://github.com/bugcoding" target="_blank" title="https://github.com/bugcoding">https://github.com/bugcoding</a></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">SwiftNote-6</div><span class="date">2016年05月02日</span><span>   </span><span class="tags"><a class="tag-link" href="/tags/Swift/">Swift</a></span><div class="content"><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Swift支持闭包，相当于其他函数里面的匿名函数的意思。经常是在一些需要传递给其他函数的参数也是一个函数类型的时候，而这个需要被传递的函数又包含的代码是短小的。</p>
<a id="more"></a>
<h2 id="创建闭包"><a href="#创建闭包" class="headerlink" title="创建闭包"></a>创建闭包</h2><ul>
<li><p>闭包语法</p>
<p>形式就是{(parameter list)-&gt; return type <strong>in</strong> function implements} <strong>in</strong>关键字用来分隔函数体与函数类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用之前函数排序那个例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortIntArray</span><span class="params">(<span class="keyword">inout</span> array:[Int], compare:<span class="params">(Int, Int)</span></span></span>-&gt;<span class="type">Bool</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span> - i</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> compare(array[j], array[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">let</span> tmp = array[j]</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>]</span><br><span class="line">                array[j + <span class="number">1</span>] = tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intArray = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, -<span class="number">1</span>, <span class="number">100</span>, <span class="number">99</span>]</span><br><span class="line"><span class="comment">// compare后的参数就是闭包的基本形式，这里不再像之前那样再写一个短小的比较函数</span></span><br><span class="line"><span class="comment">// 直接使用&#123;&#125;定义一个闭包就可以，效果与之前的lessFunc相同</span></span><br><span class="line">sortIntArray(&amp;intArray, compare: &#123;(fir:<span class="type">Int</span>, sec:<span class="type">Int</span>)-&gt;<span class="type">Bool</span> <span class="keyword">in</span> <span class="keyword">return</span> fir &gt;= sec&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(intArray)</span><br></pre></td></tr></table></figure>
<p>除了<strong>in</strong>和<strong>func</strong>关键字，还有函数名基本与定义一个函数类似。</p>
</li>
<li><p>闭包形式简化</p>
<p>已知的函数类型可以省略函数类型，因为Swift可以自动推断对应的函数类型，只需要知道对应的局部参数名称即可</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上例中的compare是明确知道函数类型是(Int, Int)-&gt;Bool类型的</span></span><br><span class="line"><span class="comment">// 上文中的闭可进一步简化成下面的形式</span></span><br><span class="line">sortIntArray(&amp;intArray, compare: &#123;(fir, sec) <span class="keyword">in</span> <span class="keyword">return</span> fir &gt;= sec&#125;)</span><br><span class="line"><span class="comment">// 甚至参数列表的小括号也可以不要</span></span><br><span class="line">sortIntArray(&amp;intArray, compare: &#123;fir, sec <span class="keyword">in</span> <span class="keyword">return</span> fir &gt;= sec&#125;)</span><br></pre></td></tr></table></figure>
<p>闭包还可以进一步简化，Swift可以隐式的推断单行表达式的返回结果，如上文中的compare参数，需要一个Bool的返回值，而闭包的函数体只有一个单行的表达式，所以这里可以继续把return关键字省略</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  进一步省略如下</span></span><br><span class="line">sortIntArray(&amp;intArray, compare: &#123;(fir, sec) <span class="keyword">in</span> fir &gt;= sec&#125;) <span class="comment">// 去掉return关键字</span></span><br></pre></td></tr></table></figure>
<p>还可以再次简化，Swift支持闭包中的参数缩写，即对应使用<strong>$</strong> + 对应参数列表中的位置来代表对应的参数列表中的局部参数，比如上文中的fir和sec可以使用 $1和$2来代替，这样就可以把局部参数名称的声明也去掉了，没有函数类型，所以也就不需要in关键字了</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数名称缩写，进一步简化</span></span><br><span class="line">sortIntArray(&amp;intArray, compare: (&#123;$<span class="number">1</span> &gt;= $<span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="尾闭包"><a href="#尾闭包" class="headerlink" title="尾闭包"></a>尾闭包</h2><p>当闭包表达式是一个参数的最后一个参数时，可以将闭包的{}部分放在函数调用的函数列表之外，以此来增强函数体实现的可读性。</p>
<ul>
<li><p>多个参数的尾闭包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上文的例子就是一个尾闭包，闭包表达式是函数参数的最后一个参数</span></span><br><span class="line"><span class="comment">// 可以这样进行书写</span></span><br><span class="line">sortIntArray(&amp;intArray)&#123;(fir:<span class="type">Int</span>, sec:<span class="type">Int</span>)-&gt;<span class="type">Bool</span> <span class="keyword">in</span> <span class="keyword">return</span> fir &gt;= sec&#125;</span><br><span class="line"><span class="comment">// 最后的简化形式，按尾闭包来写</span></span><br><span class="line">sortIntArray(&amp;intArray)&#123;$<span class="number">1</span> &gt;= $<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只有一个参数的尾闭包，甚至还可以去函数调用的小括号去掉，直接接上闭包的{}</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如内置的sort函数</span></span><br><span class="line">numbers.<span class="built_in">sort</span>&#123;n2 &gt;= n2&#125; <span class="comment">// sort只接受一个函数类型</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h2><p>闭包可以捕获其上下文中的变量/常量，即使出了对应的变量/常量已经出了对应的作用域，也能正常保持该值的引用和修改，类似像在一个函数返回另一个嵌套的函数，这个嵌套的函数就可以保持住在原函数中变量/常量的值，并且Swift会全权对闭包内存进行管理。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementByNum</span><span class="params">(num:Int)</span></span>-&gt;()-&gt;<span class="type">Int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span>-&gt;<span class="type">Int</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += num</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"increment = \(sum)"</span>)</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> increment</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值按1递增</span></span><br><span class="line"><span class="keyword">let</span> makeInc1 = makeIncrementByNum(<span class="number">1</span>)</span><br><span class="line">makeInc1() <span class="comment">// 1</span></span><br><span class="line">makeInc1() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值按10递增，与makeInc1不重合不冲突</span></span><br><span class="line"><span class="keyword">let</span> makeInc2 = makeIncrementByNum(<span class="number">10</span>)</span><br><span class="line">makeInc2() <span class="comment">// 10</span></span><br><span class="line">makeInc2() <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<h2 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h2><p>闭包无论赋值给几个变量或者是常量，闭包内的变量/常量值都是对应函数的引用，不会随着赋值进行拷贝，所以无论你将同一个闭包赋值给几个变量/常量，还是原来的引用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如上例中的makeInc1再次赋值给makeInc2</span></span><br><span class="line"><span class="keyword">var</span> makeInc3 = makeInc1</span><br><span class="line">makeInc3() <span class="comment">// 3 不会产生一个新值的拷贝，因为是原闭包的引用</span></span><br></pre></td></tr></table></figure>
<h2 id="逃逸-非逃逸闭包"><a href="#逃逸-非逃逸闭包" class="headerlink" title="逃逸/非逃逸闭包"></a>逃逸/非逃逸闭包</h2><ul>
<li><p>非逃逸闭包</p>
<p>非逃逸闭包的意思就是闭包传入一个函数中，函数执行完了，这个闭包也就不再起作用了，而逃逸闭包正好相反。Swift中的闭包默认是逃逸的，如果要使一个闭包是非逃逸闭包，在传入函数的参数前使用@noescape标签</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上文中sortArray，使compare是非逃逸闭包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortIntArray</span><span class="params">(<span class="keyword">inout</span> array:[Int], @noescape compare:<span class="params">(Int, Int)</span></span></span>-&gt;<span class="type">Bool</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>逃逸闭包</p>
<p>使闭包逃逸出函数的执行体的办法是将闭包存到一个外部的集合里(如数组，集合)，在函数返回的时候再调用对应的集合里的闭包代码，这时如果将对应函数参数标为@noescape的话就会被Swift检测到，会报错。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存要escape的闭包</span></span><br><span class="line"><span class="keyword">var</span> funcDict:[<span class="type">String</span>:()-&gt;<span class="type">String</span>] = [:]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEscape</span><span class="params">(f:<span class="params">()</span></span></span>-&gt;<span class="type">String</span>)</span><br><span class="line">&#123;</span><br><span class="line">    funcDict[<span class="string">"testEscape"</span>] = f</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"testEscape function execute completed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先输出testEscape function execute completed</span></span><br><span class="line"><span class="comment">// 再输出closure in testEscape</span></span><br><span class="line">testEscape&#123;<span class="keyword">return</span> <span class="string">"closure in testEscape"</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(funcDict[<span class="string">"testEscape"</span>]!())</span><br></pre></td></tr></table></figure>
</li>
</ul>
</div></section></div><div class="container"><ul class="nav"><li>上一篇：<a href="/2016/05/03/zsh-iTerm2折腾记录.html">zsh+iTerm2折腾记录</a></li><li>下一篇：<a href="/2016/05/02/杂记.html">杂记</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><center class="span">2014-2018 bugcode.</center></div></footer><script src="/script/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/script/index.js"></script><script src="/script/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/script/index.js"></script><script src="/script/post.js"></script></body></html>