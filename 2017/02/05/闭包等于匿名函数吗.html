<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="keep coding, keep moving..."><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>闭包 == 匿名函数?</title><link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="author"><div class="author-name"><a href="/">bugcode's note</a></div><div class="about-me">keep coding, keep moving...</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/">Home</a></li><li><a href="/archives">Archives</a></li><li><a href="/about">About</a></li><li><a href="/atom.xml">RSS</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.jpg"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/bugcoding"></span><a href="https://github.com/bugcoding" target="_blank" title="https://github.com/bugcoding">https://github.com/bugcoding</a></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">闭包 == 匿名函数?</div><span class="date">2017年02月05日</span><span>   </span><span class="tags"><a class="tag-link" href="/tags/Theory/">Theory</a></span><div class="content"><p>和同事讨论Java 8的lambda表达式，然后就说起了<code>闭包</code>，然后发现在不在少数的人对闭包的理解就是闭包就是个<em>匿名函数</em>，甚至就认为这二个是互通的。</p>
<a id="more"></a>
<blockquote>
<p><del>匿名函数就是闭包，闭包就是匿名函数</del>。</p>
</blockquote>
<p>结果自然就是一通争论，争论过程中，突然发现有些概念给对方解释的时候也不是能说得特别清楚，这里再对闭包这个概念整理深化一下。</p>
<h5 id="闭包概念"><a href="#闭包概念" class="headerlink" title="闭包概念"></a>闭包概念</h5><p>详细的概念可以看下<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29" target="_blank" rel="noopener">wiki</a>，这里引用一下wiki上对<code>闭包</code>的解释：</p>
<blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>中，<strong>闭包</strong>（英语：Closure），又称<strong>词法闭包</strong>（Lexical Closure）或<strong>函数闭包</strong>（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p>
</blockquote>
<p>这个解释，重点在于这句<code>被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外</code>，仔细看一下这句话，问题又来了，自由变量是什么?</p>
<h5 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h5><p>Google查<em>自由变量</em>会出现另一个对应的词<em>约束变量</em>，具体解释在这个<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%8F%98%E9%87%8F%E5%92%8C%E7%BA%A6%E6%9D%9F%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">链接</a>，约束变量字面解释自然是受约束的变量，其实也就是某个作用域内有效的变量，其有效范围受到约束，针对非函数式语言来说，就是函数内部的局部变量，函数的参数，这都属于<em>约束变量</em>，而非函数式语言中的全局变量，可以对应为<em>自由变量</em>，即不受某个特定的作用域限制。而对于函数式语言，可以在函数内定义函数，例如在<strong>F</strong>函数中定义了<strong>I</strong>函数，<strong>I</strong>函数内的变量是约束变量，但是在<strong>F</strong>函数内定义的变量v对于<strong>I</strong>函数来说，就是自由变量，因为v变量不受<strong>I</strong>函数的作用域限制，通常叫这个v变量为upvalue，而闭包中upvalue才是最重要的。</p>
<h5 id="再看闭包解释"><a href="#再看闭包解释" class="headerlink" title="再看闭包解释"></a>再看闭包解释</h5><p>这时再回头看闭包的解释<code>被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外</code>，闭包的核心概念是需要<strong>引用自由变量</strong>的函数，即自由变量与引用它的函数共同树成闭包，并且在产生调用的时候，自由变量与对应的函数共同组成的上下文不会因为函数的外层函数(产生闭包的函数，上面例子中的<strong>F</strong>函数)的返回而销毁，这样才是一个完整的闭包概念。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>下面用Lua来解释上面所说的这些概念，现成的例子就是<a href="https://www.lua.org/pil/6.1.html" target="_blank" rel="noopener">Lua官方教程</a>中的newCounter的例子:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- 局部变量i，newCounter函数内有效</span></span><br><span class="line">    <span class="keyword">local</span> i = <span class="number">0</span> </span><br><span class="line">    <span class="comment">-- 返回一个匿名函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span> </span><br><span class="line">        <span class="comment">-- 引用了一个上层函数作用域中的变量</span></span><br><span class="line">        <span class="comment">-- 这里i就是upvalue</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">counter1 = newCounter()</span><br><span class="line">counter2 = newCounter()</span><br><span class="line"><span class="comment">-- 这里输出二个不同的地址，即返回了不同的函数</span></span><br><span class="line"><span class="built_in">print</span>(counter1, counter2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出 1 2 3</span></span><br><span class="line"><span class="built_in">print</span>(counter1())</span><br><span class="line"><span class="built_in">print</span>(counter1())</span><br><span class="line"><span class="built_in">print</span>(counter1())</span><br><span class="line"><span class="comment">-- 输出1 2</span></span><br><span class="line"><span class="built_in">print</span>(counter2())</span><br><span class="line"><span class="built_in">print</span>(counter2())</span><br></pre></td></tr></table></figure>
<p>counter1与counter2分别是newCounter返回来的函数，二个互不相干，这点可以理解，而counter1连结调用三次，i的值保持递增，并没有因为newCounter函数返回而在匿名函数中销毁，而是和匿名函数一起组成的环境在内存中保留了下来，正好与前文中闭包的概念相对应，被引用的自由变量和引用它的函数共同构成了一个上下文一起存在，并且也不会因为离开了创造了它的环境(此例中是newCounter函数)而销毁。counter2与counter1输出不同的是因为counter1与counter2分属于不同的闭包(二次调用newCounter产生了二个闭包)，所以二个函数对应的内存也是不同(上面print(counter1, counter2已经说明问题))。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>也就是说，闭包的生成一定伴随着对自由变量的引用，即upvalue引用。而没有upvalue的一定不是闭包，<strong>并且闭包和匿名函数没有必然联系</strong>，好多人有这种感觉，只是因为闭包好多的表现形式是匿名函数，类似上面的例子，newCounter内部的就是一个匿名函数，但是上面的例子完全可以这么来写：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span></span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- ...</span></span><br></pre></td></tr></table></figure>
<p>这样返回的counter一样是闭包，但是却不是匿名函数(没有名字的函数)。</p>
</div></section></div><div class="container"><ul class="nav"><li>上一篇：<a href="/2017/02/10/关于URL编码.html">关于URL编码</a></li><li>下一篇：<a href="/2017/01/30/那些童年通关几十遍的游戏们.html">那些童年通关几十遍的游戏们</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><center class="span">2014-2018 bugcode.</center></div></footer><script src="/script/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/script/index.js"></script><script src="/script/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/script/index.js"></script><script src="/script/post.js"></script></body></html>