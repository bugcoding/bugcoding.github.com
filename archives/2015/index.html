<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="keep coding, keep moving..."><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>bugcode's note</title><link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="author"><div class="author-name"><a href="/">bugcode's note</a></div><div class="about-me">思绪如风，来去匆匆。</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">Archives</a></li><li><a href="/about">About</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.jpg"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/bugcoding"></span><a href="https://github.com/bugcoding" target="_blank" title="https://github.com/bugcoding">https://github.com/bugcoding</a></li></ul></div></div></div></header><div class="container"><div class="year-wrap"><div class="year"><a class="title" href="/archives/2015">2015</a></div></div><div class="archives"><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">06-15</div><div class="post-archive__body"><a class="post-archive__title" href="/2015/06/15/C和C-与Java互相调用-续.html">C和C++与Java互相调用(续)</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>上一篇说的是java的本地调用，即使用jni完成java调用c/c++编写的代码，这回仍然是使用jni，不过是倒过来，使用c/c++调用java编写的代码。本次使用环境是：<strong>centos5.4</strong>，<strong>gcc4.9.0</strong>，<strong>jdk1.6_45</strong>。</p></div></div></div></div></div><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">06-05</div><div class="post-archive__body"><a class="post-archive__title" href="/2015/06/05/C和C-与Java的互相调用.html">C和C++与Java的互相调用</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>因为adnroid项目中用到了获取mac地址做为唯一码的功能，c和c++在android却没有对应的api，还好有jni这个东西，用java写好获取mac地址的代码，用c/c++调用代码就可以直接获取mac字符串了。</p></div></div></div></div></div><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">05-16</div><div class="post-archive__body"><a class="post-archive__title" href="/2015/05/16/Linux下的umask.html">Linux下的umask</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>​        偶然看到一本书上写umask(掩码)的计算，说是用户的实际文件(夹)权限是通过默认文件(夹)权限与掩码相减得到的。感觉不太对。</p></div></div></div></div></div><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">04-19</div><div class="post-archive__body"><a class="post-archive__title" href="/2015/04/19/使用SIGCHLD信号异步清理子进程.html">使用SIGCHLD信号异步清理子进程</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>首先说为什么要清理子进程（由父进程），在Unix系统中经常会听到一个词“僵尸进程”(Zombie Process[可不是植物大战僵尸^_*])，而“僵尸进程”就是由子进程而来的。</p></div></div></div></div></div><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">03-29</div><div class="post-archive__body"><a class="post-archive__title" href="/2015/03/29/Lua简要笔记-2.html">Lua简要笔记-2</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>接上文，控制语句下来就是一门语言不可或缺的一部分—函数。</p></div></div></div></div></div><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">03-24</div><div class="post-archive__body"><a class="post-archive__title" href="/2015/03/24/Lua简要笔记-1.html">Lua简要笔记-1</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>Lua简要笔记。</p></div></div></div></div></div><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">03-10</div><div class="post-archive__body"><a class="post-archive__title" href="/2015/03/10/归并排序图解.html">归并排序图解</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>归并排序笔记，记录下来也希望可以帮助他人，尽可能说得明白。</p></div></div></div></div></div><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">02-15</div><div class="post-archive__body"><a class="post-archive__title" href="/2015/02/15/快速排序图解.html">快速排序图解</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>快速排序原理记录及实现，用了几张图示，虽然是篇笔记，但尽力让所有人明白。</p></div></div></div></div></div><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">01-07</div><div class="post-archive__body"><a class="post-archive__title" href="/2015/01/07/Windows下编译Clang.html">Windows下编译Clang</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>网上最近一直在说Clang这个编译器，说FreeBSD已完全使用Clang为默认编译器，Mac下也是这个编译器，“据说”编译速度比Gcc快出很多，生成出来的可执行文件也比Gcc生成的要小那么几个KB，还有错误提示也要友好很多，更还有各方“大家”对此嗤之以鼻。但是不管如何，做为一个喜欢瞎折腾的码农，不管各个大家是怎么说，自己一定要上手试试的。因为在Windows下没有Clang的二进制包，本着自己动手丰衣足食的原则，决定自己构建一个尝尝鲜（虽然这个’鲜’已然过去很久了）， 其实构建过程很简单，官网上的getting started说得很明确了，这里也只是再用中文重复一下：</p></div></div></div></div></div></div></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><center class="span">2014-2018 bugcode.</center></div></footer><script src="/script/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/script/index.js"></script></body></html>