<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bugcode&#39;s Note</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bugcode.net/"/>
  <updated>2018-07-15T06:52:14.083Z</updated>
  <id>http://bugcode.net/</id>
  
  <author>
    <name>bugcode</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《IT简史》速读</title>
    <link href="http://bugcode.net/2017/03/15/%E3%80%8AIT%E7%AE%80%E5%8F%B2%E3%80%8B%E9%80%9F%E8%AF%BB.html"/>
    <id>http://bugcode.net/2017/03/15/《IT简史》速读.html</id>
    <published>2017-03-15T05:43:08.000Z</published>
    <updated>2018-07-15T06:52:14.083Z</updated>
    
    <content type="html"><![CDATA[<p>凑单买了一本叫《IT简史》的书，一下午的时间翻了一遍，书本身没什么亮点，非常浅，也没有编著者的个人观战，感觉就是一本简版的Wiki百科的集合，不过翻一下也还好，有些事件和概念还是以前不知道了，就当补充计算机历史知识了。</p><ol><li><p><code>腓尼基字母</code>，这些一千多年前的象形文字居然还在Unicode里，U+10900 - U+1091F段内，图片摘自Wiki百科:</p><p><img src="https://i.loli.net/2018/07/15/5b4ae0b0c8d83.png" style="zoom:50%"></p></li></ol><ol start="2"><li><p>最早的纸带打孔的计算机雏形居然是来自于一个叫<code>雅卡尔</code>的织布机上，这个台织布机使用纸带打孔来控制纺织的不同样式。</p></li><li><p>一直以为答题卡(2B铅笔涂黑块的那种答题卡)的读卡机是一种高科技，原来最早的读卡机1931年就研制出来了。</p></li><li><p><code>蜂窝网络(Cellular network)</code>，叫蜂窝是因为最初设计信号塔的六边形布置的构想，因为六边形布置会使相同覆盖面积下这样的布置需要的信号塔数量最少，而六边形又像蜂窝的形状。</p></li><li><p>第一款编译器叫<code>A-0</code>，将数学符号转换为机器指令。</p></li><li><p>IBM的大型机系统<code>System/360</code>，投入6万名员工，51亿美元，其项目经理根据这个项目的经验总结写了出软件工程的神书《人月神话》，到现在还是畅销书。</p></li><li><p><code>RPG</code>除了角色扮演游戏的意思之外，还是IBM研发一款报表生成器(Report Program Generator)。当然还是一种武器: <em>肩扛火箭榴弹</em>。</p></li><li><p><code>结构化编程概念</code>由Dijkstra提出，写了一篇名为《Go To Statement Considered Harmful》的论文，提出goto语句使程序流程混乱，并提出了结构化编程的概念，同时他也是Dijkstra最短路径算法和银行家算法(操作系统资源分配解决方案)的作者。</p></li><li><p><code>RFC</code>(Request For Comment)请求评议，互联网标准一系列编号排定的文件都使用这个命令，比如RFC1738就是URL编码标准的文件。</p></li><li><p>1992年美国计算机协会还发布了一个叫<code>IT与职业道德</code>的东西，提倡了一堆类似<em>不允许使用计算机做损害他人的事</em>之类的东西。</p></li><li><p>现在准备看一下<code>《格列佛游记》</code>这本书，一来是大小端这个叫法来自格列佛游记，雅虎公司这个名字(Yahoo!)这个名字也来自于格列佛游记。</p></li><li><p><code>蓝牙</code>这个词居然是来自于布鲁图斯国王名字首字母的北欧古字母的表示，使用他的名字是因为这个国王把分裂的挪威，丹麦，瑞典统一起来，爱立信，诺基亚，IBM几家公司联合推出这个无线通讯技术取名为这个国王的名字应该就是取其<code>统一</code>的意义，可能就是表示通过无线通讯技术把各个平台都<code>统一</code>连结起来的意思吧。</p><p><img src="https://i.loli.net/2018/07/15/5b4aec1da38c2.png" alt="截图来自Wiki"></p></li><li><p><code>千年虫</code>，以为是人为制造的一种病毒，原来就是全世界的计算机系统在2000年前对年的表示都使用后二位，2000前一直没什么问题，但是到2000年，00这种表示就出现了问题，可能是1900，也可能是2000，这样计算机对时间表示出错，就造成了各种问题。</p></li><li><p><code>Web 2.0</code>相对于<code>Web 1.0</code>，Web 2.0是一个概念，指的是用户为根本，用户做为内容的生产者和传播者。而Web 1.0 指用户只是内容的消费者。Web 2.0就是一个概念，互联网用户角色转变的的过程。</p></li><li><p><code>蓝光光盘</code>，叫蓝光的原因是这种光盘是使用405纳米长的激光对光盘进行读写。Blu-ray商标不叫Blue-ray，是因为注册商标时Blue ray是一个常用词而不允许注册，所以去掉了Blue中的e。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;凑单买了一本叫《IT简史》的书，一下午的时间翻了一遍，书本身没什么亮点，非常浅，也没有编著者的个人观战，感觉就是一本简版的Wiki百科的集合，不过翻一下也还好，有些事件和概念还是以前不知道了，就当补充计算机历史知识了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;腓尼基字母
      
    
    </summary>
    
    
      <category term="Reading" scheme="http://bugcode.net/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>五读《Expert C Programming》</title>
    <link href="http://bugcode.net/2017/03/05/%E4%BA%94%E8%AF%BB%E3%80%8AExpert-C-Programming%E3%80%8B.html"/>
    <id>http://bugcode.net/2017/03/05/五读《Expert-C-Programming》.html</id>
    <published>2017-03-05T02:26:24.000Z</published>
    <updated>2018-07-11T14:47:17.395Z</updated>
    
    <content type="html"><![CDATA[<p>闲着没事儿在书架上找书看，又看到了翻得有些旧的《C专家编程》拿起来又翻了一遍，大二买的书，前后看了四遍，这是第五遍，每次看看都能有一点儿新的收获，。</p><h5 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h5><p>是来源来Ada语言的一个编译器指示符，#pragma是由编译器来指定的具体效果，书上记录了一个很意思的关于GNU C 1.3.4版本编译器#pragma指示符的效果:</p><blockquote><p>GNU C 1.3.4编译器在遇到#pragma指示符的时候，首先会尝试运行”hack”游戏，如果失败，会再尝试运行”Rogue”游戏，如果还失败，就继续尝试打开Emacs编辑器并运行”汉诺塔”游戏，最后再失败，编译器才报错。</p><p>「Rogue」: Unix上的迷宫探索游戏，具体可参见此<a href="https://zh.wikipedia.org/wiki/Rogue" target="_blank" rel="noopener">Wiki</a></p><p>「Hack」: 地牢探索游戏，具体参见<a href="https://en.wikipedia.org/wiki/Hack_%28video_game%29" target="_blank" rel="noopener">Wiki</a></p></blockquote><p>几个经常用的#pragma</p><ol><li><p>编译时打印消息 <code>#pragma message(&quot;compile message&quot;)</code></p></li><li><p>屏蔽特定编译警告 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic ignored <span class="meta-string">"具体的警告字符串"</span></span></span><br></pre></td></tr></table></figure></li><li><p>微软系的msvc使用方法和GCC的不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  <span class="meta-keyword">warning</span>( push ) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  <span class="meta-keyword">warning</span>( disable: 具体的警告代码数字 ) <span class="comment">// 可以写多个警告的代码</span></span></span><br></pre></td></tr></table></figure></li><li><p>设置内存对齐 #pragma pack(内存对齐值)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack(push 4) <span class="comment">// 设置4个字节内存对齐</span></span></span><br></pre></td></tr></table></figure></li><li><p>gcc的pragma文档可以在<a href="https://gcc.gnu.org/onlinedocs/gcc-5.4.0/gcc/Pragmas.html" target="_blank" rel="noopener">这里</a>找到。</p></li></ol><h5 id="NUL与NULL"><a href="#NUL与NULL" class="headerlink" title="NUL与NULL"></a>NUL与NULL</h5><p>平时用习惯了，真正说一下二个的区别可能并不能说得特别清楚。</p><p><code>NUL</code>表示ASCII码结束的字符，即是<code>&#39;\0&#39;</code>的字符名字，就是空字符的意思，但是不要误认为这是C的的一个宏定义，这样写是<strong><em>不正确</em></strong>的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">8</span>] = <span class="string">"Hello"</span>;</span><br><span class="line">    str[<span class="number">5</span>] = NUL; <span class="comment">// 并没有预定义的一个叫NUL的宏</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NULL</code>表示0，内存的0位置(内存地址较低的位置都是操作系统预留的)，表示空指针，即指针没有指向任何内容，指针初始化为空的时候都使用<code>NULL</code>赋值。</p><h5 id="setjmp-longjmp"><a href="#setjmp-longjmp" class="headerlink" title="setjmp longjmp"></a>setjmp longjmp</h5><p>C语言中比<code>goto</code>更强大的改变控制流的机制，平常很少用，经常忘记用法。</p><p><code>setjmp(jmp_buf j)</code>是一个宏，调用处就是标记当前的调用环境的上下文，保存当前的调用堆栈，用来调用<code>longjmp</code>的时候将控制流返回到这里再次执行，第一次调用<code>setjmp</code>时一定返回0。</p><p><code>longjmp(jmp_buf j, int return_value)</code>这里的j就是<code>setjmp</code>时设置<code>jmp_buf</code>(保证jmp_buf不变)，<code>return_value</code>就是指定控制流返回<code>setjmp</code>时，<code>setjmp</code>再调用一遍时返回的值。</p><p>这个强大控制流转移机制，可以实现C语言的异常处理，看个简单的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jmp_buf context;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memory_handler</span><span class="params">(<span class="keyword">void</span> *mem_pointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mem_pointer)</span><br><span class="line">    &#123;</span><br><span class="line">        longjmp(context, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other logic ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> rval = setjmp(context);</span><br><span class="line">    <span class="keyword">if</span> (rval)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"return value %d\n"</span>, rval);</span><br><span class="line">        <span class="keyword">switch</span> (rval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"nullpointerexception check memory alloc\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// ... other handler</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        memory_handler(pointer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>memory_handler</code>发现pointer是空指针之后重新将控制流程移回<code>setjmp</code>带着新的返回值1，然后就进入第一个分支对应的处理语句，最终输出<code>nullpointerexception check memory alloc</code>。</p><p><code>goto</code>语句只能在同一个函数中跳转到一个指定标签处的代码，而<code>longjmp</code>可以跨越函数跳转，是C中一个强大的机制。</p><p>使用<code>setjmp</code>时需要注意一点，如果<code>setjmp</code>不在<code>main</code>函数中调用而是在其他自定义函数中调用，那一旦这个自定义调用的函数返回，对应记录的调用上下文环境的<code>jmp_buf</code>也就失效了，longjmp再调用时，就回不到<code>jmp_buf</code>记录的控制流处了，像下面这个例子，代码不会有任何输出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jmp_buf context;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp_exp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longjmp(context, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp_within_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setjmp(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rval = setjmp_within_func();</span><br><span class="line">    <span class="keyword">if</span> (rval)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"return value %d\n"</span>, rval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        longjmp_exp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;闲着没事儿在书架上找书看，又看到了翻得有些旧的《C专家编程》拿起来又翻了一遍，大二买的书，前后看了四遍，这是第五遍，每次看看都能有一点儿新的收获，。&lt;/p&gt;
&lt;h5 id=&quot;pragma&quot;&gt;&lt;a href=&quot;#pragma&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="C" scheme="http://bugcode.net/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>关于URL编码</title>
    <link href="http://bugcode.net/2017/02/10/%E5%85%B3%E4%BA%8EURL%E7%BC%96%E7%A0%81.html"/>
    <id>http://bugcode.net/2017/02/10/关于URL编码.html</id>
    <published>2017-02-10T03:48:17.000Z</published>
    <updated>2018-07-06T11:09:33.616Z</updated>
    
    <content type="html"><![CDATA[<p>在写上一篇博客之前，我一直对URL编码没什么概念，看到网页链接上一串百分号加数字的字符串时会短暂的想想，因为工作中也不涉及到具体的URL编码的部分，一直也没深入过，而促使我写下来记录就是上一篇博客中markdown解析的时候出了一点小问题(markdown链接是放在小括号里面的，然后放在小括号的链接本身也包含小括号，这时markdown解析出了问题)，然后查问题的时候就查到了URL编码的相关知识，这几天又查阅了资料，简要写在这里，深化一下记忆。</p><h5 id="什么是URL编码"><a href="#什么是URL编码" class="headerlink" title="什么是URL编码"></a>什么是URL编码</h5><p>什么是URL？URL是Uniform Resource Locator(统一资源定位符)的缩写，就是平常说的网页地址，像<code>www.google.com</code>就是个URL。而URL编码就是把URL里面的字符按照一定的规则标准进行编码，产生一个国际范围内通用的字符串(ASCII码串)，这里是<a href="https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E5%8F%B7%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">Wiki上URL编码的解释</a>，可以看到Wiki上的关键词是percent-encoding，因为URL编码针对每个字符的编码都使用<strong>%</strong>做前缀转义字符。</p><h5 id="为什么需要URL编码"><a href="#为什么需要URL编码" class="headerlink" title="为什么需要URL编码"></a>为什么需要URL编码</h5><p>URL就是统一为网络上资源命名，万维网遍及世界，所以URL需要具有通用性(世界范围内通用，跨语言，跨地区时区)，具有通用性的同时还要有完整性，不能因为URL中带了一些特殊字符就导致URL在传输过程中丢失了信息(比如URL中带有某个特定国家的文字)，否则就失去了URL的意义，定位不到资源，因此<a href="https://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">RFC1738</a>网络标准对URL做了硬性的规定(可以在上面的链接里看到具体RFC1738对URL的规定)，除了一些ascii字符和特殊的保留字符可以直接用于URL，其他的字符都需要经过编码才可以用于表示URL，这样经过标准规则对URL进行编码，所有的特殊字符都可以用标准中规则的字符进行编码，世界范围内使用相同的规则，编码解码达成一致，通用性和完整性都得到了保证。</p><h5 id="URL编码的规则标准"><a href="#URL编码的规则标准" class="headerlink" title="URL编码的规则标准"></a>URL编码的规则标准</h5><p>当前的URL编码标准是对所有URL标准内的保留字符不进行百分号的编码，其他的一律先转换成UTF-8的字节(每个单独的字节转换为十六进制位再在前面都加百分号)表示，再在其前面加上百分号(<strong>%</strong>)。下面用简单的例子来演示一下URL编码标准的过程。</p><h5 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h5><p>因何而起，便以何结束，既然是上次写的博客，就以上次博客地址为例(只取一个汉字做为例子，不按个分析演示了)，地址是<code>https://bugcode.net/2017/02/05/闭包等于匿名函数吗</code>，这里只取<code>闭</code>这个字，来演示URL编码的过程：</p><ol><li><p>汉字不是RFC1738标准中规则的保留字，所以要取<code>闭</code>字的UTF-8编码，其对应的十六进制Unicode码是<code>95ED</code>。</p></li><li><p>再将对应的Unicode码转换为对应的UTF-8字节，转换需要UTF-8转换表，通过转换表，获取当前<code>95ED</code>对应的UTF-8字节序列，下面是一张UTF-8转换表:</p></li></ol><table><thead><tr><th style="text-align:center">unicode</th><th>UTF-8</th></tr></thead><tbody><tr><td style="text-align:center">0000 - 007F</td><td>0#######</td></tr><tr><td style="text-align:center">0080 - 07FF</td><td>11##### 10######</td></tr><tr><td style="text-align:center">0800 - FFFF</td><td>1110#### 10###### 10######</td></tr><tr><td style="text-align:center">10000 - 1FFFFF</td><td>11110####  10######  10###### 10######</td></tr></tbody></table><ol start="3"><li><p>上面表格中左侧是Unicode码对应范围，右侧是UTF-8对应字节序列表示，#代表对应Unicode码对应的二进制位，依次填入，后面不够的补0，具体可以查阅UTF-8编码规则相关资料，<code>95ED</code>对应范围在0800 - FFFF范围内，即<code>闭</code>字需要三个字节表示。HEX(<code>95ED</code>) = BIN(<code>10010101 11101101</code>)，对应转换表，可得到对应的UTF-8字节序列分别是(把<code>95ED</code>二进制位分别按位填入<code>1110#### 10###### 10######</code>的#位置中)</p><blockquote><p>第一个字节需要填入4位，即: <code>1110 1001</code></p><p>第二个字节填入6位，即: <code>10 010111</code></p><p>第三个字节填入6位，即: <code>10 101101</code> </p></blockquote><p>三个字节对应的二进制位，再转换为十六进制分别是:</p><blockquote><p>BIN(<code>1110 1001</code>) = HEX(<code>E9</code>)</p><p>BIN(<code>10 010111</code>) = HEX(<code>97</code>)</p><p>BIN(<code>10101101</code>) = HEX(<code>AD</code>)</p></blockquote><p>根据规则，标准之内的保留字不需要填加<strong>%</strong>前缀转义进行编码，最后上面的链接<code>https://bugcode.net/2017/02/05/闭</code>(只取一个汉字做例子演示，其余同理)经过URL编码之后就是<code>https://bugcode.net/2017/02/05/%E9%97%AD</code></p></li><li><p>最后用JS的encodeURI函数来验证一下结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">encodeURI</span>(<span class="string">"https://bugcode.net/2017/02/05/闭"</span>)+ <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>代码输出: <code>https://bugcode.net/2017/02/05/%E9%97%AD</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在写上一篇博客之前，我一直对URL编码没什么概念，看到网页链接上一串百分号加数字的字符串时会短暂的想想，因为工作中也不涉及到具体的URL编码的部分，一直也没深入过，而促使我写下来记录就是上一篇博客中markdown解析的时候出了一点小问题(markdown链接是放在小括号里
      
    
    </summary>
    
    
      <category term="Theory" scheme="http://bugcode.net/tags/Theory/"/>
    
  </entry>
  
  <entry>
    <title>闭包 == 匿名函数?</title>
    <link href="http://bugcode.net/2017/02/05/%E9%97%AD%E5%8C%85%E7%AD%89%E4%BA%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%90%97.html"/>
    <id>http://bugcode.net/2017/02/05/闭包等于匿名函数吗.html</id>
    <published>2017-02-05T13:39:17.000Z</published>
    <updated>2018-07-05T15:43:40.953Z</updated>
    
    <content type="html"><![CDATA[<p>和同事讨论Java 8的lambda表达式，然后就说起了<code>闭包</code>，然后发现在不在少数的人对闭包的理解就是闭包就是个<em>匿名函数</em>，甚至就认为这二个是互通的。</p><blockquote><p><del>匿名函数就是闭包，闭包就是匿名函数</del>。</p></blockquote><p>结果自然就是一通争论，争论过程中，突然发现有些概念给对方解释的时候也不是能说得特别清楚，这里再对闭包这个概念整理深化一下。</p><h5 id="闭包概念"><a href="#闭包概念" class="headerlink" title="闭包概念"></a>闭包概念</h5><p>详细的概念可以看下<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29" target="_blank" rel="noopener">wiki</a>，这里引用一下wiki上对<code>闭包</code>的解释：</p><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>中，<strong>闭包</strong>（英语：Closure），又称<strong>词法闭包</strong>（Lexical Closure）或<strong>函数闭包</strong>（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p></blockquote><p>这个解释，重点在于这句<code>被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外</code>，仔细看一下这句话，问题又来了，自由变量是什么?</p><h5 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h5><p>Google查<em>自由变量</em>会出现另一个对应的词<em>约束变量</em>，具体解释在这个<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%8F%98%E9%87%8F%E5%92%8C%E7%BA%A6%E6%9D%9F%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">链接</a>，约束变量字面解释自然是受约束的变量，其实也就是某个作用域内有效的变量，其有效范围受到约束，针对非函数式语言来说，就是函数内部的局部变量，函数的参数，这都属于<em>约束变量</em>，而非函数式语言中的全局变量，可以对应为<em>自由变量</em>，即不受某个特定的作用域限制。而对于函数式语言，可以在函数内定义函数，例如在<strong>F</strong>函数中定义了<strong>I</strong>函数，<strong>I</strong>函数内的变量是约束变量，但是在<strong>F</strong>函数内定义的变量v对于<strong>I</strong>函数来说，就是自由变量，因为v变量不受<strong>I</strong>函数的作用域限制，通常叫这个v变量为upvalue，而闭包中upvalue才是最重要的。</p><h5 id="再看闭包解释"><a href="#再看闭包解释" class="headerlink" title="再看闭包解释"></a>再看闭包解释</h5><p>这时再回头看闭包的解释<code>被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外</code>，闭包的核心概念是需要<strong>引用自由变量</strong>的函数，即自由变量与引用它的函数共同树成闭包，并且在产生调用的时候，自由变量与对应的函数共同组成的上下文不会因为函数的外层函数(产生闭包的函数，上面例子中的<strong>F</strong>函数)的返回而销毁，这样才是一个完整的闭包概念。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>下面用Lua来解释上面所说的这些概念，现成的例子就是<a href="https://www.lua.org/pil/6.1.html" target="_blank" rel="noopener">Lua官方教程</a>中的newCounter的例子:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- 局部变量i，newCounter函数内有效</span></span><br><span class="line">    <span class="keyword">local</span> i = <span class="number">0</span> </span><br><span class="line">    <span class="comment">-- 返回一个匿名函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span> </span><br><span class="line">        <span class="comment">-- 引用了一个上层函数作用域中的变量</span></span><br><span class="line">        <span class="comment">-- 这里i就是upvalue</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">counter1 = newCounter()</span><br><span class="line">counter2 = newCounter()</span><br><span class="line"><span class="comment">-- 这里输出二个不同的地址，即返回了不同的函数</span></span><br><span class="line"><span class="built_in">print</span>(counter1, counter2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出 1 2 3</span></span><br><span class="line"><span class="built_in">print</span>(counter1())</span><br><span class="line"><span class="built_in">print</span>(counter1())</span><br><span class="line"><span class="built_in">print</span>(counter1())</span><br><span class="line"><span class="comment">-- 输出1 2</span></span><br><span class="line"><span class="built_in">print</span>(counter2())</span><br><span class="line"><span class="built_in">print</span>(counter2())</span><br></pre></td></tr></table></figure><p>counter1与counter2分别是newCounter返回来的函数，二个互不相干，这点可以理解，而counter1连结调用三次，i的值保持递增，并没有因为newCounter函数返回而在匿名函数中销毁，而是和匿名函数一起组成的环境在内存中保留了下来，正好与前文中闭包的概念相对应，被引用的自由变量和引用它的函数共同构成了一个上下文一起存在，并且也不会因为离开了创造了它的环境(此例中是newCounter函数)而销毁。counter2与counter1输出不同的是因为counter1与counter2分属于不同的闭包(二次调用newCounter产生了二个闭包)，所以二个函数对应的内存也是不同(上面print(counter1, counter2已经说明问题))。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>也就是说，闭包的生成一定伴随着对自由变量的引用，即upvalue引用。而没有upvalue的一定不是闭包，<strong>并且闭包和匿名函数没有必然联系</strong>，好多人有这种感觉，只是因为闭包好多的表现形式是匿名函数，类似上面的例子，newCounter内部的就是一个匿名函数，但是上面的例子完全可以这么来写：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span></span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- ...</span></span><br></pre></td></tr></table></figure><p>这样返回的counter一样是闭包，但是却不是匿名函数(没有名字的函数)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;和同事讨论Java 8的lambda表达式，然后就说起了&lt;code&gt;闭包&lt;/code&gt;，然后发现在不在少数的人对闭包的理解就是闭包就是个&lt;em&gt;匿名函数&lt;/em&gt;，甚至就认为这二个是互通的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;del&gt;匿名函数就是闭包，闭包就是匿名函
      
    
    </summary>
    
    
      <category term="Theory" scheme="http://bugcode.net/tags/Theory/"/>
    
  </entry>
  
  <entry>
    <title>那些童年通关几十遍的游戏们</title>
    <link href="http://bugcode.net/2017/01/30/%E9%82%A3%E4%BA%9B%E7%AB%A5%E5%B9%B4%E9%80%9A%E5%85%B3%E5%87%A0%E5%8D%81%E9%81%8D%E7%9A%84%E6%B8%B8%E6%88%8F%E4%BB%AC.html"/>
    <id>http://bugcode.net/2017/01/30/那些童年通关几十遍的游戏们.html</id>
    <published>2017-01-30T15:39:20.000Z</published>
    <updated>2018-07-02T17:05:38.252Z</updated>
    
    <content type="html"><![CDATA[<p>岁数越来越大，回老家过年也感觉越来越没意思，今天闲得没事儿，在旧柜子里面翻腾，找到了这二个东西 – 当年超级奢侈带电池可以保存进度的FC游戏卡带:</p><p>这个是《吞食天地III》,没记错的话应该是类似《火焰纹章》战棋类的游戏，扮演不同阵营的人使用不同的技能，比如黄忠就是射箭，能打三格，刘备用剑，能打一格，类似这种</p><p><img src="/chapimages/play_fc1.jpeg" alt="吞食天地"></p><p>这个叫《夺宝小英豪》，具体内容已经完全没有印象了，估计是这个游戏一点也不好玩儿🤪</p><p><img src="/chapimages/play_fc2.jpg" alt="夺宝小英豪"></p><p>说起这些，当真是回忆无限，那个时候买了好多这种卡带，普通的卡带像《超级玛利》只有十块钱(荒野乡村，那个时候想买正版也买不到)，而这种带纽扣电池的带子就要三十多块，当时要攒好久好久才能买，还得偷偷的买，不然就是一顿「男女混双」。</p><p>至今还难忘的有四个这样的RPG游戏带子，有二个都是耗了好久全通关，有一个借的带子快速的通了，另外一个永远也通不了关…</p><p>第一个是斥巨资(四十多元，现在想想也的确值)买的叫<strong>《重装机兵》</strong>的废土题材的RPG，前后通关了差不多几十遍，当时游戏的每一个细节都能记住，甚至现在想一下里面红狼之死的情节，还有些感触。玩了这么多游戏，现在还会时不时回想一下《重装机兵》(英文Metal Max，重装机兵粉丝叫MM粉)一代的情节，现在也还会关注一些MM相关的信息，包括有人搞的<a href="http://zzjb.leiling.org/" target="_blank" rel="noopener">重装机兵的个人资料站</a> ，类似<a href="https://www.zhihu.com/question/21095584" target="_blank" rel="noopener">知乎这种讨论</a>，还能看得津津有味，可惜在柜子里翻了半天，也没有找到原来的卡带…</p><p>第二个是看到卡带店老板玩儿的<strong>《吞食天地-孔明传》</strong>，当时看的时候感觉战斗系统真好用，地图又大，还能各种换武将，各种武器，当时就没忍住就买下来了，之后和小伙伴玩儿的不亦乐乎，过五半斩六将，三顾茅庐，火烧博望坡，收服姜维，想想那时的心情，现在都有点儿小激动。战斗画面大概是这个样子的:</p><p><img src="/chapimages/tushitiandi.jpeg" alt=""></p><p>因为控制里面有个叫<code>总攻</code>的菜单，按了就直接回合制自动开打，一般不遇到boss级的怪，几乎不咋用按手柄，这个应该是玩儿的比较轻松的游戏。</p><p>第三个是与同道小伙伴借的<strong>《封神榜》</strong>，因为是借的，所以玩儿的也特别仔细，现在还记得在姜子牙没学会抽魂术之前，遇见小怪都得逃跑，仍然记得过十殿阎王剧情时候的战战兢兢，会了抽魂术之后整个游戏的难度降了N个等级，后面几乎就是平趟过剧情。</p><p>第四个卡带，也是印象最深的，没记错的话应该叫<strong>《三侠五义》</strong>，讲展昭和白玉堂的，这个游戏没有那么好玩儿，印象深纯属就是这个游戏有bug(当年认为是bug，现在看就是开发人员个偷懒)，展昭是主角只能升到23级，血量最大只到999，然而在中期的时候就遇上了死对头白玉堂，999的血无论怎么打都打不过，倔强的我在整整一个月放学就磕白玉堂剧情中度过，最后无奈放弃，网上找了一个这个倒霉催的游戏截图:</p><p><img src="/chapimages/sanxiawuyi.png" alt=""></p><p>没错！就是右下角那个<code>体</code>最多就到999，现在想想，那个程序员是用了一个什么类型来存的血量。</p><p>写到这的时候就会想，小时候玩儿了这么多游戏，而现在做为一个开发游戏的苦逼程序员，这一切是不是安排好的😂。<em>岁数大了爱回忆，找不到当年玩儿过的最爱的卡带，今晚注定要不眠了~</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;岁数越来越大，回老家过年也感觉越来越没意思，今天闲得没事儿，在旧柜子里面翻腾，找到了这二个东西 – 当年超级奢侈带电池可以保存进度的FC游戏卡带:&lt;/p&gt;
&lt;p&gt;这个是《吞食天地III》,没记错的话应该是类似《火焰纹章》战棋类的游戏，扮演不同阵营的人使用不同的技能，比如黄忠
      
    
    </summary>
    
    
      <category term="life" scheme="http://bugcode.net/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Git小记(基础命令)</title>
    <link href="http://bugcode.net/2016/10/22/Git%E5%B0%8F%E8%AE%B0.html"/>
    <id>http://bugcode.net/2016/10/22/Git小记.html</id>
    <published>2016-10-22T13:02:44.000Z</published>
    <updated>2018-06-30T11:01:40.988Z</updated>
    
    <content type="html"><![CDATA[<p>之前用Git都是直接使用SourceTree这个开源的Git图形界面的客户端，输入log，提交，从远程pull更新，都是点几下按钮，从来没有在命令行里面操作过Git，开始bugcodeCalendar这个项目之后，开始尝试完全用命令行进行Git的操作，四月份开始的这个小项目，一直到现在，断断续续的业余时间也有几个月了，现在命令行里操作Git算是『行动自如』了，这里对这几个月的使用总结一下，也算备忘吧。</p><h4 id="创建仓库，添加文件，提交"><a href="#创建仓库，添加文件，提交" class="headerlink" title="创建仓库，添加文件，提交"></a>创建仓库，添加文件，提交</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init  # 把当前目录当做Git仓库</span><br><span class="line">git add filename1,filename2 # 可以多个文件名，也可以使用通配符号</span><br><span class="line">git commit -m "提交注释" # 将已add的文件都提交到仓库</span><br><span class="line"><span class="meta">#</span><span class="bash"> 还可以像下面这样直接add并提交，commit的时候加入-a参数</span></span><br><span class="line">git commit -am "提交注释" # 会把当前没有add的文件先add再提交</span><br></pre></td></tr></table></figure><h4 id="查看工作区状态"><a href="#查看工作区状态" class="headerlink" title="查看工作区状态"></a>查看工作区状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status # 会显示当前工作区中的哪些修改，增加，删除，显示未被版本管理的文件</span><br></pre></td></tr></table></figure><h4 id="Log，回退，HEAD"><a href="#Log，回退，HEAD" class="headerlink" title="Log，回退，HEAD"></a>Log，回退，HEAD</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log 各种参数 # log后面参数可以自定义，可以参照文档定制自己需要的</span><br><span class="line">git reset --hard 提交的id # 重置文件内容到某个提交</span><br></pre></td></tr></table></figure><h4 id="工作区，暂存区概念"><a href="#工作区，暂存区概念" class="headerlink" title="工作区，暂存区概念"></a>工作区，暂存区概念</h4><p>下图展示了工作区，暂存区，仓库的关系，以及何种操作对应文件在什么区</p><p><img src="/chapimages/git_pic.jpg" alt=""></p><h4 id="回退修改"><a href="#回退修改" class="headerlink" title="回退修改"></a>回退修改</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- 文件名 # 根据上面的图可知，是从暂存区恢复至工作区</span><br><span class="line">git resetHEAD 文件名 # 从仓库中恢复到暂存区</span><br></pre></td></tr></table></figure><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm 文件名</span><br><span class="line">rm 文件名 &amp;&amp; git commit</span><br></pre></td></tr></table></figure><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch # 查看所有分支</span><br><span class="line">git branch 分支名字 # 创建分支</span><br><span class="line">git checkout 分支名字 # 切换分支</span><br><span class="line">git checkout -b 分支名字 # 创建同时切换到对应的分支</span><br><span class="line">git merge 分支名字 # 合并一个分支到当前所在分支</span><br><span class="line">git branch -d 分支名字 # 删除一个指定的分支</span><br></pre></td></tr></table></figure><h4 id="暂存，恢复"><a href="#暂存，恢复" class="headerlink" title="暂存，恢复"></a>暂存，恢复</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash # 将当前工作区改动暂存起来，把工作区变为clean状态</span><br><span class="line">git stash apply # 将暂存的改恢复到工作区</span><br></pre></td></tr></table></figure><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git tag # 查看所有标签</span><br><span class="line">git tag 标签名字  # 创建一个标签，默认HAED</span><br><span class="line">git tag -a 标签名字 -m "标签信息" # 指定标签信息</span><br><span class="line">git tag -s 标签名字 -m "标签信息" # 给标签签名</span><br><span class="line">git push origin 标签名字 # 向远程仓库推送一个标签</span><br><span class="line">git push origin --tags  # 把所有没推送的标签都推送到远程仓库</span><br><span class="line">git tag -d 标签名字 # 删除一个本地标签</span><br><span class="line">git push origin :refs/tags/标签名字 # 删除远程标签</span><br></pre></td></tr></table></figure><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff # 比较当前工作区与暂存区的不同</span><br><span class="line">git diff --cached # 比较的是暂存区与仓库最新提交的版本的不同</span><br><span class="line">git diff HEAD/提交id # 比较当前工作区+暂存区与仓库某个版本的不同</span><br><span class="line">git diff 提交id..提交id # 比较二次提交之间的不同，提交id如果省略，默认是HEAD</span><br><span class="line">git diff master..branch # 比较二个分支的不同</span><br></pre></td></tr></table></figure><p>git diff还有更多选项更多可定制的比较，具体可参照diff help。</p><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a><strong><em>小技巧</em></strong></h4><p>经常有这种需要，开了一个feature分支，添加了二个功能，结果一个功能写完了，另一个写到一半，要把这个已经写完的一个功能合并到主干上去，但是又不能像这样<code>git merge feature</code>直接合并分支，因为另一个功能只进行到一半。目的很明确只想把feature分支上的某几个文件合并到master上，可以这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master # 切到主干</span><br><span class="line">git checkout feature aFile,bFile,cFile # 将对应文件直接checkout到当前分支</span><br></pre></td></tr></table></figure><p>如是abc文件是新增的，这样没什么问题，如果cFile在master也有，并且做了修改，那这样就会把master上对应修改给覆盖掉，继续，从master创建一个临时分支，再把feature对应文件checkout到临时分支上去，再把临时分支合并回master，这样就达到了合并某分支的某几个文件到某分支的目的了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git checkout -b masterhelper</span><br><span class="line">git checkout feature aFile,bFile,cFile</span><br><span class="line">git checkout master</span><br><span class="line">git merge masterhelper</span><br><span class="line">git branch -d masterhelper</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前用Git都是直接使用SourceTree这个开源的Git图形界面的客户端，输入log，提交，从远程pull更新，都是点几下按钮，从来没有在命令行里面操作过Git，开始bugcodeCalendar这个项目之后，开始尝试完全用命令行进行Git的操作，四月份开始的这个小项目
      
    
    </summary>
    
    
      <category term="Git" scheme="http://bugcode.net/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>几个用到不多却很有用的C语言特性和小Tricky</title>
    <link href="http://bugcode.net/2016/09/17/%E4%B8%80%E4%BA%9B%E7%94%A8%E5%88%B0%E4%B8%8D%E5%A4%9A%E5%8D%B4%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84C%E8%AF%AD%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7.html"/>
    <id>http://bugcode.net/2016/09/17/一些用到不多却很有用的C语语言特性.html</id>
    <published>2016-09-17T10:21:39.000Z</published>
    <updated>2018-06-30T11:01:41.076Z</updated>
    
    <content type="html"><![CDATA[<p>几个C语言的特性和tricky，平时不常用到，却很有用，这里记录一下。</p><ol><li><p>数组传参时的<strong>static</strong>修饰，编译期检查数据长度，类似<code>void test_static(char param[static 5])</code>，意思就是传入的param的char类型数组参数至少要有五个元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// char param[static 1]检测NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_static</span><span class="params">(<span class="keyword">char</span> param[<span class="keyword">static</span> <span class="number">5</span>])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    test_static(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述写法就会出现如下警告:</p><blockquote><p>warning: array argument is too small; contains 3 elements, callee requires at least 5 [-Warray-bounds]</p></blockquote><p>可参考<a href="http://stackoverflow.com/questions/30453010/what-is-the-meaning-of-static-in-parameters-array-types-in-c" target="_blank" rel="noopener">这里</a>。</p></li><li><p>动态指定printf输出数据的长度。可以用这种方式指定浮点数小数部分的保留位数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">float</span> num = <span class="number">1.2432</span>;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"test statements"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num = %.*f\n"</span>, pre, num); <span class="comment">// 输出 1.234</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str = %.*s\n"</span>, pre, str); <span class="comment">// 输出 tes</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>printf还有一个格式参数<strong>%n</strong>，这个参数不输出任何内容，但是会把<strong>%n</strong>所在位置之前的字符计数都放入一个整型数值中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> out_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"test statements"</span>;</span><br><span class="line">    <span class="comment">// 回车之前的字符计数都会放在out_num中</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">printf</span>(<span class="string">"str = %.*s%n\n"</span>, pre, str, &amp;out_num); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"out_num=%d, ret = %d\n"</span>, out_num, ret); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>str = test<br>out_num=10, ret = 11</p></blockquote></li><li><p>c11添加了<strong>_Static_assert</strong>静态断言，在c11之前可以自行定义一个『静态断言』，即条件为假制造编译错误。(from stackoverflow)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_ASSERT(COND,MSG) typedef char static_assertion_##MSG[(!!(COND))*2-1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPILE_TIME_ASSERT3(X,L) STATIC_ASSERT(X,static_assertion_at_line_##L)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPILE_TIME_ASSERT2(X,L) COMPILE_TIME_ASSERT3(X,L)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPILE_TIME_ASSERT(X)    COMPILE_TIME_ASSERT2(X,__LINE__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    COMPILE_TIME_ASSERT(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)==<span class="number">5</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译提示如下:</p><blockquote><p>error: ‘static_assertion_static_assertion_at_line_11’ declared as an array with a negative size</p><p>COMPILE_TIME_ASSERT(sizeof(int) == 3);</p></blockquote></li><li><p>编译器的尝试性定义，代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>; <span class="comment">// 或者int i;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码不会报错，C标准是这样来解释的，因为声明是出现在文件域的，不是出现在某个函数域内，把其当做外部定义，同时编译器还根据定义是否有初始值来区分，带初值的就叫做定义，没有初始值的也没extern关键的字就是尝试性的定义，如果文件中同时出现了这二种(也就是一个是定义，一个是尝试性定义，像上文代码)，这样那个没有带初始值的就直接当做冗余定义来处理了，不会当做redefinition，如果二个都是没带初值的，也没带extern关键字的，编译器就会把这二个尝试性定义合并成为一个初始值为0的非尝试性定义。现在上面的代码会输出10，如果把<code>int i = 10</code>改为<code>int i;</code>，代码会输出0。</p></li><li><p>不能在一个返回类型为void的函数中写return void，但是可以返回执行一个返回void的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>网上很多例子说三元运算符可以这样用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    (y &lt; <span class="number">0</span> ? x : y) = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说三元运算符会产生一个左值，c语言里面是不可以的，这样编译:</p><blockquote><p>gcc -Wall -std=c99 test.c -o test</p></blockquote><p>会报编译错误，提示你表达式不能被赋值(<em>error: expression is not assignable</em>)。</p><p>但是在c++里的确可以。也就是上面这段代码用g++编译(会有警告)或者直接写一段c++的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    (y &lt; <span class="number">0</span> ? x : y) = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>g++ -Wall test.cpp -o test</p><p>./test </p></blockquote><p>会输出10 20。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;几个C语言的特性和tricky，平时不常用到，却很有用，这里记录一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;数组传参时的&lt;strong&gt;static&lt;/strong&gt;修饰，编译期检查数据长度，类似&lt;code&gt;void test_static(char param[static 
      
    
    </summary>
    
    
      <category term="C" scheme="http://bugcode.net/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Xcode-8使用XVim的问题</title>
    <link href="http://bugcode.net/2016/09/10/Xcode-8%E4%BD%BF%E7%94%A8XVim%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>http://bugcode.net/2016/09/10/Xcode-8使用XVim的问题.html</id>
    <published>2016-09-10T15:13:53.000Z</published>
    <updated>2018-06-30T11:01:40.863Z</updated>
    
    <content type="html"><![CDATA[<p>做为一个Vim党，几乎是有Vim插件的IDE都会安装上，然后各种跳转爽得飞起，Xcode上就是成名已久的了<a href="https://github.com/XVimProject" target="_blank" rel="noopener">XVim</a>，它还有一个<a href="http://xvim.org/" target="_blank" rel="noopener">官方网站</a>，但是一般的下载安装，直接去github就行了。最近使用最新Xcode安装XVim插件遇到了几个问题，发现在XVim的github上已经有老外提了issue，并且有了解决方式，总结记录一下。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>因为用到了Swift 3，所以早早就把Xcode升到了Xcode8 beta版本，像之前Apple官方出的Swift迁移指南说得一样，由Xcode7.3生成的Xcode工程，由Xcode8打开的时候会弹出一个迁移助手，然后把之前工程里不符合Swift3的代码做相应的改动。当然，也有工具不能识别和修改的，遇到得最多的就是for循环(使用原Swift2中enumerate方法)相关的，具体可以看官方的迁移指南，里面有具体指出哪些需要手动修改。</p><p>跑题了…，使用Xcode8安装XVim的时候，直接clone XVim工程再make安装，之后Xcode无法启动，直接就崩溃了(错误提示是 code signature invalid类似的信息)。。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>标准的安装方式与XVim工程里面的Readme一致。最可能遇到的问题就是，在github上它的安装说明上，使用<code>xcode-select -p</code>命令查看当前是用的哪个版本的Xcode，如果之前同时使用Xcode7.3与Xcode8 beta，并把Xcode7.3卸载，此时输出的那个目录不是对应的Contents/Developer目录(是一个其他的的目录)，这里需要使用<code>xcode-select -s &lt;路径&gt;</code>命令指定一下/Applications/Xcode-beta.app/Contents/Developer目录。下面只说解决安装XVim导致XCode崩溃的问题。</p><p>把大象装冰箱分几步:</p><ol><li><p>把现在出现崩溃的Xcode移除，然后重新解压出一份新的Xcode.app放在应用程序目录</p></li><li><p>查看自己的IdentifyID，终端里运行如下命令:</p><blockquote><p>security find-identity -p codesigning</p></blockquote><p>终端会打印出两段信息，把其中看起来像是MD5码的字符串保存。</p></li><li><p>进入到XVim的解压目录中，如果之前make过，先make clean一下，然后执行make，会询问你是否移除Xcode的signature(会停下来让你选择y还是N)，这里选N(不移除)，然后XVim工程make完成。</p></li><li><p>这时候如果你打开Xcode，XVim插件是没有启用的。需要另外一步，打开终端，定位到<strong>/Applications</strong>目录，执行下面的命令:</p><blockquote><p>codesign -f -s <strong>&lt;刚才保存的那串IdentifyID&gt;</strong> Xcode.app</p></blockquote><p>需要点时间，应该是几分钟左右，完成之后再打开Xcode，会提示你有一个未知的XVim.plugin的bundle没有加载，选中<strong>Load Bundle</strong>，然后XVim就可以用了。</p><p>Enjoy it！</p></li></ol><p><em>End</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做为一个Vim党，几乎是有Vim插件的IDE都会安装上，然后各种跳转爽得飞起，Xcode上就是成名已久的了&lt;a href=&quot;https://github.com/XVimProject&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XVim&lt;/a&gt;，它还有
      
    
    </summary>
    
    
      <category term="Xcode" scheme="http://bugcode.net/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>CR/LF小坑</title>
    <link href="http://bugcode.net/2016/09/04/CR-LF%E5%B0%8F%E5%9D%91.html"/>
    <id>http://bugcode.net/2016/09/04/CR-LF小坑.html</id>
    <published>2016-09-04T10:34:56.000Z</published>
    <updated>2018-06-30T15:15:00.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CR、LF、CR-LF"><a href="#CR、LF、CR-LF" class="headerlink" title="CR、LF、CR/LF"></a>CR、LF、CR/LF</h3><p>不同系统对“换行”的表示，详情可以看<a href="https://en.wikipedia.org/wiki/Newline" target="_blank" rel="noopener">这里</a>。</p><ol><li><p>LF(Line Feed): 换行，ascii码是10，对应字符’\n’，*Nix系使用此字符做为换行的标志(包括OSX及其之后的版本)。</p></li><li><p>CR(Carriage Return): 回车，ascii码是13，对应字符是’\r’，部分系统，类似Apple II那个经典的系统(wiki上有具体的解释)。</p><p>现在某度或者google出来的部分权重略大的搜索结果还是说CR是macOS的换行符(可能是一个抄一个，也可能写下的时间较早)，注意看上面wiki百科给出的解释，CR部分的是解释是:</p><blockquote><p> <a href="https://en.wikipedia.org/wiki/Commodore_International" target="_blank" rel="noopener">Commodore</a> 8-bit machines, <a href="https://en.wikipedia.org/wiki/BBC_Micro" target="_blank" rel="noopener">Acorn BBC</a>, <a href="https://en.wikipedia.org/wiki/ZX_Spectrum" target="_blank" rel="noopener">ZX Spectrum</a>, <a href="https://en.wikipedia.org/wiki/TRS-80" target="_blank" rel="noopener">TRS-80</a>, <a href="https://en.wikipedia.org/wiki/Apple_II_family" target="_blank" rel="noopener">Apple II family</a>, <a href="https://en.wikipedia.org/wiki/Oberon_(operating_system" target="_blank" rel="noopener">Oberon</a>), <a href="https://en.wikipedia.org/wiki/Mac_OS_history" target="_blank" rel="noopener">Mac OS</a> up to <a href="https://en.wikipedia.org/wiki/Mac_OS_9" target="_blank" rel="noopener"><strong>version 9</strong></a>, MIT <a href="https://en.wikipedia.org/wiki/Lisp_machine" target="_blank" rel="noopener">Lisp Machine</a> and <a href="https://en.wikipedia.org/wiki/OS-9" target="_blank" rel="noopener">OS-9</a>.</p></blockquote><p>这里的确提到了macOS，但是注意后面的up to version 9，也就是Mac OS 9之前的系统版本的确是使用CR做为换行符，但是之后的系统版本都是与*Nix系保持一致，都使用LF做为换行符。</p></li><li><p>CR/LF，同时使用\n\r来表示换行，现在只有Windows系统(<em>大部分问题都出在这里，这里不说网络协议中用CRLF做为分隔的情况</em>)。</p></li></ol><p>目前的情况就是<em>大部分民众</em>常用的系统几乎只有两种情况使用\n做为换行符，使用\n\r做为换行标识。</p><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>一个类似这样的场景，一堆android工程需要生成，各个工程都有自己的配置文件—不同工程的key或者id(或者其他各工程间独立且不同的配置)，这些都需要在工程生成的时候动态的把配置文件里面提前约定好的字符串替换为其对应的key或者id(类似%needReplaceIdentifier%这样的文本字符串)，对应的key或者id在相对固定的路径中存放，生成配置文件时候，把这个固定路径里面的字符串读取出来替换到对应的约定字符串中去。</p><p>这个看起来并没什么，其实如果在一个同一个系统中操作也真没什么，问题就出现在跨系统的操作上，有二个机器，一个Windows一个Mac，同时check了一份工程的代码(svn)，准备在Mac端生成对应的配置文件，但是某些情况下就直接在Windows端编辑对应的配置文件提交至svn(svn不会像git那样自动转换line ending)，之后在Mac直接update下对应的配置文件，开始生成，类似这样:</p><p>文件IDConfig.cfg内容:</p><blockquote><p>1101     firstLine</p><p>1201    secondLine</p><p>…</p></blockquote><p>被替换的文件BeReplacedFile内容:</p><blockquote><p>…</p><p>… “%needReplaceID%” …</p><p>… “%needReplaceKey%”…</p><p>…</p></blockquote><p>之后没有转换过的Windows换行直接被读取出来，字符串切分，替换，完成之后就变成了非预期的样子，出现了一个非预期的换行，如果不用类似vim这种编辑器提前看一下(vim下直接会发现Windows编辑过的文件后面多了一个^M的字样，也就是\r)，不容易发现。</p><p>替换之后文件:</p><blockquote><p>…</p><p>… “1101” …</p><p>… “firstLine</p><p>“…</p><p>…</p></blockquote><ol><li><p>类似如下shell脚本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> -i count</span><br><span class="line">count=0</span><br><span class="line">cat ~/Desktop/test.txt | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    tmp=$(<span class="built_in">echo</span> <span class="variable">$&#123;line&#125;</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">    count=<span class="variable">$count</span>+1</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"needReplaceIdentifier<span class="variable">$&#123;count&#125;</span>"</span></span><br><span class="line">    sed -i -e <span class="string">"s/needReplaceIdentifier<span class="variable">$&#123;count&#125;</span>/<span class="variable">$&#123;tmp&#125;</span>/"</span> ~/Desktop/test.dst</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>执行上文shell处理之后就变成标准的macOS换行的格式，替换完成后这时候某些配置多了一个换行就已经开始报错了。</p></li></ol><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>扯了这么多，其实是非常简单的一个问题，解决方式有N种:</p><ol><li><p>双系统开发，只在对应的系统进行提交(和没说一样)</p></li><li><p>使用dos2unix进行转换，直接brew安装一个dos2unix，还支持指转换，还可以unix2dos。</p><blockquote><p>dos2unix file_to_convert</p><p>unix2dos file_to_convert</p></blockquote></li><li><p>打开vim，你会看到这种文件有\r的地方都有一个<strong>^M</strong>标记，直接命令模式:</p><blockquote><p>:%s/\r//g</p></blockquote></li><li><p>其他任何可用的替换命令/操作。</p></li></ol><p><em>End</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CR、LF、CR-LF&quot;&gt;&lt;a href=&quot;#CR、LF、CR-LF&quot; class=&quot;headerlink&quot; title=&quot;CR、LF、CR/LF&quot;&gt;&lt;/a&gt;CR、LF、CR/LF&lt;/h3&gt;&lt;p&gt;不同系统对“换行”的表示，详情可以看&lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://bugcode.net/tags/Linux/"/>
    
      <category term="Windows" scheme="http://bugcode.net/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>空闲的八月</title>
    <link href="http://bugcode.net/2016/09/03/%E7%A9%BA%E9%97%B2%E7%9A%84%E5%85%AB%E6%9C%88.html"/>
    <id>http://bugcode.net/2016/09/03/空闲的八月.html</id>
    <published>2016-09-03T13:10:04.000Z</published>
    <updated>2018-07-06T11:23:47.906Z</updated>
    
    <content type="html"><![CDATA[<p>每个月都会写些流水帐，也不知道文字能力还能不能借此挽救一下。前几个月是没时间写，而现在是太闲了，惰性说来就来。迷糊着突然发现地铁上的人突然多了起来，恍然，九月都来了，学生都开学了，学生时代，恍惚间感觉离自己好久远一样。好吧，就迷糊着在九月记录一下八月吧~</p><h3 id="《我的朋友都死了》"><a href="#《我的朋友都死了》" class="headerlink" title="《我的朋友都死了》"></a>《我的朋友都死了》</h3><p>用了不到一个小时的时间浏览了一本漫画，名字叫《我的朋友都死了》，放在kindle里好久一直没看，介绍是这样的:</p><blockquote><p>史上最萌最虐心的超人气时尚小绘本！击中你深藏于心的寂寞！画给所有感到孤独的年轻人！</p></blockquote><p>看这个介绍似乎无感，书商的套路而已，但是直到我看到下面这一段的时候，突然发现，可能不同人群的人看，都能在不同的小段里找到与自己所从事的行业、自己的性格、自己的家庭、自己所处的环境里面的各种孤独和寂寞。看完这段脑海中直接就对号入座了—程序员，不知道其他人看是什么感受，我的感受还是挺强烈的，相当一部分人还是圈子比较小(包括我自己)，不是讨论技术就是打打游戏，最多和基友撸个串闲聊下(聊一会儿就变成我的代码如何，那谁谁代码如何…)，虽然自己非常想脱离这种状态，但是仍然在这种陷于这种状态中循环往复，之后约妹子的时候(如果能约到)可能顺嘴就下去了—技术如何如何，甚至不知道要说什么。最后就剩下，工作-&gt;假期-&gt;睡觉(偶尔与基友小聚)-&gt;工作….</p><p><img src="https://i.loli.net/2018/07/06/5b3f510e0e890.png" alt=""></p><h3 id="《谍影重重5》"><a href="#《谍影重重5》" class="headerlink" title="《谍影重重5》"></a>《谍影重重5》</h3><p>8月23号大陆上映，那天是周二，上班没时间去看，熬到周六，迫不及待的买了二张英语2D的，为什么突出说一下英语2D，大陆版的最开始是只有英语3D(特供)，而以我看完2D的情况来看，网友不是瞎说的，太多的近镜头的大幅度晃动的确让人头晕(想象不到我这个有3D眩晕症的人看完3D版本的会以什么姿势走出电影院)，特别是开始不久后在希腊的街头的那部分，看2D的都有些晕乎，也怪不得网友们大骂了。很多影评说剧情不足，但是做为一个谍影重重前三部看了N遍的人来说，依然非常给力。整个过程都是揪着心看完的，只是男神马特达蒙也老了😔，也不知道还有没有《谍影重重6》，如果有，什么时候呢？</p><h3 id="JBL小砖"><a href="#JBL小砖" class="headerlink" title="JBL小砖"></a>JBL小砖</h3><p>音响一直用三十块的地摊儿货，平时戴耳机比较多，一个款式很老的森海塞尔头戴式的，上大学时候买电脑送的，音质不错，一直保护得非常好。最近地摊儿货显示出疲态了，各种尖叫，再加上windows主机上各种线越来越多，而且天热戴耳机不舒服，狗东上溜了一圈儿最后果断下手JBL小砖，299大洋，自带重低音听着挺好的(也不会听什么音质，总之听着挺舒服)，喜欢棱角分明的外形，小砖是真小，长度比手机还短一大截，蓝牙mac秒连，windows稍微迟钝一些，也可能是个例，总体非常不错。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>关键词: <strong>拖延与进步</strong></p><p>拖延: <code>macCalendar的进度略慢</code>，<code>《Advanced Linux Programming》第五章翻译没开始</code></p><p>进步: <code>重读《Pro Git》收获比之前大</code>，<code>连续打一个小时羽毛球不喘了</code></p><p><em>End</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每个月都会写些流水帐，也不知道文字能力还能不能借此挽救一下。前几个月是没时间写，而现在是太闲了，惰性说来就来。迷糊着突然发现地铁上的人突然多了起来，恍然，九月都来了，学生都开学了，学生时代，恍惚间感觉离自己好久远一样。好吧，就迷糊着在九月记录一下八月吧~&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="life" scheme="http://bugcode.net/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Bash-simple-quick-tutorial</title>
    <link href="http://bugcode.net/2016/08/28/Bash-simple-quick-tutorial.html"/>
    <id>http://bugcode.net/2016/08/28/Bash-simple-quick-tutorial.html</id>
    <published>2016-08-28T10:28:43.000Z</published>
    <updated>2018-06-30T14:50:46.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Bash-简单入门"><a href="#Bash-简单入门" class="headerlink" title="Bash 简单入门"></a>Bash 简单入门</h3><p>Bash的简单入门，不介绍复杂的语法，只有基本的语法构成，看完可以写出简单的shell脚本，根据<a href="https://learnxinyminutes.com/docs/zh-cn/bash-cn/" target="_blank" rel="noopener">learnxinyminutes</a>的入门画的脑图，不常写会经常忘记，画下来做为备忘，条理清晰些。</p><p><img src="/chapimages/Bash.png" alt=""></p><h3 id="各语言的“马桶”入门"><a href="#各语言的“马桶”入门" class="headerlink" title="各语言的“马桶”入门"></a>各语言的“马桶”入门</h3><p>在V站上看到有V友提到了这样儿一个<a href="https://learnxinyminutes.com/" target="_blank" rel="noopener">网站</a>，挺有意思的，真是坐在马桶上就能浏览完一门语言的最基本语法，然后马上入手，尤其是像bash这种入门门槛不是特别高的脚本语言， 快速过一遍就可以上手写简单的脚本了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Bash-简单入门&quot;&gt;&lt;a href=&quot;#Bash-简单入门&quot; class=&quot;headerlink&quot; title=&quot;Bash 简单入门&quot;&gt;&lt;/a&gt;Bash 简单入门&lt;/h3&gt;&lt;p&gt;Bash的简单入门，不介绍复杂的语法，只有基本的语法构成，看完可以写出简单的shel
      
    
    </summary>
    
    
      <category term="Bash" scheme="http://bugcode.net/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>使用Markdown画流程图</title>
    <link href="http://bugcode.net/2016/08/25/%E4%BD%BF%E7%94%A8Markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE.html"/>
    <id>http://bugcode.net/2016/08/25/使用Markdown画流程图.html</id>
    <published>2016-08-25T13:29:54.000Z</published>
    <updated>2018-06-30T11:01:41.085Z</updated>
    
    <content type="html"><![CDATA[<p>最新一版的Typora支持画流程图了，用的flowchart.js，直接可以用代码的形式来描述流程图，然后直接就会通过flowchart.js渲染出实时的流程图，之前对这些没了解过，记录在此。</p><p>先看官网的例子:</p><blockquote><p>```flow</p><p>st=&gt;start: Start<br>op=&gt;operation: Your Operation<br>cond=&gt;condition: Yes or No?<br>e=&gt;end</p><p>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op</p><p>```</p></blockquote><p>上面的代码就会产生如下图:</p><p><img src="/chapimages/flow.png" alt=""></p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>与写代码有相似的地方，先定义，再构造，可以在<a href="http://flowchart.js.org/" target="_blank" rel="noopener">flowchat.js官网</a>查看相关用法。</p><ol><li><p>定义要画的流程图里用到的元素(条件、操作、分支、输入输出、开始、结束)</p><p>几个不同的元素类型分别用下面的关键字来表示</p><blockquote><ol><li>start 流程图的开始</li><li>end 流程图结束</li><li>inputouput 输入输出</li><li>subroutine 分支(子程序) </li><li>operation 操作</li><li>condition 条件</li></ol></blockquote><p>​</p><p>基本的语法:</p><blockquote><p><strong>labelName=&gt;elementType: labelContent:&gt;link</strong></p><p>labelName: 代码中当前流程图中每个元素实例的具体名字，类似于不同的变量表示流程图不同的部分</p><p>elementType: 元素类型，表示对应的那个变量是流程图的元素类型，<strong>类型冒号后有一个空格，切记</strong></p><p>labelContent: 标签上显示的内容，就是每个框里面的文字，英文汉字都行</p><p>link: &gt;link是可选的，对应那个labelContent的链接</p></blockquote></li><li><p>各元素都定义好之后，使用<strong>-&gt;</strong>来连接各个元素。</p><blockquote><p>startLabel-&gt;endLabel </p><p>使用condition的时候，条件都会有二个分支，对应yes和no，所以连接条件元素的时候一般写二个</p><p>condLabel(yes)-&gt;outLabel-&gt;endLabel</p><p>condLabel(no)-&gt;errorOp</p><p>使用subroutine的时候，有left和right二个子项，分别针对subroutine元素标签左右侧的起点位置</p></blockquote></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设以在控制台输入一个数字，判定这个数字是否为素数，是打印“是素数”，不是打印“不是素数”为例，画对应的流程图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">startLabel=&gt;start: 开始</span><br><span class="line">endLabel=&gt;end: 结束</span><br><span class="line">opLabel=&gt;operation: 输入一个数字:</span><br><span class="line">condIsNumberLabel=&gt;condition: 是否是一个数字?</span><br><span class="line">condIsPrimeLabel=&gt;condition: 是否只能被1或者本身整除?:&gt;http://goo.gl/qCKg49</span><br><span class="line">outIsPrimeLabel=&gt;inputoutput: 是素数</span><br><span class="line">outIsNotPrimeLabel=&gt;inputoutput: 不是素数</span><br><span class="line">subroutineIsNotNumberLabel=&gt;subroutine: 错误处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">startLabel-&gt;opLabel-&gt;condIsNumberLabel</span><br><span class="line">condIsNumberLabel(yes)-&gt;condIsPrimeLabel</span><br><span class="line">condIsNumberLabel(no)-&gt;subroutineIsNotNumberLabel(right)-&gt;opLabel</span><br><span class="line">condIsPrimeLabel(yes)-&gt;outIsPrimeLabel-&gt;endLabel</span><br><span class="line">condIsPrimeLabel(no)-&gt;outIsNotPrimeLabel-&gt;endLabel</span><br></pre></td></tr></table></figure><p>结果如下图:</p><p><img src="/chapimages/flowdemo.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最新一版的Typora支持画流程图了，用的flowchart.js，直接可以用代码的形式来描述流程图，然后直接就会通过flowchart.js渲染出实时的流程图，之前对这些没了解过，记录在此。&lt;/p&gt;
&lt;p&gt;先看官网的例子:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;```f
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://bugcode.net/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Swift3已完成的变动提案列表</title>
    <link href="http://bugcode.net/2016/07/24/Swift3%E5%B7%B2%E5%AE%8C%E6%88%90%E7%9A%84%E5%8F%98%E5%8A%A8%E6%8F%90%E6%A1%88%E5%88%97%E8%A1%A8.html"/>
    <id>http://bugcode.net/2016/07/24/Swift3已完成的变动提案列表.html</id>
    <published>2016-07-24T12:52:05.000Z</published>
    <updated>2018-06-30T11:01:40.900Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 3已经实现的变动提案，粗略翻译一下，自己顺便也了解记录，原文地址:<a href="https://apple.github.io/swift-evolution/" target="_blank" rel="noopener">https://apple.github.io/swift-evolution/</a></p><ol><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md" target="_blank" rel="noopener">SE-0002</a> 去掉函数柯里化的声明语法</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md" target="_blank" rel="noopener">SE-0003</a> 去掉了函数参数中的<em>var</em>关键字</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md" target="_blank" rel="noopener">SE-0004</a> 去掉了<em>++</em>和<em>–</em>操作符</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md" target="_blank" rel="noopener">SE-0005</a> Objective-C的API更符合Swift风格</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md" target="_blank" rel="noopener">SE-0006</a> Swift的标准库中应用了API指南</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md" target="_blank" rel="noopener">SE-0007</a> 移除C语言形式的for循环语法</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0008-lazy-flatmap-for-optionals.md" target="_blank" rel="noopener">SE-0008</a> 为可选序列增加了lazy flatMap</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md" target="_blank" rel="noopener">SE-0016</a> 增加由非安全指针和非安全可变指针转化为Int和UInt类型的构造器</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0017-convert-unmanaged-to-use-unsafepointer.md" target="_blank" rel="noopener">SE-0017</a> 改<code>Unmanaged</code> 为用 <code>UnsafePointer</code></li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0019-package-manager-testing.md" target="_blank" rel="noopener">SE-0019</a> Swift测试</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md" target="_blank" rel="noopener">SE-0023</a> API设计指南</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0028-modernizing-debug-identifiers.md" target="_blank" rel="noopener">SE-0028</a> 更加新式的Debug标识符(如__FILE__)</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md" target="_blank" rel="noopener">SE-0029</a> 移除了函数传参过程中，隐式的元组自展开行为</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0031-adjusting-inout-declarations.md" target="_blank" rel="noopener">SE-0031</a> 调整了inout关键字对类型修饰的定义</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0032-sequencetype-find.md" target="_blank" rel="noopener">SE-0032</a> 为序列这种类型统一加了一个<code>first(where:)</code>方法</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md" target="_blank" rel="noopener">SE-0033</a> 引入Objective-C常量做为Swift的类型</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0034-disambiguating-line.md" target="_blank" rel="noopener">SE-0034</a> 消除了Debug标识符中行控制语句的歧义</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0035-limit-inout-capture.md" target="_blank" rel="noopener">SE-0035</a> 限制了<code>inout</code>对<code>@noescape</code>修饰的上下文的捕获</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0036-enum-dot.md" target="_blank" rel="noopener">SE-0036</a> 枚举实例成员的实现必须有前导点号</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0037-clarify-comments-and-operators.md" target="_blank" rel="noopener">SE-0037</a> 明晰了注释和操作符的界限(除号与乘号)</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0039-playgroundliterals.md" target="_blank" rel="noopener">SE-0039</a> 更加新式的Playground字面量</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0040-attributecolons.md" target="_blank" rel="noopener">SE-0040</a> 在属性参数中使用冒号代替等号</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0043-declare-variables-in-case-labels-with-multiple-patterns.md" target="_blank" rel="noopener">SE-0043</a> 可以在<code>case</code>标签里使用多种模式定义变量</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md" target="_blank" rel="noopener">SE-0044</a> 现在可以把C的API做为Swift类型成员引入</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0046-first-label.md" target="_blank" rel="noopener">SE-0046</a> 为包括第一个函数参数的所有参数设定一致的标签行为</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0047-nonvoid-warn.md" target="_blank" rel="noopener">SE-0047</a> 默认非空返回的函数给出没有使用结果的警告</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md" target="_blank" rel="noopener">SE-0048</a> 可以使用泛型类型别名</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0052-iterator-post-nil-guarantee.md" target="_blank" rel="noopener">SE-0052</a> 改变了迭代类型<code>post-nil</code>保证</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0053-remove-let-from-function-parameters.md" target="_blank" rel="noopener">SE-0053</a> 去掉了函数参数中显式使用<code>let</code>的用法</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md" target="_blank" rel="noopener">SE-0054</a> 废除了<code>ImplicitlyUnwrappedOptional</code> 类型</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md" target="_blank" rel="noopener">SE-0055</a> 显式使用可选值语法使非安全指针为null</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md" target="_blank" rel="noopener">SE-0057</a> 引用Objective-C轻量泛型</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0060-defaulted-parameter-order.md" target="_blank" rel="noopener">SE-0060</a> 强制默认参数顺序</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0061-autoreleasepool-signature.md" target="_blank" rel="noopener">SE-0061</a> 加入了对autoreleasepool()的错误处理和泛型结果</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md" target="_blank" rel="noopener">SE-0062</a> 引入了Objective-C中的key-paths</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0063-swiftpm-system-module-search-paths.md" target="_blank" rel="noopener">SE-0063</a> 为Swift包管理加入系统模块搜索路径</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0064-property-selectors.md" target="_blank" rel="noopener">SE-0064</a> 引入了Objective-C的getter和setter属性的选择器</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md" target="_blank" rel="noopener">SE-0065</a> 新的集合与索引的模型</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md" target="_blank" rel="noopener">SE-0066</a> 标准化了函数参数类型需要小括号的语法</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md" target="_blank" rel="noopener">SE-0067</a> 增强浮点数的协议</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md" target="_blank" rel="noopener">SE-0069</a> Mutability和Foundation值类型</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md" target="_blank" rel="noopener">SE-0070</a>  Make Optional Requirements Objective-C-only</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0071-member-keywords.md" target="_blank" rel="noopener">SE-0071</a> 允许大部分的保留字在成员里使用</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md" target="_blank" rel="noopener">SE-0072</a> 完全消除转换成Swift类型的歧义</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0076-copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source.md" target="_blank" rel="noopener">SE-0076</a> 为<code>UnsafeMutablePointer</code>类型增加了一个重写的方法，作用接收一个<code>UnsafePointer</code>，将其转换为不析构的副本</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0085-package-manager-command-name.md" target="_blank" rel="noopener">SE-0085</a> 可以从命令行调用Swift包管理器</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0086-drop-foundation-ns.md" target="_blank" rel="noopener">SE-0086</a> 在Swift的Foundation类型中移除了NS前缀</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md" target="_blank" rel="noopener">SE-0091</a> 在协议中提高了对运算符的要求</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0093-slice-base.md" target="_blank" rel="noopener">SE-0093</a> 专门为索引增加了一个公有的<code>base</code>属性</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0094-sequence-function.md" target="_blank" rel="noopener">SE-0094</a> 在标准库中加入<code>sequence(first:next:)</code>和<code>sequence(state:next:)</code>方法</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md" target="_blank" rel="noopener">SE-0095</a> 使用<code>P1 &amp; P2</code>的语法代替原来的<code>protocol&lt;P1,P2&gt;</code>语法</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0106-rename-osx-to-macos.md" target="_blank" rel="noopener">SE-0106</a> 在OSX平台配置测试加入了<code>macOS</code>别名</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0109-remove-boolean.md" target="_blank" rel="noopener">SE-0109</a> 移除了<code>Boolean</code>协议</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md" target="_blank" rel="noopener">SE-0112</a> 增加了<code>NSError</code>的转换</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0113-rounding-functions-on-floatingpoint.md" target="_blank" rel="noopener">SE-0113</a> 为浮点类型增加了整数舍入的功能</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0114-buffer-naming.md" target="_blank" rel="noopener">SE-0114</a> 修改Buffer类型的”Value”的名字为”Header”的</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0115-literal-syntax-protocols.md" target="_blank" rel="noopener">SE-0115</a> 重命名字面量语法的协议</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md" target="_blank" rel="noopener">SE-0118</a> 修改了闭包的参数名称及参数标签</li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0124-bitpattern-label-for-int-initializer-objectidentfier.md" target="_blank" rel="noopener">SE-0124</a>  <code>Int.init(ObjectIdentifier)</code>和<code>UInt.init(ObjectIdentifier)</code>方法现在需要一个<code>bitPattern:</code>标签</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Swift 3已经实现的变动提案，粗略翻译一下，自己顺便也了解记录，原文地址:&lt;a href=&quot;https://apple.github.io/swift-evolution/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://apple.gi
      
    
    </summary>
    
    
      <category term="Swift" scheme="http://bugcode.net/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift3迁移指南-2</title>
    <link href="http://bugcode.net/2016/07/21/Swift3%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97-2.html"/>
    <id>http://bugcode.net/2016/07/21/Swift3迁移指南-2.html</id>
    <published>2016-07-21T03:50:11.000Z</published>
    <updated>2018-06-30T11:01:41.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Carthage-CocoaPods工程"><a href="#使用Carthage-CocoaPods工程" class="headerlink" title="使用Carthage/CocoaPods工程"></a>使用Carthage/CocoaPods工程</h2><p>如果你使用了第三方的二进制形式的Swift模块工程，这个工程并不是在你自己Xcode的工作空间中由你自己生成出来的，你可以选择下面的其中一种方法进行迁移。</p><ul><li><p>在你的Xcode工作空间包含工程的源代码。</p><p>使用这种方法，你需要构建并迁移开源的工程到你自己的工程里面，使用Xcode7.3确保工程构建和链接都无误。包含开源工程中的文件到你自己的Xcode工作空间里，并设置好你正在构建的工程的依赖工程scheme。如果你在Carthage的build目录下设置了framework的Swift的二进制模块的搜索路径，去掉设置的搜索路径或者直接清掉Carthage的build目录，要确保你所使用的Swift模块一定是由你自己的Xcode工作空间构建出来的。</p></li><li><p>一直等到你所使用的开源工程也更新到了Swift2.3或者Swift3</p><p>可以按下面的步骤来迁移你的工程</p><ul><li>把你的工程当做是在Xcode7.3下构建</li><li>使用迁移助手，且只应用迁移助手对你自己工程的源代码改动部分。</li><li>构建之前，修改Carthage/CocoaPods依赖文件，指定其为已经迁移到Swift2.3或者Swift3的工程分支版本</li><li>更新依赖，并尝试构建已经被迁移程序修改更新过源代码的工程。</li></ul></li></ul><h2 id="已知的迁移问题"><a href="#已知的迁移问题" class="headerlink" title="已知的迁移问题"></a>已知的迁移问题</h2><h3 id="Swift-标准库"><a href="#Swift-标准库" class="headerlink" title="Swift 标准库"></a>Swift 标准库</h3><ul><li><p>迁移程序可能会对在<code>SetIndex</code>和<code>DictionaryIndex</code>使用索引方法的这种代码转换失败。</p><ul><li>解决方法：手动迁移用在集合对象上的索引方法。大致如下:<ul><li><code>index.successor()</code> 修改为 <code>Collection.index(after: index)</code></li><li><code>index.predecessor()</code> 修改为 <code>Collection.index(before: index)</code></li><li><code>index.advancedBy(delta)</code> 修改为<code>Collection.index(index, offsetBy: delta)</code></li><li><code>index.advancedBy(delta, limit: otherIndex)</code> 修改为<code>Collection.index(index, offsetBy: delta, limitedBy: otherIndex)</code></li><li><code>index.distanceTo(otherIndex)</code> 修改为<code>Collection.distance(from: index, to: otherIndex)</code></li></ul></li></ul></li><li><p>在Swift2.2中<code>Unmanaged</code>类型有一个静态方法<code>fromOpaque(_:)</code>把<code>COpaquePointer</code>类型转换为<code>Unmanaged</code>类型和一个实例方法<code>toOpaque()</code>把未托管的引用类型转换为<code>COpaquePointer</code>类型 。在Swift3中这个变成了把<code>UnsafePointer&lt;Void&gt;</code>转换为<code>UnsafeMutablePointer&lt;Void&gt;</code>来匹配一个通用的传递给C的API的“上下文指针”，你可以简单的把用到<code>COpaquePointer</code>的移除即可(现在已重命名为<code>OpaquePointer</code>)。</p></li><li><p>如果你有任何的的自定义的集合类型，你可能会看到如下编译错误:“MyCollection’ does not conform to protocol ‘Collection”(MyCollection没有遵循Collection协议)。</p><ul><li>现在是由集合类型负责其自身的索引的自增/自减，要让你自己的集合类型遵循<code>Collection</code>协议，实现<code>func index(after: Index) -&gt; Index</code>方法，对于<code>BidirectionalCollection</code>这个集合类型，还要实现<code>func index(before: Index) -&gt; Index</code>方法。</li></ul></li><li><p>如果你有一个使用了半开区间操作符生成的<code>Range</code>类型的变量(如 1..&lt;2)并且把它做一个<code>Sequence</code>来用(比如，用在一个<code>for-in</code>循环里)，你会看到如下错误：“type ‘Range’ does not conform to protocol ‘Sequence”(Range类型没有遵循Sequence协议)。</p><ul><li>修改方式就是把<code>Range</code>改为<code>CountbaleRange</code>。</li></ul></li><li><p>用户可能需要手动修改 <code>Sequence.generate()</code> 为 <code>Sequence.makeIterator()</code>.</p></li><li><p>用户可能需要手动修改 <code>anyGenerator</code> 为 <code>AnyIterator</code>.</p></li><li><p>用户可能需要手动修改 <code>Range.start</code> 和<code>Range.end</code> 分别改为<code>Range.lowerBound</code> 和 <code>Range.upperBound</code>。</p></li><li><p>用户可能需要手动修改 <code>Collection.Index.Distance</code> 为<code>Collection.IndexDistance</code> (没有中间的点号)</p></li><li><p>访问<code>Collection.enumerated()</code>的枚举结果时，用户可能需要手动修改元组元素 <code>index</code> 为 <code>offset</code> 。</p></li><li><p><code>Printable</code> 和<code>DebugPrintable</code> 现在已分别重命名为 <code>CustomStringConvertible</code> 和<code>CustomDebugStringConvertible</code>。</p></li><li><p>如果在迁移索引区间之后使用集合的<code>indices</code>属性的时候报“<code>Range&lt;Index&gt;</code>没有遵循<code>Sequence</code>协议”的错。像下面这样修改：</p><ul><li><code>for _ in str.startIndex..</code> –&gt; <code>for _ in str.indices[str.startIndex..&lt;someIndex]{}</code></li></ul></li><li><p><code>Zip2Sequence(_:_:)</code> 构造器已被移除; 使用 <code>zip(_:_:)</code>函数替代。</p></li><li><p>在<code>Collection</code>扩展中使用 <code>min</code>/<code>max</code> 会与<code>Collection</code>的本地方法冲突; 在 <code>min</code>/<code>max</code> 之前加<code>swift</code>就可以解决这个冲突。</p></li><li><p>在迁移程序会自动重命名代码中的类型名，新的类型名可能会与用户自定义的类型名冲突，解决这个问题需要你移除那些不必须的类型别名定义。</p></li><li><p><code>Selector()</code> 会被转换为 <code>nil</code>。</p></li><li><p><code>Unmanaged.toOpaque()</code> 会被转换为 <code>OpaquePointer(bitPattern:)</code></p></li><li><p><code>Range&lt;&gt;.reversed</code> 已经被移除; 用户可以调用<code>[].indices.reversed()</code>模拟实现这个功能。</p></li><li><p><code>&lt;Index&gt; ..&lt; &lt;Sequence&gt;.endIndex</code> 需要手动修改为<code>&lt;Sequence&gt;.indices.suffix(from: )</code>。</p></li><li><p>迁移程序不会重写Swift中不存在的类型的泛型约束。</p><p>比如：</p><p><code>func foo() &lt;C: CollectionType where C.Index: BidirectionalIndexType&gt;{}</code> 会被转换为 <code>func foo()&lt;C: BidirectionalCollection&gt; {}</code> 但其实应该转换为这样<code>func foo()&lt;C: Collection where C.Index: BidirectionalIndex&gt; {}</code>。</p><p>​</p></li></ul><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><ul><li><p>新SDK的release版本一些协议增加了一些<code>required</code>的方法(遵循协议必须要实现的方法)，迁移程序现在不会在你的源代码里加入这些方法(<code>required</code>方法)实现。</p><ul><li>解决办法就是手动在遵循这些协议的代码里添加<code>required</code>方法的实现。</li></ul></li><li><p>在Swift3中很多Foundation中的“字符串类型”的API已经被改为使用结体的“包装类型”。比如新的<code>Notification.name</code></p></li><li><p><code>FileAttributeKey</code>是另一个由“字符串类型”改为使用结构体的“包装类型”，当像这样的类型被用在字典(比如<code>FileManager</code>中的 <code>attributesOfItem(atPath:)</code>方法的返回结果)上的时候，字符值通常需要使用<code>rawValue</code>属性提取出来。</p><ul><li><code>let mtime = try FileManager.default().attributesOfItem(atPath: &quot;/&quot;)[FileAttributeKey.size.rawValue] as? NSNumber</code></li></ul></li><li><p>迁移程序会修改绝大部分用到<code>NSURL</code>的地方为<code>URL</code>，但是<code>NSURL</code>中的某些方法，像<code>checkResourceIsReachableAndReturnError</code>，没有使用Swift的错误处理机制，而是使用是外部参数来保存错误信息。而某些<code>URL</code>里类似的方法，如<code>checkResourceIsReachable</code>，如期的使用了Swift的错误处理机制。</p><ul><li><p>Swift3的迁移程序依然迁移时保留了<code>NSURL</code>方法，如果你想使用新的API里的<code>URL</code>类型，需要手动修改自己的代码。通用的处理url不可达的错误方式是使用<code>try?</code>:</p><p><code>let isReachable = (try? resourceURL.checkResourceIsReachable()) ?? false)</code> </p></li><li><p>在<code>NSURL</code>中<code>port</code>属性是一个可选的<code>NSNumber</code>类型，同时对应在新的<code>URL</code>类型是一个可选的<code>Int</code>类型。Swift3的迁移程序迁移时保留了<code>NSURL</code>的属性，如果想使用新的<code>URL</code>类型需要手动修改代码为新的API。</p></li></ul></li><li><p>迁移程序会把大部分的<code>NSData</code>转换为<code>Data</code>，某些<code>NSData</code>中的方法操作<code>UnsafeMutablePointer&lt;Void&gt;</code>，相对于<code>Data</code>里面的方法使用<code>UnsafeMutablePointer&lt;UInt8&gt;</code>(相对于<code>Data.copyBytes(_:length:)</code>方法，<code>NSData.getBytes(_:length:)</code> 方法更容易接受)。需要注意，Swift类型的内存布局是不能保证的。</p><ul><li>迁移程序会依然保留使用<code>NSData</code>的方法;想用新API需要自己手动修改代码。</li><li><code>NSData(contentsOfMappedFile: x)</code>可被修改为<code>Data(contentsOf: x, options: .mappedAlways)</code></li><li><code>NSData(data: x)</code> 可以被修改为 <code>x</code></li></ul></li><li><p>在Swift3中除非有更好的方式来代替<code>NSDate</code>，否则迁移程序都会保留使用<code>NSDate</code>，如：</p><ul><li><code>(x as NSDate).earlierDate(y)</code> 可以改为 <code>x &lt; y ? x : y</code></li><li><code>(x as NSDate).laterDate(y)</code> 可以改为 <code>x &lt; y ? y : x</code></li></ul></li><li><p>迁移程序可能不能正确的处理<code>NSEventSubtype</code> 枚举。</p></li><li><p>迁移程序可能不能正确处理属性的<code>setter</code>方法，导致出现这种：<code>setInstanceVariable = instanceVariable</code>。</p><ul><li>解决办法：修改<code>setter</code>为属性名字，如:<code>self.instanceVariable = instanceVariable</code></li></ul></li><li><p>在新SDK中会有switch语句中新增了一些case语句，但迁移程序不会在你的代码里做处理。</p><ul><li>解决办法:手动加入新的switch语句中的case，并加入合适的可用性判定</li></ul></li><li><p>错误:由<code>CALayer?</code>向下转换为<code>CALayer</code>只能可选解包;你是想使用’!’?</p><ul><li>去掉<code>as! CALayer</code>，用<code>!</code>代替</li></ul></li><li><p>错误:枚举值<code>tv</code>不存在于类型<code>UIUserInterfaceIdiom</code>中</p><ul><li>改为<code>TV</code></li></ul></li><li><p>迁移程序可能会错误的处理像<code>objc_ASSOCIATION_RETAIN</code>这种小写的枚举值。</p><ul><li>解决方法：把它们全部改为大写<code>OBJC_ASSOCIATION_RETAIN</code></li></ul></li><li><p>迁移程序会转换全局常量为名称空间枚举，但可能并不会赋一个合适的<code>.rawValue</code>值，传入一个接受一个枚举值的函数时使用新的枚举类型。</p></li><li><p>迁移程序不会转换<code>NSNumber.unsignedLongValue</code></p><ul><li>解决办法：手动改为<code>.uintValue</code></li></ul></li><li><p>迁移程序可能不会将<code>XCUIElementQuery.elementBound(by:)</code> 转换为<code>XCUIElementQuery.element(boundBy:)</code>。</p></li><li><p>一些类型现在已变成泛型(如：<code>NSCache</code> -&gt; <code>Cache</code>, <code>NSMapTable</code> -&gt;<code>MapTable</code>)，迁移到Swift3之后需要为它们加一个合适的泛型参数。</p></li><li><p>迁移程序可能不能正确的将 <code>NSApplicationDelegate</code>类的<code>applicationShouldTerminateAfterLastWindowClosed(_:)</code> 方法转换为<code>applicationShouldTerminate(afterLastWindowClosed:)</code>, 这会引发一个警告： “Instance method ‘…’ nearly matches optional requirement ‘…’ of protocol NSApplicationDelegate”。</p><ul><li>解决办法：将方法名改回<code>applicationShouldTerminateAfterLastWindowClosed</code></li></ul></li><li><p>如果你在一个子类遵循一个Objective-C协议，并实现了其可选的的方法，你会看到这样一个警告：“Instance method ‘…’ nearly matches optional requirement ‘…’ of protocol ‘…’”</p><ul><li>解决方法：在实现的可选方法之前添加<code>@objc(objectiveC:name:)</code>属性。</li></ul></li><li><p>使用字面量做为选项现在需要调用对应选项的构造器，如：<code>NSWindowStyleMask(rawValue: 8345)</code></p></li><li><p>迁移程序不会修改类似这种有相同值类型的<code>NSMutable*</code>(如：<code>NSMutableData</code> -&gt; <code>Data</code>, <code>NSMutableURLSession</code> -&gt; <code>URLSession</code>)，但绝大部分SDK的函数现在接收新的值类型。</p><ul><li>修改为与它们的值类型等同的，小心处理引用与值的转换。快速的解决办法是直接把它们转换为需要的类型(如 <code>as Data</code>)，但是这可能会造成额外的拷贝。</li></ul></li><li><p>如果你定义过的一个泛型与现在某个Foundaiton类冲突。迁移程序可能会在这个类用于一个不同的目标的时候错误的移除掉泛型参数。</p><ul><li>如果你定义的类与Foundation有冲突，首先重命名类以防止产生冲突，或者回退那些被去掉的泛型参数。</li></ul></li><li><p>迁移到Swift3之后，你会看到类似这样的错误：“Extension of a generic Objective-C class cannot access the class’s generic parameters at runtime”</p><ul><li>当尝试调用一个Objective-C中泛型类中含有泛型参数的方法时，可以通过调一个API产生去掉self属性的变量来解决这个问题。如：<code>let typeErasedSelf = self as! MyObjCType&lt;AnyObject&gt;</code></li></ul></li><li><p>如果代码中调用了<code>self.init(...)</code>，这时在迁移到Swift过程中就会错误的将<code>self.init</code>转换为<code>self.dynamicType.init</code>，这时会导致这样的错误：“return from initializer without initializing all stored properties”。</p><ul><li>解决方法：去掉<code>.dynamicType</code></li></ul></li><li><p>迁移程序在转换类似这样的函数时<code>Pasteboard.￼readObjects(forClasses:options:</code>)，会强制重命名第一个参数，比如把NSURL.self改为URL.self，这样就会导致一个编译错误;解决这个问题就是去掉迁移程序做出的改动。</p></li><li><p>迁移程序在转换<code>NSData(bytes:length:deallocator:)</code>时，并不会修改析构器的类型。</p><ul><li>解决办法：将<code>(UnsafeMutablePointer&lt;Void&gt;, Int) -&gt; Void</code>修改为<code>(UnsafeMutablePointer&lt;Int8&gt;, Int) -&gt; Void</code></li></ul></li><li><p>某些方法会标记为在watchOS中不可用，但是对于iOS仍然是必须的，如果出现了这样不能重写某些不可用的方法的错误，请使用<code>#if os(iOS)</code>块将对应的代码包起来。</p></li><li><p>用户可能需要手动将<code>String(contentsOfURL:usedEncoding:)</code>改为<code>String(contentsOf:usedEncoding:)</code>，现在这个方法在<code>usedEncoding</code>参数上用<code>inout String.Encoding</code>代替了<code>UnsafeMutablePointer</code> </p></li><li><p>有必要手动将<code>NSBundle.url(orResource:withExtension:)</code>修改为<code>Bundle.urlForResource(_ :withExtension:subdirectory:inBundleWith:)</code></p></li><li><p>在迁移程序自动迁移之后一些值类型由<code>NSURL</code>变为<code>URL</code>，导致出现不可用成员的错误。解决这个问题，需要手动添加类型转换，用<code>URL</code>的例子，就像这样<code>x as NSURL</code>。</p></li><li><p>用户可能需要通过类型推断来手动简化选项设置。如：修改<code>DispatchQueue.global(attributes: DispatchQueue.GlobalAttributes.qosDefault)</code>为<code>DispatchQueue.global(attributes: .qosDefault)</code></p></li><li><p>尾闭包可能由于名字变得更短而产生歧义，可以通过在闭包参数加参数标签来解决。</p><p>比如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parameterTree: <span class="type">AUParameterTree</span></span><br><span class="line">parameterObserverToken = parameterTree.tokenByAddingParameterObserver &#123;...&#125;</span><br></pre></td></tr></table></figure><p>变为</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameterObserverToken = parameterTree.token &#123;...&#125;</span><br></pre></td></tr></table></figure><p>歧义是由于其他的tocken(:)方法，修改为加入参数标签</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameterObserverToken = parameterTree.token(byAddingParameterObserver: &#123;...&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Dispatch</p><ul><li><p><code>dispatch_once</code>函数在Swift中不再可用。在Swift中你可以使用延迟初始化全局或者静态属性来达到由<code>dispathc_once</code>提供的确保只调用一次的功能。例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myGlobal = &#123; … global <span class="built_in">contains</span> initialization <span class="keyword">in</span> a call to a closure … &#125;()</span><br><span class="line">  <span class="number">_</span> = myGlobal  <span class="comment">// using myGlobal will invoke the initialization code only the first time it is used.</span></span><br></pre></td></tr></table></figure></li><li><p>迁移程序可能不能正确处理多个使用相同的token在不同的静态变量中调用<code>dispatch_once</code>的情况。</p></li><li><p>调用<code>dispatch_after</code>可能会导致被迁移转换为错误的参数标签：如果你看到这样的错误</p><p> <em>“Argument labels ‘(when:, block:)’ do not match any available overloads”</em> ，把<code>block</code>改为<code>execute</code>即可修复。</p></li><li><p>现在针对每个<code>DispatchSource</code>类型都有特定的协议。你需要修改<code>dispatch_source_t</code> 为其中一个特定的协议，比如<code>DispatchSourceTimer</code>, <code>DispatchSourceProcess</code>,等合适的。</p></li><li><p>Dispatch 队列API现在使用这个 <code>DispatchAttributes</code> <code>OptionSet</code>。如果你之前使用</p><p><code>dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_DEFAULT, 0))</code>，现在你使用<code>DispatchQueue(label: name, attributes: [.serial, .qosDefault])</code>这里的选项设置。</p></li><li><p>迁移程序会错误的把<code>dispatch_get_global_queue(_:_:)</code> 转换为<code>DispatchQueue.global(_:_:)</code>来代替<code>DispatchQueue.global(attributes:)</code>。</p><ul><li>解决方法：移除第二个参数，确保第一个参数是<code>DispatchQueue.GlobalAttributes</code>的枚举值。</li></ul></li><li><p><code>dispatch_get_specific</code> 不再带一个<code>UnsafeMutablePointer</code>参数，并且现在它不会加上必需的参数标签。</p><ul><li>解决方法：替换<code>UnsafeMutablePointer&lt;Void&gt;</code>的key为<code>DispatchSpecificKey&lt;T&gt;</code>，同时加上缺少的<code>key</code>标签。</li></ul></li><li><p><code>dispatch_block_t</code> 不会自动转换为<code>(Void) -&gt; Void</code>。</p></li><li><p><code>dispatch_qos_class_t</code> 不再是必需的;用户可以使用Swift的选项设置语法设置<code>DispatchQueueAttributes</code> 成员为自己想要的配置。</p></li></ul></li></ul><h3 id="Swift-3语言细节"><a href="#Swift-3语言细节" class="headerlink" title="Swift 3语言细节"></a>Swift 3语言细节</h3><ul><li><p>迁移程序不会转换<code>rand()</code>用法，这个函数现在不能用了。需要使用<code>arc4random()</code>。</p><ul><li>解决方法：将所有的<code>rand()</code>用法都改成<code>arc4random()</code>和<code>arc4random_uniform()</code>，谨记<code>arc4random()</code>返回一个<code>UInt32</code>而不是<code>Int32</code>。</li></ul></li><li><p>迁移程序不能完全转换接受<code>ImplicitlyUnwrappedOptional</code>类型参数的闭包。</p><ul><li>解决方法：提升为使用标准可选类型。</li></ul></li><li><p>迁移程序可能错误的在需要<code>!</code>的可选类型隐式解包的值的后面插入<code>?</code>，这允许空值静默传播代替确定性陷阱。</p><ul><li>使用<code>!</code>来代替<code>?</code>，</li></ul></li><li><p>迁移程序不转换不再返回可选值的<code>if let</code>语句。</p><ul><li>解决方法：在<code>if let</code>移除对应的语句，如果你需要一个词法定界，可以它对应的语句放到<code>do</code>语句中。</li></ul></li><li><p>迁移程序不会添加为枚举值添加前置句点。当迁移程序把枚举值都变为小写时会造成冲突。</p><ul><li>解决方法：为没有前置句点的枚举值手动添加句点</li></ul></li><li><p>去掉NS前缀的Foundaiton中的类型冲突的自定义属性冲突，会自动添加模块标识的类型名字。例如：如果有这样的定义<code>var URL:NSURL</code>，它会被重写为<code>var URL: Foundation.URL</code>。</p><ul><li>解决方法：在进行代码迁移之前把这样的属性重命名，这样就会冲突了。Swift的API设计指南建议这样的应该是小写的。</li></ul></li><li><p>迁移程序不会处理C形式的递减的for循环，如：<code>for var i = right; i &gt; left; i-- {}</code></p><ul><li>解决方法：手动修改循环为for-in形式的或者while形式的循环。</li></ul></li><li><p>迁移程序可能错误的在自定义的闭包类型添加括号。如：从<code>inout State -&gt; Element?</code>变为<code>inout (State) -&gt; Element?</code>，正确的修改应该是<code>(inout State) -&gt; Element?</code></p></li><li><p>迁移程序会给SequenceType添加不必要的Swift模块标识符，如：</p><p><code>struct MySequence: SequenceType</code> =&gt;<code>struct MySequence: Swift.Sequence</code></p><ul><li>解决办法：移除前置的<code>Swift</code></li></ul></li><li><p>迁移程序可能会略掉小写之后的枚举值。</p><ul><li>解决方法：手动处理一下迁移程序忽略掉的小写的枚举值。</li></ul></li></ul><h3 id="Swift-2-3"><a href="#Swift-2-3" class="headerlink" title="Swift 2.3"></a>Swift 2.3</h3><ul><li>迁移程序在迁移到Swift2.3的过程中可能会错误的转换<code>Range&lt;T&gt;</code>为<code>CountableRange&lt;T&gt;</code>。<ul><li>解决办法：改回<code>Range&lt;T&gt;</code>，Swift2.3没有<code>CountableRange&lt;T&gt;</code>，只有Swift3有。</li><li>迁移程序会为使用了<code>dispatch_queue_set_specific()</code>添加一行这样的<code>/*Migrator FIXME: Use a variable of type DispatchSpecificKey*/</code>注释，这个只在Swift3中有用，如果是迁移到Swift2.3，可以忽略这个。</li></ul></li></ul><h3 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h3><ul><li>如果在你的工程里有多个scheme包含了不同的target，你只需要关注你要迁移的那个。你应该手动选项一个新的scheme。此时运行<em>Edit-&gt;Convert-&gt;To Current Swift Syntax</em>迁移其他的scheme，或者创建一个scheme包括工程内所有的target，并且保证在运行迁移助手工具的时候已选中这个scheme。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用Carthage-CocoaPods工程&quot;&gt;&lt;a href=&quot;#使用Carthage-CocoaPods工程&quot; class=&quot;headerlink&quot; title=&quot;使用Carthage/CocoaPods工程&quot;&gt;&lt;/a&gt;使用Carthage/CocoaPods
      
    
    </summary>
    
    
      <category term="Swift" scheme="http://bugcode.net/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>6/7月杂记</title>
    <link href="http://bugcode.net/2016/07/18/6-7%E6%9C%88%E6%9D%82%E8%AE%B0.html"/>
    <id>http://bugcode.net/2016/07/18/6-7月杂记.html</id>
    <published>2016-07-18T08:02:10.000Z</published>
    <updated>2018-06-30T11:01:41.148Z</updated>
    
    <content type="html"><![CDATA[<p>每次写这种记录就是胡言乱语的流水帐，之后再回去看一眼时候，感觉当时心情是千军万马，火急火燎的。至少有半个月没有碰这个小(ji)博(shi)客(ben)了，趁端午节的调休假记录一下这二个月。流水帐开始:</p><ul><li>游戏上线了，算是很成功，这可能还是小事儿，最高兴的是终于可以不用像之前那样加班加点几乎每天熬夜了，熬夜对身体影响真得特别明显。好像身边的小伙伴都松了一口气，也终于有时间早回家一会打打游戏，看看闲书，看看电影，可能屌丝的想法就是这样吧…</li></ul><ul><li>最近玩儿了一下《火炬之光2》，用法师通关了，从小就喜欢这种类型这种视角的游戏(可能是手残玩不了那种策略类型的)，画面在4K显示器下相当棒，就是浮动的UI窗口(貌似学名叫HUD?)在4K分辨率下显示得相当小，不过影响不大，宠物带东西回城这个很好，火柱技能，虽然有时候感觉移动速度太慢追踪也略显示迟钝，如是这二个弱点也没有，那这估计就是一个bug技能了，用来刷怪是相当爽的。下来准备玩儿一下工程师…</li></ul><ul><li>Swift 3.0的开发者预览版已经发布了，看了一下改动提案里面已经实现的就几十条了，还有没完全实现的几十条，这次从Swift 2.x迁移到Swift 3.0估计需要些工作量了，官方给了一个Swift 3的迁移工具，昨天弄到挺晚把那个官方的迁移说明翻译了一下(虽然翻译功底很烂，就当自己熟悉学习了)。最近还买了一本《Cocoa Programming for OSX》第五版，虽然是全英文的，但是看起来还不算费劲，看了四分之一，感觉对macOS编程还是帮助很大的，吃灰了好几个月的Kindle终于又见了天日，用来看这种英文书是真得很爽。</li></ul><ul><li>这两天没事儿，把大学时候用的笔记本翻了一下，居然在硬盘里找到了2013年8月我开始翻译的那本开源的《Advanced Linux Programming》，而且已经翻译了四章，四万多字…后来我就换了电脑，然后就把这事儿给忘了。我当时是怎么想的，那个时候的执行力真是好。虽然翻译得不怎么好，但也不能虎头蛇尾，copy出来继续，已在github建了repo。</li></ul><ul><li>说了执行力又想到了一个打脸的事，之前看得那个非常不错的配色，想配一个vim scheme出来，结果到现在也一直没实施，真是容易产生惰性。对，还有那个翻译了三分之二的Swift 3的变动列表。</li></ul><ul><li>TODO: <ol><li>把没翻译完的Apple官方的迁移指南翻译完，Swift 3变动列表翻译完</li><li>配色bugcolor配置完</li><li>基本架子搭起来的MacCalendar边学边继续</li></ol></li></ul><p><em>End</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每次写这种记录就是胡言乱语的流水帐，之后再回去看一眼时候，感觉当时心情是千军万马，火急火燎的。至少有半个月没有碰这个小(ji)博(shi)客(ben)了，趁端午节的调休假记录一下这二个月。流水帐开始:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游戏上线了，算是很成功，这可能还是小事儿，最高
      
    
    </summary>
    
    
      <category term="life" scheme="http://bugcode.net/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Swift3迁移指南-1</title>
    <link href="http://bugcode.net/2016/07/18/Swift3%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97-1.html"/>
    <id>http://bugcode.net/2016/07/18/Swift3迁移指南-1.html</id>
    <published>2016-07-17T17:23:56.000Z</published>
    <updated>2018-06-30T11:01:40.888Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h3><p>Swift3开发者预览版已经开放了，3.0release估计很多就来了，Swift 3相对于Swift2.x变动非常大，看官方有一个Swift 3的官方迁移指南，这里粗略翻译了一下，也算是自己熟悉一下。分成二部分翻译，第一部分就是迁移程序的各种注意事项，第二部分是各种细节问题解决方案。后续把swift-evolution的语法/特性变动列表翻译一下。</p><p>Xcode8.0带来了一个迁移工具，能帮你将现在的Swift工程迁移到Swift3，也能让你的工程更新到Swift2.3和新的SDK版本。</p><h3 id="预迁移准备"><a href="#预迁移准备" class="headerlink" title="预迁移准备"></a>预迁移准备</h3><p>为了达到最好的迁移效果，确保你想要迁移的工程能在Xcode7.3下构建成功，并通过了所有测试。</p><p>同时还要保证工程在版本管理之下，这能让你看到在通过迁移助手迁移完成之后工程内的变化，并且在有需要的时候可以随时回退变化，再次去尝试迁移。</p><p>假如有多个scheme用来构建不同的独立product(或者对应不同平台下相同的product)，那么在你的工程里创建一个为你需要的所有平台构建所有东西的scheme还是相当重要的，包括你用于的单元测试的target。迁移助手会根据你选择的scheme的更改来生成，所以所有需要处理的target都要一起到包含到这个scheme里。</p><p>要检查或者修改已经被包含到scheme里的target，选中“Edit Scheme”选项，在左侧切换到“Build”标签，确认你所有的target和其单元测试都已经被包含进scheme里了。</p><p>如果你的工程依赖由Carthage或者CocoaPods提供的第三方开源的工程，参考<a href="">使用Carthage/CocoaPods工程</a>这节。</p><h3 id="Swift迁移助手"><a href="#Swift迁移助手" class="headerlink" title="Swift迁移助手"></a>Swift迁移助手</h3><p>当你首次用Xcode8.0打开工程的时候，会有弹窗提示你通过迁移助手来做一个迁移测试。这个工具也可以通过菜单“Edit-&gt;Convert-&gt;To Current Swift Syntax…”手动打开。</p><p>你可以执行下面二种迁移:</p><ul><li><strong>使用Swift2.3</strong> 修改你的工程开启<em>使用旧式Swift</em>的构建设置，并提供代码更改来确保可以在新的SDK下使用。</li><li><strong>使用Swift 3</strong> 推荐使用这种。你的工程得到代码的更改且能通过Swift3.0来构建，同时能使用Xcode8.0里面的所有新功能。</li></ul><p>你还可以选择先将工程通过迁移助手迁移到Swift2.3，之后再迁移更新到Swift3.0。</p><p>在你使用迁移助手选择“使用Swift2.3”或者“使用Swift3.0”之后，你得到一个将要被迁移的target的列表。此时这些target不包含任何Swift代码并且也不能被选中。有一个已知的问题，影响那些不包含Swift文件但是“Emned Swift Standard Libraries”设置却可用的target，原本这个设置应该被勾选的，但是却没有。安全起见，把所有的列表中target都选上。</p><p>点击“Next”，会来到“Generate Preview(生成预览)”页，助手即将开始启动迁移来生成代码的更改。当这些都完成之后，在点击“Save”之后，你会看到所有这些变动都会生效。注意这点， 在比较的界面中，原始的代码(转换之前的)在右边，变动之后的在左边。点击“Save”之后，这些代码变动就会应用到原始文件里。如果你选择的是迁移到Swift2.3，所有这些target都会拥有一个“<em>使用旧式Swift</em>”的构建设置集合。</p><p>在处理target的时候可能会出现影响迁移处理的问题。切换到“Report Navigator”选择“Convert”入口；这是一个转换的生成日志。检查日志里显示的错误，如果你发现错误是从你自己的一个target中引入Swift模块失败了(比如，“No Such module ‘NAME’ ，这里显示的‘NAME’是其中一个target的名字”)，这可能是你遇到了一个已知的问题，就是迁移工具生成时没有正确的处理隐式的依赖模块(也就是这个叫‘NAME’的target没有在处理依赖它的target的之前处理)。解决办法，编辑scheme在‘Build’标签里显式的加入这个target(点击左下的加号按钮，在已选择的target列表中找到这个target)，在列表中，如果依赖它的target在它前面。“Parallelize Build”项必须不能勾选。</p><p>如果看到的错误是关于不能签名target，试着在这个target的构建设置禁用签名。</p><p>如果看到其他的错误，请在<a href="https://bugreport.apple.com详细描述并反馈。" target="_blank" rel="noopener">https://bugreport.apple.com详细描述并反馈。</a></p><p>如果你需要使用其他任何的替代方法，回退之前所有通过迁移助手产生的变动，使用替代方法，再手动用迁移助手从头开始转换一次。</p><h3 id="Swift-3-迁移变动概览"><a href="#Swift-3-迁移变动概览" class="headerlink" title="Swift 3 迁移变动概览"></a>Swift 3 迁移变动概览</h3><p>Swift 3有非常多的重大变动，迁移工具会帮你。你可以通过下面的链接大致看一下Swift 3的改进提案:  </p><p><a href="https://github.com/apple/swift-evolution]" target="_blank" rel="noopener">https://github.com/apple/swift-evolution]</a>(<a href="https://github.com/apple/swift-evolution" target="_blank" rel="noopener">https://github.com/apple/swift-evolution</a></p><p>下面是一份简要的源码崩坏修复的概述:</p><h4 id="API设计指南"><a href="#API设计指南" class="headerlink" title="API设计指南"></a>API设计指南</h4><p>Objective-C的API已经依照Swift的API设计指南来引入。这会同时影响如何引入SDK和用户自己的Objective-C的frameworks。Swift标准库也做了很多改动来遵循设计指南。更多细节请参考提案<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md" target="_blank" rel="noopener">SE-0005 - Better Translation of Objective-C APIs Into Swift</a>.</p><p>迁移程序会把用户自己定义的枚举都变成小写以此来让它们与新的设计指南相匹配。</p><h4 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h4><p>像CoreGraphics，Dispatch，Foundation里的其他类型这些主要的framework，不再做为一组全局函数和变量来引入了，改为做为Swift类型各自的方法和属性来引入。更多细节请看提案<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md" target="_blank" rel="noopener">SE-0044 - Import as member</a>, <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md" target="_blank" rel="noopener">SE-0088 - Modernize libdispatch for Swift 3 naming conventions</a>.</p><p>Swift 3里在主要的基础类型中，‘NS’前缀已经被移除了。请看<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0086-drop-foundation-ns.md" target="_blank" rel="noopener">SE-0086 - Drop NS Prefix in Swift Foundation</a>.</p><h4 id="Swift-标准库"><a href="#Swift-标准库" class="headerlink" title="Swift 标准库"></a>Swift 标准库</h4><p>Swift 3中集合类型的索引模型被改动的相当大，更多细节在此<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md" target="_blank" rel="noopener">SE-0065 - A New Model for Collections and Indices</a></p><p>最明显的改就是不再有像<code>successor()</code>，<code>predecessor()</code>，<code>advancedBy(_:)</code>，<code>advancedBy(_:limit:)</code>，或者<code>distanceTo(_:)</code>这些索引方法了。这些操作都被移到用于递增和递减切片集合中了。</p><blockquote><p>myIndex.successor()  =&gt;  myCollection.index(after: myIndex)<br>myIndex.predecessor()  =&gt;  myCollection.index(before: myIndex)<br>myIndex.advance(by: …) =&gt; myCollection.index(myIndex, offsetBy: …)</p></blockquote><p>如果迁移程序不能检测到集合是用于切片，就会插入一个编辑器占位符，这时就需要自己必须填入正确的集合了。</p><p> 为了支持集合的更改，Range类型也做了一些变动。之前的<code>x..&lt;y</code>和<code>x...y</code>产生相同的Range<t>类型。现在这些表达式能产生四种类型:<code>Range</code>， <code>CountableRange</code>，<code>ClosedRange</code>，<code>CountableClosedRange</code>。我们将<code>Range</code>拆分为<code>Range</code>和<code>ClosedRange</code>类型允许包含类型最大值的闭区间(如，<code>0...Int8.max</code>是可以的)。普通的区间类型和它们的~Countable变体在功能上的不同:</t></p><ul><li><code>Range&lt;Bound&gt;</code>与<code>ClosedRange&lt;Bound&gt;</code>现在只需要<code>Comparable</code>做为边界。这意味你可创建一个<code>Range&lt;String&gt;</code></li><li><code>Range</code>和<code>ClosedRange</code>不能被遍历(它们不再是集合类型)，因为值仅是一个不能被递增的<code>Comparable</code></li><li><code>CountableRange</code>和<code>CountableClosedRange</code>需要<code>Strideble</code>，并且它们符合<code>Collection</code>，所以可以遍历它们。</li></ul><p><code>..&lt;</code>和<code>...</code>操作符试着做正确的事情并返回最符合的区间，所以像这样的代码<code>for i in 1..&lt;10</code>推导出一个<code>CountableRange</code>类型，代码还是可以正常工作的。假如你有一个做为一个区间类型的变量，并且你想把它传给一个接收不同类型的区间类型的API，这时需要在区间类型变量上使用构造器来转换一下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="number">0</span>..&lt;<span class="number">10</span> <span class="comment">// CountableRange&lt;Int&gt;</span></span><br><span class="line"><span class="type">Range</span>(r) <span class="comment">// converts to Range&lt;Int&gt;</span></span><br></pre></td></tr></table></figure><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><ul><li><p><strong>函数第一个参数标签一致化</strong></p><p>现在是考虑函数默认要有第一个参数标签，请看<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0046-first-label.md" target="_blank" rel="noopener">SE-0046 - Establish consistent label behavior across all parameters including first labels</a>。迁移程序会添加下划线标签，以保留已经存在API:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(bar: Int)</span></span> =&gt; <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> bar: Int)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>对UnsafePointer<t>的处理变动</t></strong></p><p>在Swift 3中，现在是使用可选类型来表示可为空的空对象指针类型，如<code>UnsafePointer&lt;Int&gt;?</code>，请看 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md" target="_blank" rel="noopener">SE-0055 - Make unsafe pointer nullability explicit using Optional</a>。这表示<code>UnsafePointer</code>，<code>UnsafeMutablePointer</code>，<code>AutoreleasingUnsafeMutablePointer</code>， <code>OpaquePointer</code>，<code>Selector</code>， 和 <code>NSZone</code>现在表示非可空指针，也就是这些指针永不为<code>nil</code>。使用这些类型的代码可能需要做这几项更改:</p><ul><li><p>要设置指针为<code>nil</code>，类型必须是可选的。迁移程序会处理几种简单的情况，但是通常你必须确定你的指针是仅仅如对象引用一样可以为可选类型。</p></li><li><p>从C函数获取的返回的可为空的结果在访问<code>pointee</code>属性(原来的<code>memory</code>)或者下标元素之前必须显式解包。这里链式可选语法还是可以继续使用的。如:</p><p><code>result?.pointee = sum</code>。</p></li><li><p>接收或者返回指针类型的回调(C函数或者blocks)必须与使用或者忽略<code>Opional</code>类型的原始定义相一致。</p></li><li><p>由于编译器的限制，不允许传递指针给使用了C可变参数的函数(如NSLog)。替代方法是使用下面这种形式用一个指针大小的整型来代替，做为参数传递过去:</p><p><code>Int(bitPattern: nullablePointer)</code>。</p></li></ul></li><li><p><strong>现在Objective-C轻量泛型类型做为泛型类型引入</strong></p><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md" target="_blank" rel="noopener">SE-0057 - Importing Objective-C Lightweight Generics</a></p><p>因为Objective-C的泛型不会在运行时表现，所以在Siwft中使用他们有一些限制:</p><ul><li><p>如果Objective-C的泛型类被用于<code>as?</code>，<code>as!</code>，或者<code>is</code>转换中，这个泛型的参数不会在运行时被检查。如果转换成功的操作数是一个Objective-C的类实例，那参数就会忽略。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="type">NSFoo</span>&lt;<span class="type">NSNumber</span>&gt;(value: <span class="type">NSNumber</span>(integer: <span class="number">0</span>))</span><br><span class="line"><span class="keyword">let</span> y: <span class="type">AnyObject</span> = x</span><br><span class="line"><span class="keyword">let</span> z = y <span class="keyword">as</span>! <span class="type">NSFoo</span>&lt;<span class="type">NSString</span>&gt; <span class="comment">// Succeeds</span></span><br></pre></td></tr></table></figure></li><li><p>Swift 子类只能继承一个参数类型被完全指定的Objective-C泛型类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error: Can't inherit Objective-C generic class with unbound parameter T</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwiftFoo1</span>&lt;<span class="title">T</span>&gt;: <span class="title">NSFoo</span>&lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"><span class="comment">// OK: Can inherit Objective-C generic class with specific parameters</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwiftFoo2</span>&lt;<span class="title">T</span>&gt;: <span class="title">NSFoo</span>&lt;<span class="title">NSString</span>&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>Swift可以扩展Objective-C泛型类，但是扩展不能含有约束，并且扩展内定义不能访问类的泛型参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSFoo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Error: Can't access generic param T</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">T</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Error: extension can't be constrained</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSFoo</span> <span class="title">where</span> <span class="title">T</span>: <span class="title">NSString</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基本容器类<code>NS[Mutable]Array</code>， <code>NS[Mutable]Set</code>，和<code>NS[Mutable]Dictionary</code>现在仍然做为非泛型类型引入。</p></li></ul><p>​</p></li></ul><h3 id="迁移之后"><a href="#迁移之后" class="headerlink" title="迁移之后"></a>迁移之后</h3><p>虽然迁移程序会替你处理那些固定的变动，但还是可能需要你进行大量的手动修改以保证在迁移程序做出迁移改动之后能成功构建出项目。</p><p>你可能会看到一些已经关联到的fixit错误；虽然迁移程序是用来消除Swift 3编译器提供的fixit的，但是一个已知的限制就是迁移程序不能保证100%的没问题(特别是在二个target之间有内部之间的依赖的的时候)，可能会有些fixit会被忽略掉。</p><p>即使编译没问题，迁移程序生成的代码也不是完美的，比如，你可能会看到转换为带‘NS’前缀的类型(<code>url as NSURL</code>)，这样的代码显然是使用相关API重构为新的<code>URL</code>类型更为合适。你会看到迁移程序会在需要转换为更合适的代码的地方加入了新的注释(<code>/*Migrator FIXME: ...*/</code>)。</p><p>查看<a href="https://swift.org/migration-guide/#known-migration-issues" target="_blank" rel="noopener">Known Migration Issues</a>这节，是一个你在迁移工程的过程中可能会遇到的问题的列表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h3&gt;&lt;p&gt;Swift3开发者预览版已经开放了，3.0release估计很多就来了，Swift 3相对于Swift2.x变动非常大，看官方有一个Swif
      
    
    </summary>
    
    
      <category term="Swift" scheme="http://bugcode.net/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>端午节后碎念</title>
    <link href="http://bugcode.net/2016/06/27/%E7%AB%AF%E5%8D%88%E8%8A%82%E5%90%8E%E7%A2%8E%E5%BF%B5.html"/>
    <id>http://bugcode.net/2016/06/27/端午节后碎念.html</id>
    <published>2016-06-26T16:52:20.000Z</published>
    <updated>2018-06-30T11:01:40.864Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一个月内一直在各种忙，项目马上上线，各种问题都来了，虽然不是身居要职但是问题也特别多，说焦头烂额也不为过，每天处于各种加班状态中感觉时间过得特别快。端午节没休息，国内游戏行业好像都是这个状态，一言不合就疯狂加班😂。</li></ul><ul><li>不同公司技术栈不同特别是游戏这个东西，到后期在大陆上的游戏都避免不了一个事情就是Android的各种渠道商的接入，不同公司有不同处理方式，可能是对Android没有深入了解过，只知道比葫芦画瓢，很多时候会出各种问题，尤其对Android的各种线程的处理，回调函数里非线程安全的操作要Handle到主线程操作之类的，虽然之前进过坑，但是突然发现『每个坑里的风景也是不尽相同呐……』。最近补一下Android线程相关的东西。找时间整理记录一下。</li></ul><ul><li>上个在掘金网站看到一个讲配色的文章，里面有一个地铁站的例子，给了一个配色网格图，个人特别喜欢，一直想参照那个配色把它搞成Vim的Colorscheme，名字都想好了—<strong>bugcolor</strong>，本打算在端午节完成，无奈又加了三天班，近期完成一下。</li></ul><ul><li>上周看了一下《天启》，看得时候好爽，各种特效爽翻，看得一愣一愣的，但是看完了脑袋里除了各种特效场面啥也没有，剧情照着《逆转未来》差太多，天启这么一个无敌的存在，最后就让凤凰女给秒了，后来就想，如果让幻影猫把天启和哨兵搞到一起，是不是很欢乐🤔。最近又把《火炬之光2》玩了一下，就回想起当年在高中放假就去网吧刷《暗黑破坏神》，手残就喜欢这种无脑点鼠标。给媳妇儿买了一年的爱奇艺会员，然后看《Mr. Robot》的时候给推荐了一个叫《余罪》网络剧，随便点了看了一下，结果一发不可收拾，二天直接看完了，还挺有意思的。</li></ul><ul><li>最近玩了几个好玩的单机手机游戏<ol><li>《Mekorama》类似《纪念碑谷》，画面没有后者精细，但是可以自定义关卡。</li><li>《DreamMachine》也类似，但是画就更糙了一些，但是感觉还挺耐玩儿的。</li><li>《Beat Racer》放一首歌，然后控制一个小车在跑道上跑，画面挺带感的，突然就想起了当年的盛大的那个《疯狂赛车》，一玩儿就是一下午，暴露年龄😳。</li></ol></li></ul><ul><li>完这阵真得找个时间放松一下，找个地儿去溜达一圈，今年还没出去溜达过。也算是给自己的一点回报和鼓励吧。</li></ul><p><em>End</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;一个月内一直在各种忙，项目马上上线，各种问题都来了，虽然不是身居要职但是问题也特别多，说焦头烂额也不为过，每天处于各种加班状态中感觉时间过得特别快。端午节没休息，国内游戏行业好像都是这个状态，一言不合就疯狂加班😂。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;不同
      
    
    </summary>
    
    
      <category term="life" scheme="http://bugcode.net/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Function Currying</title>
    <link href="http://bugcode.net/2016/06/26/Function-Currying.html"/>
    <id>http://bugcode.net/2016/06/26/Function-Currying.html</id>
    <published>2016-06-26T08:17:46.000Z</published>
    <updated>2018-06-30T11:01:40.960Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>前几天Swift发布3.0预览版，改动的还不小，不兼容Swift2.2，加了诸多特性，也去掉了不少语法，看到的第一个就是在Swift3.0里去掉了<strong>Function Currying(函数柯里化)</strong>的语法声明形式，具体可以看<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md" target="_blank" rel="noopener">这里</a>。之前从来没有了解过这个术语，只知道大致的意思，这里记录一下。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>函数柯里化是计算机科学里的术语，简单的说就是把一个接受<strong>多个参数</strong>的函数转换为接受<strong>一个参数</strong>的函数，并且<strong>返回</strong>一个这样的<strong>函数</strong>，这个函数接受剩下没有处理的参数且把最终结果返回。具体可参照<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">Wiki</a>的解释。</p><h3 id="为什么要使用函数柯里化"><a href="#为什么要使用函数柯里化" class="headerlink" title="为什么要使用函数柯里化"></a>为什么要使用函数柯里化</h3><p>函数式编程的思想，把函数变成”一个输入一个输出”的单个小片段，从而可以更好的与其他接口组合出更强大的功能，整个过程也更易理解，看起来就是把一大堆复杂的东西，”一步一步的”构造出来，而这中间的过程都是单一的可组合的，更加灵活的。至于为什么Swift3.0会去掉函数柯里化的语法，<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md" target="_blank" rel="noopener">SE-0002</a>提案给出的解释是在Swift里柯里化的功能有限，且增加了语言实现的复杂度。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Lua中实现类似的函数柯里化</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying_test</span><span class="params">(fir)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(sec)</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(thr)</span></span></span><br><span class="line">            <span class="keyword">return</span> fir * sec * thr</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(currying_test(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)) <span class="comment">-- 输出24</span></span><br></pre></td></tr></table></figure><p>Python中也是类似，不过Python中的functiontools包中还有partial，可以组合出类似的功能。通过固定某些参数的值，组合出更灵活的返回函数完成更多功能。</p><p>Swift2.2中的函数柯里化</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">curryingFunction</span><span class="params">(fir:Int)</span></span>(<span class="number">_</span> sec:<span class="type">Int</span>)(<span class="number">_</span> thr:<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fir + sec + thr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> addSec = curryingFunction(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> addThr = addSec(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">let</span> res = addThr(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(res) <span class="comment">// 输出33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接像上面lua那样直接调用</span></span><br><span class="line"><span class="built_in">print</span>(curryingFunction(<span class="number">10</span>)(<span class="number">11</span>)(<span class="number">12</span>))</span><br></pre></td></tr></table></figure><p>可能在实际项目中不会追根究底的去这样儿用，只求达到最终目的，或者是并没有理解到柯里化的真正精髓，但是多知道一些总是好的。</p><p><em>End记录</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数柯里化&quot;&gt;&lt;a href=&quot;#函数柯里化&quot; class=&quot;headerlink&quot; title=&quot;函数柯里化&quot;&gt;&lt;/a&gt;函数柯里化&lt;/h3&gt;&lt;p&gt;前几天Swift发布3.0预览版，改动的还不小，不兼容Swift2.2，加了诸多特性，也去掉了不少语法，看到的第一个
      
    
    </summary>
    
    
      <category term="Swift" scheme="http://bugcode.net/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>好用的shell命令和常用的SVN命令记录</title>
    <link href="http://bugcode.net/2016/06/16/%E5%A5%BD%E7%94%A8%E7%9A%84shell%E5%91%BD%E4%BB%A4%E5%92%8C%E5%B8%B8%E7%94%A8%E7%9A%84SVN%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95.html"/>
    <id>http://bugcode.net/2016/06/16/好用的shell命令和常用的SVN命令记录.html</id>
    <published>2016-06-16T15:11:24.000Z</published>
    <updated>2018-07-05T13:51:16.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用的命令行SVN命令"><a href="#常用的命令行SVN命令" class="headerlink" title="常用的命令行SVN命令"></a>常用的命令行SVN命令</h2><p>现在的版本管理工具都有相当人性化的GUI版本，无论是免费的收费的，都做得相当好，点几个按钮，选几个文件，提交，回退，更新，一步就完成了，但是最近在公司的Mac下(低配Mac mini，你懂的…)，很多GUI版本的工具都非常慢，卡顿非常严重，而且对SVN的外链(external)支持不好(像CornerStone这个SVN的GUI工具)，也就是在版本管理工具的内部的文件视图里，看不到external属性下的文件，只能看到最上级的目录，而实际的目录中却有对应的文件，只是不能在GUI的版本工具中进行操作，这个情况下就只能在对应的外链目录下通过终端进行提交了。一段时间下来，发现一堆命令都忘了，只会在GUI工具上点来点去，一旦遇到上面那种情况，就得傻眼半天，这里记录一下常用的SVN命令行命令。</p><ol><li><p>检出(Check Out)</p><blockquote><p>svn checkout <server-path></server-path></p><p>ex: svn checkout svn://dev.bugcode.net/demo/svn_demo</p><p>short: svn co</p></blockquote></li><li><p>更新文件</p><blockquote><p>svn update [-r version_code] <file-path></file-path></p><p>svn update # 直接更新当前目录和子目录的所有文件</p><p>ex: svn update -r 1028 demo.c # 把当前目录下的demo.c还原到版本号是1028的版本</p><p>svn update <file-name> # 更新指定文件到最新</file-name></p><p>short: svn up</p></blockquote></li><li><p>向版本库添加文件，支持通配符</p><blockquote><p>svn add <file-name></file-name></p><p>ex: svn add demo.swift  /  svn add *.cpp</p></blockquote></li><li><p>提交文件</p><blockquote><p>svn commit -m “commit-log” <path-file></path-file></p><p>ex: svn commit -m “commit message for svn” ./demo_dir/demo.c</p><p>short: svn ci</p></blockquote></li><li><p>回退文件(直接解决冲突状态，但不会回退被删除的文件)</p><blockquote><p>svn revert <file-path></file-path></p><p>ex: svn revert ./demo/demo.c</p></blockquote></li><li><p>删除文件</p><blockquote><p>svn delete <file-path> -m “delete message”</file-path></p><p>ex: svn delete svn://dev.bugcode.net/demo/demo_need_file -m “delete message for svn” # 相当于直接删除版本库里的文件</p><p>ex svn delete ./demo/demo_need_file -&gt; svn commit -m “delete message” # 先删除本地副本中的对应文件，再提交</p><p>short: svn delete / svn remove / svn rm</p></blockquote></li><li><p>查看log</p><blockquote><p>svn log <file-path></file-path></p></blockquote></li><li><p>比较差异</p><blockquote><p>svn diff <file-path></file-path></p><p>svn diff version1:version2 <file-path></file-path></p><p>ex: svn diff ./demo.c  / svn diff 1028:1000 ./demo.c</p><p>short: svn di</p></blockquote></li><li><p>显示属于版本库管理的目录和文件，直接创建属于版本库管理的目录</p><blockquote><p>svn list <path></path></p><p>ex: svn list ./</p><p>short: svn ls</p><p>svn mkdir <path></path></p><p>ex svn mkdir test_dir</p></blockquote></li><li><p>解决冲突，这里的命令只是用来移除对应文件的冲突状态(删除对应的标记冲突的文件)，具体的文件冲突还是需要手动去文件解决</p><blockquote><p>svn resolved <file-path></file-path></p><p>ex: svn resolved ./conflicted_file_name</p></blockquote></li></ol><h2 id="有用的shell命令"><a href="#有用的shell命令" class="headerlink" title="有用的shell命令"></a>有用的shell命令</h2><p>shell命令天天在用，除了ls，cat，pwd，cp，mv类似这些常用的，有些提高效率的命令用起来还是可以缩短不少输入时间的。脑袋不好使这里一起记录一下</p><ol><li><p>zsh下的进入当前目录下的前二级目录，bash没有！</p><blockquote><p>cd …</p></blockquote></li><li><p>都知道 <strong>~</strong> 是home目录，但是cd之后什么也不加也是相当于 <strong>cd ~</strong></p></li><li><p>中划线，直接<strong>cd -</strong>可以进入上次cd进入的目录，比如现在test目录进入test目录下的next目录，这时执行cd -,就会再回到test目录下，再执行cd -就又回到test目录下的next目录下了。</p></li><li><p>快捷键</p><ul><li>ctrl + a: 回到行首</li><li>ctrl + e: 去到行尾</li><li>ctrl + u / ctrl + y: undo / redo</li><li>ctrl + z: 当前正在运行的程序放到后台执行</li></ul></li><li><p>$? 获取上一个命令的返回结果，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Terminal output test."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后生成的可执行文件运行后，想看一下main函数的返回值，就可以在文件运行后，使用$?来查看return的具体值。</p></li><li><p>!! 输出上一次命令，并执行</p></li><li><p>!$ 输出上一次命令的最后一个字符串</p></li><li><p>快速创建文件，touch file 或者 &gt; file(更短更快)</p></li><li><p>fgrep “string” 快速查找当前目录包含string这个串的文件并输出，加-r选项可以查所有子目录</p></li></ol><p><em>end</em> 生活不只有眼前的苟且，还有远方的苟且。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用的命令行SVN命令&quot;&gt;&lt;a href=&quot;#常用的命令行SVN命令&quot; class=&quot;headerlink&quot; title=&quot;常用的命令行SVN命令&quot;&gt;&lt;/a&gt;常用的命令行SVN命令&lt;/h2&gt;&lt;p&gt;现在的版本管理工具都有相当人性化的GUI版本，无论是免费的收费的，都
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://bugcode.net/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ADB命令使用记录</title>
    <link href="http://bugcode.net/2016/06/14/ADB%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html"/>
    <id>http://bugcode.net/2016/06/14/ADB命令使用记录.html</id>
    <published>2016-06-14T13:57:09.000Z</published>
    <updated>2018-06-30T11:01:41.149Z</updated>
    
    <content type="html"><![CDATA[<p>经常在Mac在安装操作Android真机，但是Mac对于Android的设备支持，你懂的，没有Windows那么方便，经常把文件copy来copy去就为了把文件放到Android手机里，特别不方便，现在知道了Android sdk的adb(Android Debug Bridge)，这里面的adb push 和adb pull命令特别好用，直接可以用Android真机连Mac把文件从电脑push到Android，或者使用pull命令把Android机拉到Mac机上。这里记录一下其他的adb命令，在调试真机的时候还真是特别有用，可以在电脑上全面操作Android真机。安装不需多说，直接把对应的adb所在目录加到环境变量里就行。</p><ol><li><p>查看adb 帮助</p><blockquote><p>adb help</p></blockquote></li><li><p>从电脑向电脑上复制文件</p><blockquote><p>adb push local_file device_path</p></blockquote></li><li><p>从真机向电脑上复制文件</p><blockquote><p>adb pull device_path_file local_path</p></blockquote></li><li><p>直接进入真机shell</p><blockquote><p>adb shell #进入之后可以使用一般的linux命令来查看相关信息</p></blockquote></li><li><p>也可以直接使用adb shell + 命令来执行，类似如下：</p><blockquote><p>adb shell cat /proc/meminfo # 内存占用</p><p>adb shell cat /proc/cpuinfo # cpu序列号</p><p>adb shell procrank # 查看各个进程的内存情况</p><p># 还有类似cd，ls，top，ps，grep，rename，rm，mv，chomd，mkdir等命令…</p></blockquote></li><li><p>安装，卸载apk</p><blockquote><p>adb install <apk-file-name> # 安装到手机内存</apk-file-name></p><p>adb install -s <apk-file-name> # 安装到手机sd卡</apk-file-name></p><p>adb install -r <apk-file-name> # 重新安装文件，不清除数据和缓存</apk-file-name></p><p>adb uninstall <package-file> # 这里的参数不是apk文件名，是安装之后的包的名字</package-file></p></blockquote></li><li><p>查看后台service信息</p><blockquote><p>adb service list</p></blockquote></li><li><p>查看bug反馈</p><blockquote><p>adb bugreport</p></blockquote></li><li><p>清除logcat缓存，在命令行里查看logcat输出</p><blockquote><p>adb logcat -c</p><p>adb logcat -s &lt;过滤标签名&gt;</p></blockquote></li><li><p>还可以查看wifi密码，获取设备名称</p><blockquote><p>adb shell cat /data/misc/wifi/*.conf</p><p>adb shell cat /system/build.prop</p></blockquote></li><li><p>重启机器</p><blockquote><p>adb reboot # 和linux命令行差不多</p></blockquote></li><li><p>查看连接所有的设备，获取序列号，设备ID</p><blockquote><p>adb services</p><p>adb get-serialno</p><p>adb get-product</p></blockquote></li><li><p>Android 系统中sd卡的路径</p><blockquote><p>cd /sdcardX # X是sd卡序号 如sdcard1</p></blockquote></li><li><p>退出adb的shell模式</p><blockquote><p>exit # 直接exit退出adb shell</p></blockquote></li></ol><p>到此已经差不多够用了。</p><p><em>记录end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经常在Mac在安装操作Android真机，但是Mac对于Android的设备支持，你懂的，没有Windows那么方便，经常把文件copy来copy去就为了把文件放到Android手机里，特别不方便，现在知道了Android sdk的adb(Android Debug Bri
      
    
    </summary>
    
    
      <category term="Android" scheme="http://bugcode.net/tags/Android/"/>
    
  </entry>
  
</feed>
