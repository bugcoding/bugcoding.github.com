<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《小狗钱钱》]]></title>
    <url>%2F2017%2F04%2F28%2F%E3%80%8A%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%E3%80%8B.html</url>
    <content type="text"><![CDATA[本来对这种书名的书向来是不感冒的，但是在V站书单推荐里看到了几次这本书之后查了一下，豆瓣评分9.0，趁着囤书的机会就买了看了一遍，说实话，读写之后感觉7.5-8.0还是可以的，9.0感觉有些夸张了，可能是大家考虑到是面向小孩子理财的，才打了高分？ 即使打7.5或者8.0，也足以说明这本书写得够吸引人了，书的封面也足够讨喜，我第一次看到《小狗钱钱》这个书名时，想到的封面就是那种书摊上泛滥的成功学书的封面，一大堆带叹号的营销语句… 《小狗钱钱》通过一个叫吉娅的小女孩儿的种种经历来讲述理财的必要性，科普理财的知识，故事本身是童话色彩的，读着轻松并且有读下去的欲望，很多道理对于成人来讲也是很受用的，如果是已为人父为人母的人读完了，还能把这个故事继续讲给自己的孩子听，这样既让孩子听了故事，也学会了理财知道，还懂了做人道理，故事中有一只会说话的小狗，时不时还有一些稍微起伏的剧情，足够吸引小孩子了。 有几段印象特别深刻，只是一句话，就深有同感 『试一下都不愿意，总是想着”这事是做不成的”，这样肯定不成』。 这是一个普遍存在于大人们世界中的问题，可能有些思想已经深入骨髓，做事(特别是看起来有些困难的事)总会事先自己给自己设置障碍，从而在犹豫中失去了主动权。 『我们的支出永远是随着我们的收入而增长的』。 深有同感，可能一个月赚五千块的时候，想着我能买个iPhone就很好，等赚到一万的时候就会想: 我得买个Macbook用用了，所以有时候盲目的一味存钱是不正确的，要有正确投资观念。 『吉娅，你应该首先考虑一下，你是否真的买得起这张 CD』。 这是钱钱第一次对吉娅说的话，也是理财科普的开始，这里说得也是大多数人在理财上会犯的错误，冲动消费，没有理财的概念，无法做到对自己钱财量入为出，不能合理的分配钱财。 『注意力要集中在你知道的，能做的和拥有的事情上』。 看起来像一句鸡汤，但是的确是要践行的道理，总是苦恼于自己无能为力的事情(像吉娅的父母，每天都为贷款而焦虑，注意力都在这上面，而忽略了应该怎么积累财富这个根本性的问题)，而忽略了原本应该去花时间花精力去做的事，要擅于利用自己的长处去赚钱。 『生命中出现美好的东西是因为你做了原本不敢做的事』。 吉娅从拒绝去演讲，到被海内鼓励，被金先生指导，再想着去尝试演讲，接着在演讲的路上又打退堂鼓，下来到场上的紧张，后来顺利演讲完得到朋友们的喝彩，这个心路历程，想必每个人都经历过。 72公式 / 72 法则 72公式: 书中提到的计算投资收益翻番所需时长的公式，同时也是计算通货膨胀让你的货币贬值一半所需时间的公式。计算方法就是: 用72除以投资的年收益率(复利)的百分比，得出的数字就是这笔钱翻一番所需要的时长(单位: 年)。 比如年收益率是12%，那么 72 / 12 = 6，现在的钱6年后就能翻一番 用72除以当时的通胀率，得出的数字就是你的钱贬值一半所需要的时长(单位: 年)。 比如通胀率3%，那么72 / 3 = 24，即24年后，那时的钱只有现在钱一半的购买力。 72法则: 应该叫72小时法则 想要做的事必须在72小时内付诸实践，否则这件事可能永远也不会去做了。(CAN’T AGREE MORE!!!) 要勇敢，自信，要敢于尝试，正确看待逆境，善于利用自己的长处，如果能在小孩子很小的时候就把这些观念传递给他/她，这应该会对小孩子产生巨大的正面影响。]]></content>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《IT简史》速读]]></title>
    <url>%2F2017%2F03%2F15%2F%E3%80%8AIT%E7%AE%80%E5%8F%B2%E3%80%8B%E9%80%9F%E8%AF%BB.html</url>
    <content type="text"><![CDATA[凑单买了一本叫《IT简史》的书，一下午的时间翻了一遍，书本身没什么亮点，非常浅，也没有编著者的个人观战，感觉就是一本简版的Wiki百科的集合，不过翻一下也还好，有些事件和概念还是以前不知道了，就当补充计算机历史知识了。 腓尼基字母，这些一千多年前的象形文字居然还在Unicode里，U+10900 - U+1091F段内，图片摘自Wiki百科: 最早的纸带打孔的计算机雏形居然是来自于一个叫雅卡尔的织布机上，这个台织布机使用纸带打孔来控制纺织的不同样式。 一直以为答题卡(2B铅笔涂黑块的那种答题卡)的读卡机是一种高科技，原来最早的读卡机1931年就研制出来了。 蜂窝网络(Cellular network)，叫蜂窝是因为最初设计信号塔的六边形布置的构想，因为六边形布置会使相同覆盖面积下这样的布置需要的信号塔数量最少，而六边形又像蜂窝的形状。 第一款编译器叫A-0，将数学符号转换为机器指令。 IBM的大型机系统System/360，投入6万名员工，51亿美元，其项目经理根据这个项目的经验总结写了出软件工程的神书《人月神话》，到现在还是畅销书。 RPG除了角色扮演游戏的意思之外，还是IBM研发一款报表生成器(Report Program Generator)。当然还是一种武器: 肩扛火箭榴弹。 结构化编程概念由Dijkstra提出，写了一篇名为《Go To Statement Considered Harmful》的论文，提出goto语句使程序流程混乱，并提出了结构化编程的概念，同时他也是Dijkstra最短路径算法和银行家算法(操作系统资源分配解决方案)的作者。 RFC(Request For Comment)请求评议，互联网标准一系列编号排定的文件都使用这个命令，比如RFC1738就是URL编码标准的文件。 1992年美国计算机协会还发布了一个叫IT与职业道德的东西，提倡了一堆类似不允许使用计算机做损害他人的事之类的东西。 现在准备看一下《格列佛游记》这本书，一来是大小端这个叫法来自格列佛游记，雅虎公司这个名字(Yahoo!)这个名字也来自于格列佛游记。 蓝牙这个词居然是来自于布鲁图斯国王名字首字母的北欧古字母的表示，使用他的名字是因为这个国王把分裂的挪威，丹麦，瑞典统一起来，爱立信，诺基亚，IBM几家公司联合推出这个无线通讯技术取名为这个国王的名字应该就是取其统一的意义，可能就是表示通过无线通讯技术把各个平台都统一连结起来的意思吧。 千年虫，以为是人为制造的一种病毒，原来就是全世界的计算机系统在2000年前对年的表示都使用后二位，2000前一直没什么问题，但是到2000年，00这种表示就出现了问题，可能是1900，也可能是2000，这样计算机对时间表示出错，就造成了各种问题。 Web 2.0相对于Web 1.0，Web 2.0是一个概念，指的是用户为根本，用户做为内容的生产者和传播者。而Web 1.0 指用户只是内容的消费者。Web 2.0就是一个概念，互联网用户角色转变的的过程。 蓝光光盘，叫蓝光的原因是这种光盘是使用405纳米长的激光对光盘进行读写。Blu-ray商标不叫Blue-ray，是因为注册商标时Blue ray是一个常用词而不允许注册，所以去掉了Blue中的e。]]></content>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五读《Expert C Programming》]]></title>
    <url>%2F2017%2F03%2F05%2F%E4%BA%94%E8%AF%BB%E3%80%8AExpert-C-Programming%E3%80%8B.html</url>
    <content type="text"><![CDATA[闲着没事儿在书架上找书看，又看到了翻得有些旧的《C专家编程》拿起来又翻了一遍，大二买的书，前后看了四遍，这是第五遍，每次看看都能有一点儿新的收获，。 #pragma是来源来Ada语言的一个编译器指示符，#pragma是由编译器来指定的具体效果，书上记录了一个很意思的关于GNU C 1.3.4版本编译器#pragma指示符的效果: GNU C 1.3.4编译器在遇到#pragma指示符的时候，首先会尝试运行”hack”游戏，如果失败，会再尝试运行”Rogue”游戏，如果还失败，就继续尝试打开Emacs编辑器并运行”汉诺塔”游戏，最后再失败，编译器才报错。 「Rogue」: Unix上的迷宫探索游戏，具体可参见此Wiki 「Hack」: 地牢探索游戏，具体参见Wiki 几个经常用的#pragma 编译时打印消息 #pragma message(&quot;compile message&quot;) 屏蔽特定编译警告 12#pragma GCC diagnostic push#pragma GCC diagnostic ignored "具体的警告字符串" 微软系的msvc使用方法和GCC的不同 12#pragma warning( push ) #pragma warning( disable: 具体的警告代码数字 ) // 可以写多个警告的代码 设置内存对齐 #pragma pack(内存对齐值) 1#pragma pack(push 4) // 设置4个字节内存对齐 gcc的pragma文档可以在这里找到。 NUL与NULL平时用习惯了，真正说一下二个的区别可能并不能说得特别清楚。 NUL表示ASCII码结束的字符，即是&#39;\0&#39;的字符名字，就是空字符的意思，但是不要误认为这是C的的一个宏定义，这样写是不正确的: 123456789#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; char str[8] = "Hello"; str[5] = NUL; // 并没有预定义的一个叫NUL的宏 printf("%s\n", str); return(0);&#125; NULL表示0，内存的0位置(内存地址较低的位置都是操作系统预留的)，表示空指针，即指针没有指向任何内容，指针初始化为空的时候都使用NULL赋值。 setjmp longjmpC语言中比goto更强大的改变控制流的机制，平常很少用，经常忘记用法。 setjmp(jmp_buf j)是一个宏，调用处就是标记当前的调用环境的上下文，保存当前的调用堆栈，用来调用longjmp的时候将控制流返回到这里再次执行，第一次调用setjmp时一定返回0。 longjmp(jmp_buf j, int return_value)这里的j就是setjmp时设置jmp_buf(保证jmp_buf不变)，return_value就是指定控制流返回setjmp时，setjmp再调用一遍时返回的值。 这个强大控制流转移机制，可以实现C语言的异常处理，看个简单的例子: 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;setjmp.h&gt;static jmp_buf context;void memory_handler(void *mem_pointer)&#123; if (!mem_pointer) &#123; longjmp(context, 1); &#125; // other logic ...&#125;int main(int argc, char *argv[])&#123; void *pointer = NULL; int rval = setjmp(context); if (rval) &#123; printf("return value %d\n", rval); switch (rval) &#123; case 1: printf("nullpointerexception check memory alloc\n"); break; // ... other handler &#125; &#125; else &#123; memory_handler(pointer); &#125; return 0;&#125; memory_handler发现pointer是空指针之后重新将控制流程移回setjmp带着新的返回值1，然后就进入第一个分支对应的处理语句，最终输出nullpointerexception check memory alloc。 goto语句只能在同一个函数中跳转到一个指定标签处的代码，而longjmp可以跨越函数跳转，是C中一个强大的机制。 使用setjmp时需要注意一点，如果setjmp不在main函数中调用而是在其他自定义函数中调用，那一旦这个自定义调用的函数返回，对应记录的调用上下文环境的jmp_buf也就失效了，longjmp再调用时，就回不到jmp_buf记录的控制流处了，像下面这个例子，代码不会有任何输出: 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;setjmp.h&gt;static jmp_buf context;void longjmp_exp()&#123; longjmp(context, 2);&#125;int setjmp_within_func()&#123; return setjmp(context);&#125;int main(int argc, char *argv[])&#123; int rval = setjmp_within_func(); if (rval) &#123; printf("return value %d\n", rval); &#125; else &#123; longjmp_exp(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于URL编码]]></title>
    <url>%2F2017%2F02%2F10%2F%E5%85%B3%E4%BA%8EURL%E7%BC%96%E7%A0%81.html</url>
    <content type="text"><![CDATA[在写上一篇博客之前，我一直对URL编码没什么概念，看到网页链接上一串百分号加数字的字符串时会短暂的想想，因为工作中也不涉及到具体的URL编码的部分，一直也没深入过，而促使我写下来记录就是上一篇博客中markdown解析的时候出了一点小问题(markdown链接是放在小括号里面的，然后放在小括号的链接本身也包含小括号，这时markdown解析出了问题)，然后查问题的时候就查到了URL编码的相关知识，这几天又查阅了资料，简要写在这里，深化一下记忆。 什么是URL编码什么是URL？URL是Uniform Resource Locator(统一资源定位符)的缩写，就是平常说的网页地址，像www.google.com就是个URL。而URL编码就是把URL里面的字符按照一定的规则标准进行编码，产生一个国际范围内通用的字符串(ASCII码串)，这里是Wiki上URL编码的解释，可以看到Wiki上的关键词是percent-encoding，因为URL编码针对每个字符的编码都使用%做前缀转义字符。 为什么需要URL编码URL就是统一为网络上资源命名，万维网遍及世界，所以URL需要具有通用性(世界范围内通用，跨语言，跨地区时区)，具有通用性的同时还要有完整性，不能因为URL中带了一些特殊字符就导致URL在传输过程中丢失了信息(比如URL中带有某个特定国家的文字)，否则就失去了URL的意义，定位不到资源，因此RFC1738网络标准对URL做了硬性的规定(可以在上面的链接里看到具体RFC1738对URL的规定)，除了一些ascii字符和特殊的保留字符可以直接用于URL，其他的字符都需要经过编码才可以用于表示URL，这样经过标准规则对URL进行编码，所有的特殊字符都可以用标准中规则的字符进行编码，世界范围内使用相同的规则，编码解码达成一致，通用性和完整性都得到了保证。 URL编码的规则标准当前的URL编码标准是对所有URL标准内的保留字符不进行百分号的编码，其他的一律先转换成UTF-8的字节(每个单独的字节转换为十六进制位再在前面都加百分号)表示，再在其前面加上百分号(%)。下面用简单的例子来演示一下URL编码标准的过程。 简单例子因何而起，便以何结束，既然是上次写的博客，就以上次博客地址为例(只取一个汉字做为例子，不按个分析演示了)，地址是https://bugcode.net/2017/02/05/闭包等于匿名函数吗，这里只取闭这个字，来演示URL编码的过程： 汉字不是RFC1738标准中规则的保留字，所以要取闭字的UTF-8编码，其对应的十六进制Unicode码是95ED。 再将对应的Unicode码转换为对应的UTF-8字节，转换需要UTF-8转换表，通过转换表，获取当前95ED对应的UTF-8字节序列，下面是一张UTF-8转换表: unicode UTF-8 0000 - 007F 0####### 0080 - 07FF 11##### 10###### 0800 - FFFF 1110#### 10###### 10###### 10000 - 1FFFFF 11110#### 10###### 10###### 10###### 上面表格中左侧是Unicode码对应范围，右侧是UTF-8对应字节序列表示，#代表对应Unicode码对应的二进制位，依次填入，后面不够的补0，具体可以查阅UTF-8编码规则相关资料，95ED对应范围在0800 - FFFF范围内，即闭字需要三个字节表示。HEX(95ED) = BIN(10010101 11101101)，对应转换表，可得到对应的UTF-8字节序列分别是(把95ED二进制位分别按位填入1110#### 10###### 10######的#位置中) 第一个字节需要填入4位，即: 1110 1001 第二个字节填入6位，即: 10 010111 第三个字节填入6位，即: 10 101101 三个字节对应的二进制位，再转换为十六进制分别是: BIN(1110 1001) = HEX(E9) BIN(10 010111) = HEX(97) BIN(10101101) = HEX(AD) 根据规则，标准之内的保留字不需要填加%前缀转义进行编码，最后上面的链接https://bugcode.net/2017/02/05/闭(只取一个汉字做例子演示，其余同理)经过URL编码之后就是https://bugcode.net/2017/02/05/%E9%97%AD 最后用JS的encodeURI函数来验证一下结果: 123456789&lt;html&gt;&lt;body&gt; &lt;script type="text/javascript"&gt;document.write(encodeURI("https://bugcode.net/2017/02/05/闭")+ "&lt;br /&gt;")&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码输出: https://bugcode.net/2017/02/05/%E9%97%AD]]></content>
      <tags>
        <tag>Theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包 == 匿名函数?]]></title>
    <url>%2F2017%2F02%2F05%2F%E9%97%AD%E5%8C%85%E7%AD%89%E4%BA%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%90%97.html</url>
    <content type="text"><![CDATA[和同事讨论Java 8的lambda表达式，然后就说起了闭包，然后发现在不在少数的人对闭包的理解就是闭包就是个匿名函数，甚至就认为这二个是互通的。 匿名函数就是闭包，闭包就是匿名函数。 结果自然就是一通争论，争论过程中，突然发现有些概念给对方解释的时候也不是能说得特别清楚，这里再对闭包这个概念整理深化一下。 闭包概念详细的概念可以看下wiki，这里引用一下wiki上对闭包的解释： 在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 这个解释，重点在于这句被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外，仔细看一下这句话，问题又来了，自由变量是什么? 自由变量Google查自由变量会出现另一个对应的词约束变量，具体解释在这个链接，约束变量字面解释自然是受约束的变量，其实也就是某个作用域内有效的变量，其有效范围受到约束，针对非函数式语言来说，就是函数内部的局部变量，函数的参数，这都属于约束变量，而非函数式语言中的全局变量，可以对应为自由变量，即不受某个特定的作用域限制。而对于函数式语言，可以在函数内定义函数，例如在F函数中定义了I函数，I函数内的变量是约束变量，但是在F函数内定义的变量v对于I函数来说，就是自由变量，因为v变量不受I函数的作用域限制，通常叫这个v变量为upvalue，而闭包中upvalue才是最重要的。 再看闭包解释这时再回头看闭包的解释被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外，闭包的核心概念是需要引用自由变量的函数，即自由变量与引用它的函数共同树成闭包，并且在产生调用的时候，自由变量与对应的函数共同组成的上下文不会因为函数的外层函数(产生闭包的函数，上面例子中的F函数)的返回而销毁，这样才是一个完整的闭包概念。 示例下面用Lua来解释上面所说的这些概念，现成的例子就是Lua官方教程中的newCounter的例子: 123456789101112131415161718192021222324function newCounter() -- 局部变量i，newCounter函数内有效 local i = 0 -- 返回一个匿名函数 return function() -- 引用了一个上层函数作用域中的变量 -- 这里i就是upvalue i = i + 1 return i endendcounter1 = newCounter()counter2 = newCounter()-- 这里输出二个不同的地址，即返回了不同的函数print(counter1, counter2)-- 输出 1 2 3print(counter1())print(counter1())print(counter1())-- 输出1 2print(counter2())print(counter2()) counter1与counter2分别是newCounter返回来的函数，二个互不相干，这点可以理解，而counter1连结调用三次，i的值保持递增，并没有因为newCounter函数返回而在匿名函数中销毁，而是和匿名函数一起组成的环境在内存中保留了下来，正好与前文中闭包的概念相对应，被引用的自由变量和引用它的函数共同构成了一个上下文一起存在，并且也不会因为离开了创造了它的环境(此例中是newCounter函数)而销毁。counter2与counter1输出不同的是因为counter1与counter2分属于不同的闭包(二次调用newCounter产生了二个闭包)，所以二个函数对应的内存也是不同(上面print(counter1, counter2已经说明问题))。 小结也就是说，闭包的生成一定伴随着对自由变量的引用，即upvalue引用。而没有upvalue的一定不是闭包，并且闭包和匿名函数没有必然联系，好多人有这种感觉，只是因为闭包好多的表现形式是匿名函数，类似上面的例子，newCounter内部的就是一个匿名函数，但是上面的例子完全可以这么来写： 123456789function newCounter() local i = 0 function counter() i = i + 1 return i end return counterend-- ... 这样返回的counter一样是闭包，但是却不是匿名函数(没有名字的函数)。]]></content>
      <tags>
        <tag>Theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些童年通关几十遍的游戏们]]></title>
    <url>%2F2017%2F01%2F30%2F%E9%82%A3%E4%BA%9B%E7%AB%A5%E5%B9%B4%E9%80%9A%E5%85%B3%E5%87%A0%E5%8D%81%E9%81%8D%E7%9A%84%E6%B8%B8%E6%88%8F%E4%BB%AC.html</url>
    <content type="text"><![CDATA[岁数越来越大，回老家过年也感觉越来越没意思，今天闲得没事儿，在旧柜子里面翻腾，找到了这二个东西 – 当年超级奢侈带电池可以保存进度的FC游戏卡带: 这个是《吞食天地III》,没记错的话应该是类似《火焰纹章》战棋类的游戏，扮演不同阵营的人使用不同的技能，比如黄忠就是射箭，能打三格，刘备用剑，能打一格，类似这种 这个叫《夺宝小英豪》，具体内容已经完全没有印象了，估计是这个游戏一点也不好玩儿🤪 说起这些，当真是回忆无限，那个时候买了好多这种卡带，普通的卡带像《超级玛利》只有十块钱(荒野乡村，那个时候想买正版也买不到)，而这种带纽扣电池的带子就要三十多块，当时要攒好久好久才能买，还得偷偷的买，不然就是一顿「男女混双」。 至今还难忘的有四个这样的RPG游戏带子，有二个都是耗了好久全通关，有一个借的带子快速的通了，另外一个永远也通不了关… 第一个是斥巨资(四十多元，现在想想也的确值)买的叫《重装机兵》的废土题材的RPG，前后通关了差不多几十遍，当时游戏的每一个细节都能记住，甚至现在想一下里面红狼之死的情节，还有些感触。玩了这么多游戏，现在还会时不时回想一下《重装机兵》(英文Metal Max，重装机兵粉丝叫MM粉)一代的情节，现在也还会关注一些MM相关的信息，包括有人搞的重装机兵的个人资料站 ，类似知乎这种讨论，还能看得津津有味，可惜在柜子里翻了半天，也没有找到原来的卡带… 第二个是看到卡带店老板玩儿的《吞食天地-孔明传》，当时看的时候感觉战斗系统真好用，地图又大，还能各种换武将，各种武器，当时就没忍住就买下来了，之后和小伙伴玩儿的不亦乐乎，过五半斩六将，三顾茅庐，火烧博望坡，收服姜维，想想那时的心情，现在都有点儿小激动。战斗画面大概是这个样子的: 因为控制里面有个叫总攻的菜单，按了就直接回合制自动开打，一般不遇到boss级的怪，几乎不咋用按手柄，这个应该是玩儿的比较轻松的游戏。 第三个是与同道小伙伴借的《封神榜》，因为是借的，所以玩儿的也特别仔细，现在还记得在姜子牙没学会抽魂术之前，遇见小怪都得逃跑，仍然记得过十殿阎王剧情时候的战战兢兢，会了抽魂术之后整个游戏的难度降了N个等级，后面几乎就是平趟过剧情。 第四个卡带，也是印象最深的，没记错的话应该叫《三侠五义》，讲展昭和白玉堂的，这个游戏没有那么好玩儿，印象深纯属就是这个游戏有bug(当年认为是bug，现在看就是开发人员个偷懒)，展昭是主角只能升到23级，血量最大只到999，然而在中期的时候就遇上了死对头白玉堂，999的血无论怎么打都打不过，倔强的我在整整一个月放学就磕白玉堂剧情中度过，最后无奈放弃，网上找了一个这个倒霉催的游戏截图: 没错！就是右下角那个体最多就到999，现在想想，那个程序员是用了一个什么类型来存的血量。 写到这的时候就会想，小时候玩儿了这么多游戏，而现在做为一个开发游戏的苦逼程序员，这一切是不是安排好的😂。岁数大了爱回忆，找不到当年玩儿过的最爱的卡带，今晚注定要不眠了~]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git小记(基础命令)]]></title>
    <url>%2F2016%2F10%2F22%2FGit%E5%B0%8F%E8%AE%B0.html</url>
    <content type="text"><![CDATA[之前用Git都是直接使用SourceTree这个开源的Git图形界面的客户端，输入log，提交，从远程pull更新，都是点几下按钮，从来没有在命令行里面操作过Git，开始bugcodeCalendar这个项目之后，开始尝试完全用命令行进行Git的操作，四月份开始的这个小项目，一直到现在，断断续续的业余时间也有几个月了，现在命令行里操作Git算是『行动自如』了，这里对这几个月的使用总结一下，也算备忘吧。 创建仓库，添加文件，提交12345git init # 把当前目录当做Git仓库git add filename1,filename2 # 可以多个文件名，也可以使用通配符号git commit -m "提交注释" # 将已add的文件都提交到仓库# 还可以像下面这样直接add并提交，commit的时候加入-a参数git commit -am "提交注释" # 会把当前没有add的文件先add再提交 查看工作区状态1git status # 会显示当前工作区中的哪些修改，增加，删除，显示未被版本管理的文件 Log，回退，HEAD12git log 各种参数 # log后面参数可以自定义，可以参照文档定制自己需要的git reset --hard 提交的id # 重置文件内容到某个提交 工作区，暂存区概念下图展示了工作区，暂存区，仓库的关系，以及何种操作对应文件在什么区 回退修改12git checkout -- 文件名 # 根据上面的图可知，是从暂存区恢复至工作区git resetHEAD 文件名 # 从仓库中恢复到暂存区 删除文件12git rm 文件名rm 文件名 &amp;&amp; git commit 分支123456git branch # 查看所有分支git branch 分支名字 # 创建分支git checkout 分支名字 # 切换分支git checkout -b 分支名字 # 创建同时切换到对应的分支git merge 分支名字 # 合并一个分支到当前所在分支git branch -d 分支名字 # 删除一个指定的分支 暂存，恢复12git stash # 将当前工作区改动暂存起来，把工作区变为clean状态git stash apply # 将暂存的改恢复到工作区 标签12345678git tag # 查看所有标签git tag 标签名字 # 创建一个标签，默认HAEDgit tag -a 标签名字 -m "标签信息" # 指定标签信息git tag -s 标签名字 -m "标签信息" # 给标签签名git push origin 标签名字 # 向远程仓库推送一个标签git push origin --tags # 把所有没推送的标签都推送到远程仓库git tag -d 标签名字 # 删除一个本地标签git push origin :refs/tags/标签名字 # 删除远程标签 diff12345git diff # 比较当前工作区与暂存区的不同git diff --cached # 比较的是暂存区与仓库最新提交的版本的不同git diff HEAD/提交id # 比较当前工作区+暂存区与仓库某个版本的不同git diff 提交id..提交id # 比较二次提交之间的不同，提交id如果省略，默认是HEADgit diff master..branch # 比较二个分支的不同 git diff还有更多选项更多可定制的比较，具体可参照diff help。 小技巧经常有这种需要，开了一个feature分支，添加了二个功能，结果一个功能写完了，另一个写到一半，要把这个已经写完的一个功能合并到主干上去，但是又不能像这样git merge feature直接合并分支，因为另一个功能只进行到一半。目的很明确只想把feature分支上的某几个文件合并到master上，可以这样： 12git checkout master # 切到主干git checkout feature aFile,bFile,cFile # 将对应文件直接checkout到当前分支 如是abc文件是新增的，这样没什么问题，如果cFile在master也有，并且做了修改，那这样就会把master上对应修改给覆盖掉，继续，从master创建一个临时分支，再把feature对应文件checkout到临时分支上去，再把临时分支合并回master，这样就达到了合并某分支的某几个文件到某分支的目的了。 123456git checkout mastergit checkout -b masterhelpergit checkout feature aFile,bFile,cFilegit checkout mastergit merge masterhelpergit branch -d masterhelper]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个用到不多却很有用的C语言特性和小Tricky]]></title>
    <url>%2F2016%2F09%2F17%2F%E4%B8%80%E4%BA%9B%E7%94%A8%E5%88%B0%E4%B8%8D%E5%A4%9A%E5%8D%B4%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84C%E8%AF%AD%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7.html</url>
    <content type="text"><![CDATA[几个C语言的特性和tricky，平时不常用到，却很有用，这里记录一下。 数组传参时的static修饰，编译期检查数据长度，类似void test_static(char param[static 5])，意思就是传入的param的char类型数组参数至少要有五个元素。 123456789101112// char param[static 1]检测NULLvoid test_static(char param[static 5]) &#123; // code here&#125;int main()&#123; char x[3] = &#123;1, 2&#125;; test_static(x); return 0;&#125; 上述写法就会出现如下警告: warning: array argument is too small; contains 3 elements, callee requires at least 5 [-Warray-bounds] 可参考这里。 动态指定printf输出数据的长度。可以用这种方式指定浮点数小数部分的保留位数。 123456789int main(int argc, char *argv[])&#123; int pre = 3; float num = 1.2432; char *str = "test statements"; printf("num = %.*f\n", pre, num); // 输出 1.234 printf("str = %.*s\n", pre, str); // 输出 tes return 0;&#125; printf还有一个格式参数%n，这个参数不输出任何内容，但是会把%n所在位置之前的字符计数都放入一个整型数值中。 12345678910int main(int argc, char *argv[])&#123; int pre = 4; int out_num = 0; char *str = "test statements"; // 回车之前的字符计数都会放在out_num中 int ret = printf("str = %.*s%n\n", pre, str, &amp;out_num); printf("out_num=%d, ret = %d\n", out_num, ret); return 0;&#125; 输出: str = testout_num=10, ret = 11 c11添加了_Static_assert静态断言，在c11之前可以自行定义一个『静态断言』，即条件为假制造编译错误。(from stackoverflow) 12345678910#define STATIC_ASSERT(COND,MSG) typedef char static_assertion_##MSG[(!!(COND))*2-1]#define COMPILE_TIME_ASSERT3(X,L) STATIC_ASSERT(X,static_assertion_at_line_##L)#define COMPILE_TIME_ASSERT2(X,L) COMPILE_TIME_ASSERT3(X,L)#define COMPILE_TIME_ASSERT(X) COMPILE_TIME_ASSERT2(X,__LINE__)int main()&#123; COMPILE_TIME_ASSERT(sizeof(int)==5); &#125; 编译提示如下: error: ‘static_assertion_static_assertion_at_line_11’ declared as an array with a negative size COMPILE_TIME_ASSERT(sizeof(int) == 3); 编译器的尝试性定义，代码: 12345678int i;int i = 10; // 或者int i;int main(int argc, char *argv[])&#123; printf("%d\n", i); return 0;&#125; 这段代码不会报错，C标准是这样来解释的，因为声明是出现在文件域的，不是出现在某个函数域内，把其当做外部定义，同时编译器还根据定义是否有初始值来区分，带初值的就叫做定义，没有初始值的也没extern关键的字就是尝试性的定义，如果文件中同时出现了这二种(也就是一个是定义，一个是尝试性定义，像上文代码)，这样那个没有带初始值的就直接当做冗余定义来处理了，不会当做redefinition，如果二个都是没带初值的，也没带extern关键字的，编译器就会把这二个尝试性定义合并成为一个初始值为0的非尝试性定义。现在上面的代码会输出10，如果把int i = 10改为int i;，代码会输出0。 不能在一个返回类型为void的函数中写return void，但是可以返回执行一个返回void的函数。 123456789101112131415void foo(int x)&#123;&#125;void bar()&#123; return foo(10);&#125;int main(int argc, char *argv[])&#123; bar(); return 0;&#125; 网上很多例子说三元运算符可以这样用: 12345678910#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; int x = 10; int y = 0; (y &lt; 0 ? x : y) = 20; printf("%d %d\n", x, y); return 0;&#125; 也就是说三元运算符会产生一个左值，c语言里面是不可以的，这样编译: gcc -Wall -std=c99 test.c -o test 会报编译错误，提示你表达式不能被赋值(error: expression is not assignable)。 但是在c++里的确可以。也就是上面这段代码用g++编译(会有警告)或者直接写一段c++的代码: 12345678910#include &lt;cstdio&gt;int main(int argc, char *argv[])&#123; int x = 10; int y = 0; (y &lt; 0 ? x : y) = 20; printf("%d %d\n", x, y); return 0;&#125; g++ -Wall test.cpp -o test ./test 会输出10 20。]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode-8使用XVim的问题]]></title>
    <url>%2F2016%2F09%2F10%2FXcode-8%E4%BD%BF%E7%94%A8XVim%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[做为一个Vim党，几乎是有Vim插件的IDE都会安装上，然后各种跳转爽得飞起，Xcode上就是成名已久的了XVim，它还有一个官方网站，但是一般的下载安装，直接去github就行了。最近使用最新Xcode安装XVim插件遇到了几个问题，发现在XVim的github上已经有老外提了issue，并且有了解决方式，总结记录一下。 问题因为用到了Swift 3，所以早早就把Xcode升到了Xcode8 beta版本，像之前Apple官方出的Swift迁移指南说得一样，由Xcode7.3生成的Xcode工程，由Xcode8打开的时候会弹出一个迁移助手，然后把之前工程里不符合Swift3的代码做相应的改动。当然，也有工具不能识别和修改的，遇到得最多的就是for循环(使用原Swift2中enumerate方法)相关的，具体可以看官方的迁移指南，里面有具体指出哪些需要手动修改。 跑题了…，使用Xcode8安装XVim的时候，直接clone XVim工程再make安装，之后Xcode无法启动，直接就崩溃了(错误提示是 code signature invalid类似的信息)。。 解决标准的安装方式与XVim工程里面的Readme一致。最可能遇到的问题就是，在github上它的安装说明上，使用xcode-select -p命令查看当前是用的哪个版本的Xcode，如果之前同时使用Xcode7.3与Xcode8 beta，并把Xcode7.3卸载，此时输出的那个目录不是对应的Contents/Developer目录(是一个其他的的目录)，这里需要使用xcode-select -s &lt;路径&gt;命令指定一下/Applications/Xcode-beta.app/Contents/Developer目录。下面只说解决安装XVim导致XCode崩溃的问题。 把大象装冰箱分几步: 把现在出现崩溃的Xcode移除，然后重新解压出一份新的Xcode.app放在应用程序目录 查看自己的IdentifyID，终端里运行如下命令: security find-identity -p codesigning 终端会打印出两段信息，把其中看起来像是MD5码的字符串保存。 进入到XVim的解压目录中，如果之前make过，先make clean一下，然后执行make，会询问你是否移除Xcode的signature(会停下来让你选择y还是N)，这里选N(不移除)，然后XVim工程make完成。 这时候如果你打开Xcode，XVim插件是没有启用的。需要另外一步，打开终端，定位到/Applications目录，执行下面的命令: codesign -f -s &lt;刚才保存的那串IdentifyID&gt; Xcode.app 需要点时间，应该是几分钟左右，完成之后再打开Xcode，会提示你有一个未知的XVim.plugin的bundle没有加载，选中Load Bundle，然后XVim就可以用了。 Enjoy it！ End]]></content>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CR/LF小坑]]></title>
    <url>%2F2016%2F09%2F04%2FCR-LF%E5%B0%8F%E5%9D%91.html</url>
    <content type="text"><![CDATA[CR、LF、CR/LF不同系统对“换行”的表示，详情可以看这里。 LF(Line Feed): 换行，ascii码是10，对应字符’\n’，*Nix系使用此字符做为换行的标志(包括OSX及其之后的版本)。 CR(Carriage Return): 回车，ascii码是13，对应字符是’\r’，部分系统，类似Apple II那个经典的系统(wiki上有具体的解释)。 现在某度或者google出来的部分权重略大的搜索结果还是说CR是macOS的换行符(可能是一个抄一个，也可能写下的时间较早)，注意看上面wiki百科给出的解释，CR部分的是解释是: Commodore 8-bit machines, Acorn BBC, ZX Spectrum, TRS-80, Apple II family, Oberon), Mac OS up to version 9, MIT Lisp Machine and OS-9. 这里的确提到了macOS，但是注意后面的up to version 9，也就是Mac OS 9之前的系统版本的确是使用CR做为换行符，但是之后的系统版本都是与*Nix系保持一致，都使用LF做为换行符。 CR/LF，同时使用\n\r来表示换行，现在只有Windows系统(大部分问题都出在这里，这里不说网络协议中用CRLF做为分隔的情况)。 目前的情况就是大部分民众常用的系统几乎只有两种情况使用\n做为换行符，使用\n\r做为换行标识。 起因一个类似这样的场景，一堆android工程需要生成，各个工程都有自己的配置文件—不同工程的key或者id(或者其他各工程间独立且不同的配置)，这些都需要在工程生成的时候动态的把配置文件里面提前约定好的字符串替换为其对应的key或者id(类似%needReplaceIdentifier%这样的文本字符串)，对应的key或者id在相对固定的路径中存放，生成配置文件时候，把这个固定路径里面的字符串读取出来替换到对应的约定字符串中去。 这个看起来并没什么，其实如果在一个同一个系统中操作也真没什么，问题就出现在跨系统的操作上，有二个机器，一个Windows一个Mac，同时check了一份工程的代码(svn)，准备在Mac端生成对应的配置文件，但是某些情况下就直接在Windows端编辑对应的配置文件提交至svn(svn不会像git那样自动转换line ending)，之后在Mac直接update下对应的配置文件，开始生成，类似这样: 文件IDConfig.cfg内容: 1101 firstLine 1201 secondLine … 被替换的文件BeReplacedFile内容: … … “%needReplaceID%” … … “%needReplaceKey%”… … 之后没有转换过的Windows换行直接被读取出来，字符串切分，替换，完成之后就变成了非预期的样子，出现了一个非预期的换行，如果不用类似vim这种编辑器提前看一下(vim下直接会发现Windows编辑过的文件后面多了一个^M的字样，也就是\r)，不容易发现。 替换之后文件: … … “1101” … … “firstLine “… … 类似如下shell脚本: 1234567891011#!/bin/bashdeclare -i countcount=0cat ~/Desktop/test.txt | while read linedo tmp=$(echo $&#123;line&#125; | awk '&#123;print $2&#125;') count=$count+1 echo "needReplaceIdentifier$&#123;count&#125;" sed -i -e "s/needReplaceIdentifier$&#123;count&#125;/$&#123;tmp&#125;/" ~/Desktop/test.dstdone 执行上文shell处理之后就变成标准的macOS换行的格式，替换完成后这时候某些配置多了一个换行就已经开始报错了。 解决扯了这么多，其实是非常简单的一个问题，解决方式有N种: 双系统开发，只在对应的系统进行提交(和没说一样) 使用dos2unix进行转换，直接brew安装一个dos2unix，还支持指转换，还可以unix2dos。 dos2unix file_to_convert unix2dos file_to_convert 打开vim，你会看到这种文件有\r的地方都有一个^M标记，直接命令模式: :%s/\r//g 其他任何可用的替换命令/操作。 End]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空闲的八月]]></title>
    <url>%2F2016%2F09%2F03%2F%E7%A9%BA%E9%97%B2%E7%9A%84%E5%85%AB%E6%9C%88.html</url>
    <content type="text"><![CDATA[每个月都会写些流水帐，也不知道文字能力还能不能借此挽救一下。前几个月是没时间写，而现在是太闲了，惰性说来就来。迷糊着突然发现地铁上的人突然多了起来，恍然，九月都来了，学生都开学了，学生时代，恍惚间感觉离自己好久远一样。好吧，就迷糊着在九月记录一下八月吧~ 《我的朋友都死了》用了不到一个小时的时间浏览了一本漫画，名字叫《我的朋友都死了》，放在kindle里好久一直没看，介绍是这样的: 史上最萌最虐心的超人气时尚小绘本！击中你深藏于心的寂寞！画给所有感到孤独的年轻人！ 看这个介绍似乎无感，书商的套路而已，但是直到我看到下面这一段的时候，突然发现，可能不同人群的人看，都能在不同的小段里找到与自己所从事的行业、自己的性格、自己的家庭、自己所处的环境里面的各种孤独和寂寞。看完这段脑海中直接就对号入座了—程序员，不知道其他人看是什么感受，我的感受还是挺强烈的，相当一部分人还是圈子比较小(包括我自己)，不是讨论技术就是打打游戏，最多和基友撸个串闲聊下(聊一会儿就变成我的代码如何，那谁谁代码如何…)，虽然自己非常想脱离这种状态，但是仍然在这种陷于这种状态中循环往复，之后约妹子的时候(如果能约到)可能顺嘴就下去了—技术如何如何，甚至不知道要说什么。最后就剩下，工作-&gt;假期-&gt;睡觉(偶尔与基友小聚)-&gt;工作…. 《谍影重重5》8月23号大陆上映，那天是周二，上班没时间去看，熬到周六，迫不及待的买了二张英语2D的，为什么突出说一下英语2D，大陆版的最开始是只有英语3D(特供)，而以我看完2D的情况来看，网友不是瞎说的，太多的近镜头的大幅度晃动的确让人头晕(想象不到我这个有3D眩晕症的人看完3D版本的会以什么姿势走出电影院)，特别是开始不久后在希腊的街头的那部分，看2D的都有些晕乎，也怪不得网友们大骂了。很多影评说剧情不足，但是做为一个谍影重重前三部看了N遍的人来说，依然非常给力。整个过程都是揪着心看完的，只是男神马特达蒙也老了😔，也不知道还有没有《谍影重重6》，如果有，什么时候呢？ JBL小砖音响一直用三十块的地摊儿货，平时戴耳机比较多，一个款式很老的森海塞尔头戴式的，上大学时候买电脑送的，音质不错，一直保护得非常好。最近地摊儿货显示出疲态了，各种尖叫，再加上windows主机上各种线越来越多，而且天热戴耳机不舒服，狗东上溜了一圈儿最后果断下手JBL小砖，299大洋，自带重低音听着挺好的(也不会听什么音质，总之听着挺舒服)，喜欢棱角分明的外形，小砖是真小，长度比手机还短一大截，蓝牙mac秒连，windows稍微迟钝一些，也可能是个例，总体非常不错。 Summary关键词: 拖延与进步 拖延: macCalendar的进度略慢，《Advanced Linux Programming》第五章翻译没开始 进步: 重读《Pro Git》收获比之前大，连续打一个小时羽毛球不喘了 End]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bash-simple-quick-tutorial]]></title>
    <url>%2F2016%2F08%2F28%2FBash-simple-quick-tutorial.html</url>
    <content type="text"><![CDATA[Bash 简单入门Bash的简单入门，不介绍复杂的语法，只有基本的语法构成，看完可以写出简单的shell脚本，根据learnxinyminutes的入门画的脑图，不常写会经常忘记，画下来做为备忘，条理清晰些。 各语言的“马桶”入门在V站上看到有V友提到了这样儿一个网站，挺有意思的，真是坐在马桶上就能浏览完一门语言的最基本语法，然后马上入手，尤其是像bash这种入门门槛不是特别高的脚本语言， 快速过一遍就可以上手写简单的脚本了。]]></content>
      <tags>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Markdown画流程图]]></title>
    <url>%2F2016%2F08%2F25%2F%E4%BD%BF%E7%94%A8Markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE.html</url>
    <content type="text"><![CDATA[最新一版的Typora支持画流程图了，用的flowchart.js，直接可以用代码的形式来描述流程图，然后直接就会通过flowchart.js渲染出实时的流程图，之前对这些没了解过，记录在此。 先看官网的例子: ```flow st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;end st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op ``` 上面的代码就会产生如下图: 基本语法与写代码有相似的地方，先定义，再构造，可以在flowchat.js官网查看相关用法。 定义要画的流程图里用到的元素(条件、操作、分支、输入输出、开始、结束) 几个不同的元素类型分别用下面的关键字来表示 start 流程图的开始 end 流程图结束 inputouput 输入输出 subroutine 分支(子程序) operation 操作 condition 条件 ​ 基本的语法: labelName=&gt;elementType: labelContent:&gt;link labelName: 代码中当前流程图中每个元素实例的具体名字，类似于不同的变量表示流程图不同的部分 elementType: 元素类型，表示对应的那个变量是流程图的元素类型，类型冒号后有一个空格，切记 labelContent: 标签上显示的内容，就是每个框里面的文字，英文汉字都行 link: &gt;link是可选的，对应那个labelContent的链接 各元素都定义好之后，使用-&gt;来连接各个元素。 startLabel-&gt;endLabel 使用condition的时候，条件都会有二个分支，对应yes和no，所以连接条件元素的时候一般写二个 condLabel(yes)-&gt;outLabel-&gt;endLabel condLabel(no)-&gt;errorOp 使用subroutine的时候，有left和right二个子项，分别针对subroutine元素标签左右侧的起点位置 示例假设以在控制台输入一个数字，判定这个数字是否为素数，是打印“是素数”，不是打印“不是素数”为例，画对应的流程图 123456789101112131415startLabel=&gt;start: 开始endLabel=&gt;end: 结束opLabel=&gt;operation: 输入一个数字:condIsNumberLabel=&gt;condition: 是否是一个数字?condIsPrimeLabel=&gt;condition: 是否只能被1或者本身整除?:&gt;http://goo.gl/qCKg49outIsPrimeLabel=&gt;inputoutput: 是素数outIsNotPrimeLabel=&gt;inputoutput: 不是素数subroutineIsNotNumberLabel=&gt;subroutine: 错误处理startLabel-&gt;opLabel-&gt;condIsNumberLabelcondIsNumberLabel(yes)-&gt;condIsPrimeLabelcondIsNumberLabel(no)-&gt;subroutineIsNotNumberLabel(right)-&gt;opLabelcondIsPrimeLabel(yes)-&gt;outIsPrimeLabel-&gt;endLabelcondIsPrimeLabel(no)-&gt;outIsNotPrimeLabel-&gt;endLabel 结果如下图:]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift3已完成的变动提案列表]]></title>
    <url>%2F2016%2F07%2F24%2FSwift3%E5%B7%B2%E5%AE%8C%E6%88%90%E7%9A%84%E5%8F%98%E5%8A%A8%E6%8F%90%E6%A1%88%E5%88%97%E8%A1%A8.html</url>
    <content type="text"><![CDATA[Swift 3已经实现的变动提案，粗略翻译一下，自己顺便也了解记录，原文地址:https://apple.github.io/swift-evolution/ SE-0002 去掉函数柯里化的声明语法 SE-0003 去掉了函数参数中的var关键字 SE-0004 去掉了++和–操作符 SE-0005 Objective-C的API更符合Swift风格 SE-0006 Swift的标准库中应用了API指南 SE-0007 移除C语言形式的for循环语法 SE-0008 为可选序列增加了lazy flatMap SE-0016 增加由非安全指针和非安全可变指针转化为Int和UInt类型的构造器 SE-0017 改Unmanaged 为用 UnsafePointer SE-0019 Swift测试 SE-0023 API设计指南 SE-0028 更加新式的Debug标识符(如__FILE__) SE-0029 移除了函数传参过程中，隐式的元组自展开行为 SE-0031 调整了inout关键字对类型修饰的定义 SE-0032 为序列这种类型统一加了一个first(where:)方法 SE-0033 引入Objective-C常量做为Swift的类型 SE-0034 消除了Debug标识符中行控制语句的歧义 SE-0035 限制了inout对@noescape修饰的上下文的捕获 SE-0036 枚举实例成员的实现必须有前导点号 SE-0037 明晰了注释和操作符的界限(除号与乘号) SE-0039 更加新式的Playground字面量 SE-0040 在属性参数中使用冒号代替等号 SE-0043 可以在case标签里使用多种模式定义变量 SE-0044 现在可以把C的API做为Swift类型成员引入 SE-0046 为包括第一个函数参数的所有参数设定一致的标签行为 SE-0047 默认非空返回的函数给出没有使用结果的警告 SE-0048 可以使用泛型类型别名 SE-0052 改变了迭代类型post-nil保证 SE-0053 去掉了函数参数中显式使用let的用法 SE-0054 废除了ImplicitlyUnwrappedOptional 类型 SE-0055 显式使用可选值语法使非安全指针为null SE-0057 引用Objective-C轻量泛型 SE-0060 强制默认参数顺序 SE-0061 加入了对autoreleasepool()的错误处理和泛型结果 SE-0062 引入了Objective-C中的key-paths SE-0063 为Swift包管理加入系统模块搜索路径 SE-0064 引入了Objective-C的getter和setter属性的选择器 SE-0065 新的集合与索引的模型 SE-0066 标准化了函数参数类型需要小括号的语法 SE-0067 增强浮点数的协议 SE-0069 Mutability和Foundation值类型 SE-0070 Make Optional Requirements Objective-C-only SE-0071 允许大部分的保留字在成员里使用 SE-0072 完全消除转换成Swift类型的歧义 SE-0076 为UnsafeMutablePointer类型增加了一个重写的方法，作用接收一个UnsafePointer，将其转换为不析构的副本 SE-0085 可以从命令行调用Swift包管理器 SE-0086 在Swift的Foundation类型中移除了NS前缀 SE-0091 在协议中提高了对运算符的要求 SE-0093 专门为索引增加了一个公有的base属性 SE-0094 在标准库中加入sequence(first:next:)和sequence(state:next:)方法 SE-0095 使用P1 &amp; P2的语法代替原来的protocol&lt;P1,P2&gt;语法 SE-0106 在OSX平台配置测试加入了macOS别名 SE-0109 移除了Boolean协议 SE-0112 增加了NSError的转换 SE-0113 为浮点类型增加了整数舍入的功能 SE-0114 修改Buffer类型的”Value”的名字为”Header”的 SE-0115 重命名字面量语法的协议 SE-0118 修改了闭包的参数名称及参数标签 SE-0124 Int.init(ObjectIdentifier)和UInt.init(ObjectIdentifier)方法现在需要一个bitPattern:标签]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift3迁移指南-2]]></title>
    <url>%2F2016%2F07%2F21%2FSwift3%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97-2.html</url>
    <content type="text"><![CDATA[使用Carthage/CocoaPods工程如果你使用了第三方的二进制形式的Swift模块工程，这个工程并不是在你自己Xcode的工作空间中由你自己生成出来的，你可以选择下面的其中一种方法进行迁移。 在你的Xcode工作空间包含工程的源代码。 使用这种方法，你需要构建并迁移开源的工程到你自己的工程里面，使用Xcode7.3确保工程构建和链接都无误。包含开源工程中的文件到你自己的Xcode工作空间里，并设置好你正在构建的工程的依赖工程scheme。如果你在Carthage的build目录下设置了framework的Swift的二进制模块的搜索路径，去掉设置的搜索路径或者直接清掉Carthage的build目录，要确保你所使用的Swift模块一定是由你自己的Xcode工作空间构建出来的。 一直等到你所使用的开源工程也更新到了Swift2.3或者Swift3 可以按下面的步骤来迁移你的工程 把你的工程当做是在Xcode7.3下构建 使用迁移助手，且只应用迁移助手对你自己工程的源代码改动部分。 构建之前，修改Carthage/CocoaPods依赖文件，指定其为已经迁移到Swift2.3或者Swift3的工程分支版本 更新依赖，并尝试构建已经被迁移程序修改更新过源代码的工程。 已知的迁移问题Swift 标准库 迁移程序可能会对在SetIndex和DictionaryIndex使用索引方法的这种代码转换失败。 解决方法：手动迁移用在集合对象上的索引方法。大致如下: index.successor() 修改为 Collection.index(after: index) index.predecessor() 修改为 Collection.index(before: index) index.advancedBy(delta) 修改为Collection.index(index, offsetBy: delta) index.advancedBy(delta, limit: otherIndex) 修改为Collection.index(index, offsetBy: delta, limitedBy: otherIndex) index.distanceTo(otherIndex) 修改为Collection.distance(from: index, to: otherIndex) 在Swift2.2中Unmanaged类型有一个静态方法fromOpaque(_:)把COpaquePointer类型转换为Unmanaged类型和一个实例方法toOpaque()把未托管的引用类型转换为COpaquePointer类型 。在Swift3中这个变成了把UnsafePointer&lt;Void&gt;转换为UnsafeMutablePointer&lt;Void&gt;来匹配一个通用的传递给C的API的“上下文指针”，你可以简单的把用到COpaquePointer的移除即可(现在已重命名为OpaquePointer)。 如果你有任何的的自定义的集合类型，你可能会看到如下编译错误:“MyCollection’ does not conform to protocol ‘Collection”(MyCollection没有遵循Collection协议)。 现在是由集合类型负责其自身的索引的自增/自减，要让你自己的集合类型遵循Collection协议，实现func index(after: Index) -&gt; Index方法，对于BidirectionalCollection这个集合类型，还要实现func index(before: Index) -&gt; Index方法。 如果你有一个使用了半开区间操作符生成的Range类型的变量(如 1..&lt;2)并且把它做一个Sequence来用(比如，用在一个for-in循环里)，你会看到如下错误：“type ‘Range’ does not conform to protocol ‘Sequence”(Range类型没有遵循Sequence协议)。 修改方式就是把Range改为CountbaleRange。 用户可能需要手动修改 Sequence.generate() 为 Sequence.makeIterator(). 用户可能需要手动修改 anyGenerator 为 AnyIterator. 用户可能需要手动修改 Range.start 和Range.end 分别改为Range.lowerBound 和 Range.upperBound。 用户可能需要手动修改 Collection.Index.Distance 为Collection.IndexDistance (没有中间的点号) 访问Collection.enumerated()的枚举结果时，用户可能需要手动修改元组元素 index 为 offset 。 Printable 和DebugPrintable 现在已分别重命名为 CustomStringConvertible 和CustomDebugStringConvertible。 如果在迁移索引区间之后使用集合的indices属性的时候报“Range&lt;Index&gt;没有遵循Sequence协议”的错。像下面这样修改： for _ in str.startIndex.. –&gt; for _ in str.indices[str.startIndex..&lt;someIndex]{} Zip2Sequence(_:_:) 构造器已被移除; 使用 zip(_:_:)函数替代。 在Collection扩展中使用 min/max 会与Collection的本地方法冲突; 在 min/max 之前加swift就可以解决这个冲突。 在迁移程序会自动重命名代码中的类型名，新的类型名可能会与用户自定义的类型名冲突，解决这个问题需要你移除那些不必须的类型别名定义。 Selector() 会被转换为 nil。 Unmanaged.toOpaque() 会被转换为 OpaquePointer(bitPattern:) Range&lt;&gt;.reversed 已经被移除; 用户可以调用[].indices.reversed()模拟实现这个功能。 &lt;Index&gt; ..&lt; &lt;Sequence&gt;.endIndex 需要手动修改为&lt;Sequence&gt;.indices.suffix(from: )。 迁移程序不会重写Swift中不存在的类型的泛型约束。 比如： func foo() &lt;C: CollectionType where C.Index: BidirectionalIndexType&gt;{} 会被转换为 func foo()&lt;C: BidirectionalCollection&gt; {} 但其实应该转换为这样func foo()&lt;C: Collection where C.Index: BidirectionalIndex&gt; {}。 ​ SDK 新SDK的release版本一些协议增加了一些required的方法(遵循协议必须要实现的方法)，迁移程序现在不会在你的源代码里加入这些方法(required方法)实现。 解决办法就是手动在遵循这些协议的代码里添加required方法的实现。 在Swift3中很多Foundation中的“字符串类型”的API已经被改为使用结体的“包装类型”。比如新的Notification.name FileAttributeKey是另一个由“字符串类型”改为使用结构体的“包装类型”，当像这样的类型被用在字典(比如FileManager中的 attributesOfItem(atPath:)方法的返回结果)上的时候，字符值通常需要使用rawValue属性提取出来。 let mtime = try FileManager.default().attributesOfItem(atPath: &quot;/&quot;)[FileAttributeKey.size.rawValue] as? NSNumber 迁移程序会修改绝大部分用到NSURL的地方为URL，但是NSURL中的某些方法，像checkResourceIsReachableAndReturnError，没有使用Swift的错误处理机制，而是使用是外部参数来保存错误信息。而某些URL里类似的方法，如checkResourceIsReachable，如期的使用了Swift的错误处理机制。 Swift3的迁移程序依然迁移时保留了NSURL方法，如果你想使用新的API里的URL类型，需要手动修改自己的代码。通用的处理url不可达的错误方式是使用try?: let isReachable = (try? resourceURL.checkResourceIsReachable()) ?? false) 在NSURL中port属性是一个可选的NSNumber类型，同时对应在新的URL类型是一个可选的Int类型。Swift3的迁移程序迁移时保留了NSURL的属性，如果想使用新的URL类型需要手动修改代码为新的API。 迁移程序会把大部分的NSData转换为Data，某些NSData中的方法操作UnsafeMutablePointer&lt;Void&gt;，相对于Data里面的方法使用UnsafeMutablePointer&lt;UInt8&gt;(相对于Data.copyBytes(_:length:)方法，NSData.getBytes(_:length:) 方法更容易接受)。需要注意，Swift类型的内存布局是不能保证的。 迁移程序会依然保留使用NSData的方法;想用新API需要自己手动修改代码。 NSData(contentsOfMappedFile: x)可被修改为Data(contentsOf: x, options: .mappedAlways) NSData(data: x) 可以被修改为 x 在Swift3中除非有更好的方式来代替NSDate，否则迁移程序都会保留使用NSDate，如： (x as NSDate).earlierDate(y) 可以改为 x &lt; y ? x : y (x as NSDate).laterDate(y) 可以改为 x &lt; y ? y : x 迁移程序可能不能正确的处理NSEventSubtype 枚举。 迁移程序可能不能正确处理属性的setter方法，导致出现这种：setInstanceVariable = instanceVariable。 解决办法：修改setter为属性名字，如:self.instanceVariable = instanceVariable 在新SDK中会有switch语句中新增了一些case语句，但迁移程序不会在你的代码里做处理。 解决办法:手动加入新的switch语句中的case，并加入合适的可用性判定 错误:由CALayer?向下转换为CALayer只能可选解包;你是想使用’!’? 去掉as! CALayer，用!代替 错误:枚举值tv不存在于类型UIUserInterfaceIdiom中 改为TV 迁移程序可能会错误的处理像objc_ASSOCIATION_RETAIN这种小写的枚举值。 解决方法：把它们全部改为大写OBJC_ASSOCIATION_RETAIN 迁移程序会转换全局常量为名称空间枚举，但可能并不会赋一个合适的.rawValue值，传入一个接受一个枚举值的函数时使用新的枚举类型。 迁移程序不会转换NSNumber.unsignedLongValue 解决办法：手动改为.uintValue 迁移程序可能不会将XCUIElementQuery.elementBound(by:) 转换为XCUIElementQuery.element(boundBy:)。 一些类型现在已变成泛型(如：NSCache -&gt; Cache, NSMapTable -&gt;MapTable)，迁移到Swift3之后需要为它们加一个合适的泛型参数。 迁移程序可能不能正确的将 NSApplicationDelegate类的applicationShouldTerminateAfterLastWindowClosed(_:) 方法转换为applicationShouldTerminate(afterLastWindowClosed:), 这会引发一个警告： “Instance method ‘…’ nearly matches optional requirement ‘…’ of protocol NSApplicationDelegate”。 解决办法：将方法名改回applicationShouldTerminateAfterLastWindowClosed 如果你在一个子类遵循一个Objective-C协议，并实现了其可选的的方法，你会看到这样一个警告：“Instance method ‘…’ nearly matches optional requirement ‘…’ of protocol ‘…’” 解决方法：在实现的可选方法之前添加@objc(objectiveC:name:)属性。 使用字面量做为选项现在需要调用对应选项的构造器，如：NSWindowStyleMask(rawValue: 8345) 迁移程序不会修改类似这种有相同值类型的NSMutable*(如：NSMutableData -&gt; Data, NSMutableURLSession -&gt; URLSession)，但绝大部分SDK的函数现在接收新的值类型。 修改为与它们的值类型等同的，小心处理引用与值的转换。快速的解决办法是直接把它们转换为需要的类型(如 as Data)，但是这可能会造成额外的拷贝。 如果你定义过的一个泛型与现在某个Foundaiton类冲突。迁移程序可能会在这个类用于一个不同的目标的时候错误的移除掉泛型参数。 如果你定义的类与Foundation有冲突，首先重命名类以防止产生冲突，或者回退那些被去掉的泛型参数。 迁移到Swift3之后，你会看到类似这样的错误：“Extension of a generic Objective-C class cannot access the class’s generic parameters at runtime” 当尝试调用一个Objective-C中泛型类中含有泛型参数的方法时，可以通过调一个API产生去掉self属性的变量来解决这个问题。如：let typeErasedSelf = self as! MyObjCType&lt;AnyObject&gt; 如果代码中调用了self.init(...)，这时在迁移到Swift过程中就会错误的将self.init转换为self.dynamicType.init，这时会导致这样的错误：“return from initializer without initializing all stored properties”。 解决方法：去掉.dynamicType 迁移程序在转换类似这样的函数时Pasteboard.￼readObjects(forClasses:options:)，会强制重命名第一个参数，比如把NSURL.self改为URL.self，这样就会导致一个编译错误;解决这个问题就是去掉迁移程序做出的改动。 迁移程序在转换NSData(bytes:length:deallocator:)时，并不会修改析构器的类型。 解决办法：将(UnsafeMutablePointer&lt;Void&gt;, Int) -&gt; Void修改为(UnsafeMutablePointer&lt;Int8&gt;, Int) -&gt; Void 某些方法会标记为在watchOS中不可用，但是对于iOS仍然是必须的，如果出现了这样不能重写某些不可用的方法的错误，请使用#if os(iOS)块将对应的代码包起来。 用户可能需要手动将String(contentsOfURL:usedEncoding:)改为String(contentsOf:usedEncoding:)，现在这个方法在usedEncoding参数上用inout String.Encoding代替了UnsafeMutablePointer 有必要手动将NSBundle.url(orResource:withExtension:)修改为Bundle.urlForResource(_ :withExtension:subdirectory:inBundleWith:) 在迁移程序自动迁移之后一些值类型由NSURL变为URL，导致出现不可用成员的错误。解决这个问题，需要手动添加类型转换，用URL的例子，就像这样x as NSURL。 用户可能需要通过类型推断来手动简化选项设置。如：修改DispatchQueue.global(attributes: DispatchQueue.GlobalAttributes.qosDefault)为DispatchQueue.global(attributes: .qosDefault) 尾闭包可能由于名字变得更短而产生歧义，可以通过在闭包参数加参数标签来解决。 比如： 12let parameterTree: AUParameterTreeparameterObserverToken = parameterTree.tokenByAddingParameterObserver &#123;...&#125; 变为 1parameterObserverToken = parameterTree.token &#123;...&#125; 歧义是由于其他的tocken(:)方法，修改为加入参数标签 1parameterObserverToken = parameterTree.token(byAddingParameterObserver: &#123;...&#125;) Dispatch dispatch_once函数在Swift中不再可用。在Swift中你可以使用延迟初始化全局或者静态属性来达到由dispathc_once提供的确保只调用一次的功能。例如： 12let myGlobal = &#123; … global contains initialization in a call to a closure … &#125;() _ = myGlobal // using myGlobal will invoke the initialization code only the first time it is used. 迁移程序可能不能正确处理多个使用相同的token在不同的静态变量中调用dispatch_once的情况。 调用dispatch_after可能会导致被迁移转换为错误的参数标签：如果你看到这样的错误 “Argument labels ‘(when:, block:)’ do not match any available overloads” ，把block改为execute即可修复。 现在针对每个DispatchSource类型都有特定的协议。你需要修改dispatch_source_t 为其中一个特定的协议，比如DispatchSourceTimer, DispatchSourceProcess,等合适的。 Dispatch 队列API现在使用这个 DispatchAttributes OptionSet。如果你之前使用 dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_DEFAULT, 0))，现在你使用DispatchQueue(label: name, attributes: [.serial, .qosDefault])这里的选项设置。 迁移程序会错误的把dispatch_get_global_queue(_:_:) 转换为DispatchQueue.global(_:_:)来代替DispatchQueue.global(attributes:)。 解决方法：移除第二个参数，确保第一个参数是DispatchQueue.GlobalAttributes的枚举值。 dispatch_get_specific 不再带一个UnsafeMutablePointer参数，并且现在它不会加上必需的参数标签。 解决方法：替换UnsafeMutablePointer&lt;Void&gt;的key为DispatchSpecificKey&lt;T&gt;，同时加上缺少的key标签。 dispatch_block_t 不会自动转换为(Void) -&gt; Void。 dispatch_qos_class_t 不再是必需的;用户可以使用Swift的选项设置语法设置DispatchQueueAttributes 成员为自己想要的配置。 Swift 3语言细节 迁移程序不会转换rand()用法，这个函数现在不能用了。需要使用arc4random()。 解决方法：将所有的rand()用法都改成arc4random()和arc4random_uniform()，谨记arc4random()返回一个UInt32而不是Int32。 迁移程序不能完全转换接受ImplicitlyUnwrappedOptional类型参数的闭包。 解决方法：提升为使用标准可选类型。 迁移程序可能错误的在需要!的可选类型隐式解包的值的后面插入?，这允许空值静默传播代替确定性陷阱。 使用!来代替?， 迁移程序不转换不再返回可选值的if let语句。 解决方法：在if let移除对应的语句，如果你需要一个词法定界，可以它对应的语句放到do语句中。 迁移程序不会添加为枚举值添加前置句点。当迁移程序把枚举值都变为小写时会造成冲突。 解决方法：为没有前置句点的枚举值手动添加句点 去掉NS前缀的Foundaiton中的类型冲突的自定义属性冲突，会自动添加模块标识的类型名字。例如：如果有这样的定义var URL:NSURL，它会被重写为var URL: Foundation.URL。 解决方法：在进行代码迁移之前把这样的属性重命名，这样就会冲突了。Swift的API设计指南建议这样的应该是小写的。 迁移程序不会处理C形式的递减的for循环，如：for var i = right; i &gt; left; i-- {} 解决方法：手动修改循环为for-in形式的或者while形式的循环。 迁移程序可能错误的在自定义的闭包类型添加括号。如：从inout State -&gt; Element?变为inout (State) -&gt; Element?，正确的修改应该是(inout State) -&gt; Element? 迁移程序会给SequenceType添加不必要的Swift模块标识符，如： struct MySequence: SequenceType =&gt;struct MySequence: Swift.Sequence 解决办法：移除前置的Swift 迁移程序可能会略掉小写之后的枚举值。 解决方法：手动处理一下迁移程序忽略掉的小写的枚举值。 Swift 2.3 迁移程序在迁移到Swift2.3的过程中可能会错误的转换Range&lt;T&gt;为CountableRange&lt;T&gt;。 解决办法：改回Range&lt;T&gt;，Swift2.3没有CountableRange&lt;T&gt;，只有Swift3有。 迁移程序会为使用了dispatch_queue_set_specific()添加一行这样的/*Migrator FIXME: Use a variable of type DispatchSpecificKey*/注释，这个只在Swift3中有用，如果是迁移到Swift2.3，可以忽略这个。 其他杂项 如果在你的工程里有多个scheme包含了不同的target，你只需要关注你要迁移的那个。你应该手动选项一个新的scheme。此时运行Edit-&gt;Convert-&gt;To Current Swift Syntax迁移其他的scheme，或者创建一个scheme包括工程内所有的target，并且保证在运行迁移助手工具的时候已选中这个scheme。]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6/7月杂记]]></title>
    <url>%2F2016%2F07%2F18%2F6-7%E6%9C%88%E6%9D%82%E8%AE%B0.html</url>
    <content type="text"><![CDATA[每次写这种记录就是胡言乱语的流水帐，之后再回去看一眼时候，感觉当时心情是千军万马，火急火燎的。至少有半个月没有碰这个小(ji)博(shi)客(ben)了，趁端午节的调休假记录一下这二个月。流水帐开始: 游戏上线了，算是很成功，这可能还是小事儿，最高兴的是终于可以不用像之前那样加班加点几乎每天熬夜了，熬夜对身体影响真得特别明显。好像身边的小伙伴都松了一口气，也终于有时间早回家一会打打游戏，看看闲书，看看电影，可能屌丝的想法就是这样吧… 最近玩儿了一下《火炬之光2》，用法师通关了，从小就喜欢这种类型这种视角的游戏(可能是手残玩不了那种策略类型的)，画面在4K显示器下相当棒，就是浮动的UI窗口(貌似学名叫HUD?)在4K分辨率下显示得相当小，不过影响不大，宠物带东西回城这个很好，火柱技能，虽然有时候感觉移动速度太慢追踪也略显示迟钝，如是这二个弱点也没有，那这估计就是一个bug技能了，用来刷怪是相当爽的。下来准备玩儿一下工程师… Swift 3.0的开发者预览版已经发布了，看了一下改动提案里面已经实现的就几十条了，还有没完全实现的几十条，这次从Swift 2.x迁移到Swift 3.0估计需要些工作量了，官方给了一个Swift 3的迁移工具，昨天弄到挺晚把那个官方的迁移说明翻译了一下(虽然翻译功底很烂，就当自己熟悉学习了)。最近还买了一本《Cocoa Programming for OSX》第五版，虽然是全英文的，但是看起来还不算费劲，看了四分之一，感觉对macOS编程还是帮助很大的，吃灰了好几个月的Kindle终于又见了天日，用来看这种英文书是真得很爽。 这两天没事儿，把大学时候用的笔记本翻了一下，居然在硬盘里找到了2013年8月我开始翻译的那本开源的《Advanced Linux Programming》，而且已经翻译了四章，四万多字…后来我就换了电脑，然后就把这事儿给忘了。我当时是怎么想的，那个时候的执行力真是好。虽然翻译得不怎么好，但也不能虎头蛇尾，copy出来继续，已在github建了repo。 说了执行力又想到了一个打脸的事，之前看得那个非常不错的配色，想配一个vim scheme出来，结果到现在也一直没实施，真是容易产生惰性。对，还有那个翻译了三分之二的Swift 3的变动列表。 TODO: 把没翻译完的Apple官方的迁移指南翻译完，Swift 3变动列表翻译完 配色bugcolor配置完 基本架子搭起来的MacCalendar边学边继续 End]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift3迁移指南-1]]></title>
    <url>%2F2016%2F07%2F18%2FSwift3%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97-1.html</url>
    <content type="text"><![CDATA[前记Swift3开发者预览版已经开放了，3.0release估计很多就来了，Swift 3相对于Swift2.x变动非常大，看官方有一个Swift 3的官方迁移指南，这里粗略翻译了一下，也算是自己熟悉一下。分成二部分翻译，第一部分就是迁移程序的各种注意事项，第二部分是各种细节问题解决方案。后续把swift-evolution的语法/特性变动列表翻译一下。 Xcode8.0带来了一个迁移工具，能帮你将现在的Swift工程迁移到Swift3，也能让你的工程更新到Swift2.3和新的SDK版本。 预迁移准备为了达到最好的迁移效果，确保你想要迁移的工程能在Xcode7.3下构建成功，并通过了所有测试。 同时还要保证工程在版本管理之下，这能让你看到在通过迁移助手迁移完成之后工程内的变化，并且在有需要的时候可以随时回退变化，再次去尝试迁移。 假如有多个scheme用来构建不同的独立product(或者对应不同平台下相同的product)，那么在你的工程里创建一个为你需要的所有平台构建所有东西的scheme还是相当重要的，包括你用于的单元测试的target。迁移助手会根据你选择的scheme的更改来生成，所以所有需要处理的target都要一起到包含到这个scheme里。 要检查或者修改已经被包含到scheme里的target，选中“Edit Scheme”选项，在左侧切换到“Build”标签，确认你所有的target和其单元测试都已经被包含进scheme里了。 如果你的工程依赖由Carthage或者CocoaPods提供的第三方开源的工程，参考使用Carthage/CocoaPods工程这节。 Swift迁移助手当你首次用Xcode8.0打开工程的时候，会有弹窗提示你通过迁移助手来做一个迁移测试。这个工具也可以通过菜单“Edit-&gt;Convert-&gt;To Current Swift Syntax…”手动打开。 你可以执行下面二种迁移: 使用Swift2.3 修改你的工程开启使用旧式Swift的构建设置，并提供代码更改来确保可以在新的SDK下使用。 使用Swift 3 推荐使用这种。你的工程得到代码的更改且能通过Swift3.0来构建，同时能使用Xcode8.0里面的所有新功能。 你还可以选择先将工程通过迁移助手迁移到Swift2.3，之后再迁移更新到Swift3.0。 在你使用迁移助手选择“使用Swift2.3”或者“使用Swift3.0”之后，你得到一个将要被迁移的target的列表。此时这些target不包含任何Swift代码并且也不能被选中。有一个已知的问题，影响那些不包含Swift文件但是“Emned Swift Standard Libraries”设置却可用的target，原本这个设置应该被勾选的，但是却没有。安全起见，把所有的列表中target都选上。 点击“Next”，会来到“Generate Preview(生成预览)”页，助手即将开始启动迁移来生成代码的更改。当这些都完成之后，在点击“Save”之后，你会看到所有这些变动都会生效。注意这点， 在比较的界面中，原始的代码(转换之前的)在右边，变动之后的在左边。点击“Save”之后，这些代码变动就会应用到原始文件里。如果你选择的是迁移到Swift2.3，所有这些target都会拥有一个“使用旧式Swift”的构建设置集合。 在处理target的时候可能会出现影响迁移处理的问题。切换到“Report Navigator”选择“Convert”入口；这是一个转换的生成日志。检查日志里显示的错误，如果你发现错误是从你自己的一个target中引入Swift模块失败了(比如，“No Such module ‘NAME’ ，这里显示的‘NAME’是其中一个target的名字”)，这可能是你遇到了一个已知的问题，就是迁移工具生成时没有正确的处理隐式的依赖模块(也就是这个叫‘NAME’的target没有在处理依赖它的target的之前处理)。解决办法，编辑scheme在‘Build’标签里显式的加入这个target(点击左下的加号按钮，在已选择的target列表中找到这个target)，在列表中，如果依赖它的target在它前面。“Parallelize Build”项必须不能勾选。 如果看到的错误是关于不能签名target，试着在这个target的构建设置禁用签名。 如果看到其他的错误，请在https://bugreport.apple.com详细描述并反馈。 如果你需要使用其他任何的替代方法，回退之前所有通过迁移助手产生的变动，使用替代方法，再手动用迁移助手从头开始转换一次。 Swift 3 迁移变动概览Swift 3有非常多的重大变动，迁移工具会帮你。你可以通过下面的链接大致看一下Swift 3的改进提案: https://github.com/apple/swift-evolution](https://github.com/apple/swift-evolution 下面是一份简要的源码崩坏修复的概述: API设计指南Objective-C的API已经依照Swift的API设计指南来引入。这会同时影响如何引入SDK和用户自己的Objective-C的frameworks。Swift标准库也做了很多改动来遵循设计指南。更多细节请参考提案SE-0005 - Better Translation of Objective-C APIs Into Swift. 迁移程序会把用户自己定义的枚举都变成小写以此来让它们与新的设计指南相匹配。 SDK像CoreGraphics，Dispatch，Foundation里的其他类型这些主要的framework，不再做为一组全局函数和变量来引入了，改为做为Swift类型各自的方法和属性来引入。更多细节请看提案SE-0044 - Import as member, SE-0088 - Modernize libdispatch for Swift 3 naming conventions. Swift 3里在主要的基础类型中，‘NS’前缀已经被移除了。请看SE-0086 - Drop NS Prefix in Swift Foundation. Swift 标准库Swift 3中集合类型的索引模型被改动的相当大，更多细节在此SE-0065 - A New Model for Collections and Indices 最明显的改就是不再有像successor()，predecessor()，advancedBy(_:)，advancedBy(_:limit:)，或者distanceTo(_:)这些索引方法了。这些操作都被移到用于递增和递减切片集合中了。 myIndex.successor() =&gt; myCollection.index(after: myIndex)myIndex.predecessor() =&gt; myCollection.index(before: myIndex)myIndex.advance(by: …) =&gt; myCollection.index(myIndex, offsetBy: …) 如果迁移程序不能检测到集合是用于切片，就会插入一个编辑器占位符，这时就需要自己必须填入正确的集合了。 为了支持集合的更改，Range类型也做了一些变动。之前的x..&lt;y和x...y产生相同的Range类型。现在这些表达式能产生四种类型:Range， CountableRange，ClosedRange，CountableClosedRange。我们将Range拆分为Range和ClosedRange类型允许包含类型最大值的闭区间(如，0...Int8.max是可以的)。普通的区间类型和它们的~Countable变体在功能上的不同: Range&lt;Bound&gt;与ClosedRange&lt;Bound&gt;现在只需要Comparable做为边界。这意味你可创建一个Range&lt;String&gt; Range和ClosedRange不能被遍历(它们不再是集合类型)，因为值仅是一个不能被递增的Comparable CountableRange和CountableClosedRange需要Strideble，并且它们符合Collection，所以可以遍历它们。 ..&lt;和...操作符试着做正确的事情并返回最符合的区间，所以像这样的代码for i in 1..&lt;10推导出一个CountableRange类型，代码还是可以正常工作的。假如你有一个做为一个区间类型的变量，并且你想把它传给一个接收不同类型的区间类型的API，这时需要在区间类型变量上使用构造器来转换一下: 12var r = 0..&lt;10 // CountableRange&lt;Int&gt;Range(r) // converts to Range&lt;Int&gt; 语言 函数第一个参数标签一致化 现在是考虑函数默认要有第一个参数标签，请看SE-0046 - Establish consistent label behavior across all parameters including first labels。迁移程序会添加下划线标签，以保留已经存在API: 1func foo(bar: Int) =&gt; func foo(_ bar: Int) 对UnsafePointer的处理变动 在Swift 3中，现在是使用可选类型来表示可为空的空对象指针类型，如UnsafePointer&lt;Int&gt;?，请看 SE-0055 - Make unsafe pointer nullability explicit using Optional。这表示UnsafePointer，UnsafeMutablePointer，AutoreleasingUnsafeMutablePointer， OpaquePointer，Selector， 和 NSZone现在表示非可空指针，也就是这些指针永不为nil。使用这些类型的代码可能需要做这几项更改: 要设置指针为nil，类型必须是可选的。迁移程序会处理几种简单的情况，但是通常你必须确定你的指针是仅仅如对象引用一样可以为可选类型。 从C函数获取的返回的可为空的结果在访问pointee属性(原来的memory)或者下标元素之前必须显式解包。这里链式可选语法还是可以继续使用的。如: result?.pointee = sum。 接收或者返回指针类型的回调(C函数或者blocks)必须与使用或者忽略Opional类型的原始定义相一致。 由于编译器的限制，不允许传递指针给使用了C可变参数的函数(如NSLog)。替代方法是使用下面这种形式用一个指针大小的整型来代替，做为参数传递过去: Int(bitPattern: nullablePointer)。 现在Objective-C轻量泛型类型做为泛型类型引入 SE-0057 - Importing Objective-C Lightweight Generics 因为Objective-C的泛型不会在运行时表现，所以在Siwft中使用他们有一些限制: 如果Objective-C的泛型类被用于as?，as!，或者is转换中，这个泛型的参数不会在运行时被检查。如果转换成功的操作数是一个Objective-C的类实例，那参数就会忽略。 123let x = NSFoo&lt;NSNumber&gt;(value: NSNumber(integer: 0))let y: AnyObject = xlet z = y as! NSFoo&lt;NSString&gt; // Succeeds Swift 子类只能继承一个参数类型被完全指定的Objective-C泛型类。 1234// Error: Can't inherit Objective-C generic class with unbound parameter Tclass SwiftFoo1&lt;T&gt;: NSFoo&lt;T&gt; &#123; &#125;// OK: Can inherit Objective-C generic class with specific parametersclass SwiftFoo2&lt;T&gt;: NSFoo&lt;NSString&gt; &#123; &#125; Swift可以扩展Objective-C泛型类，但是扩展不能含有约束，并且扩展内定义不能访问类的泛型参数。 12345678910extension NSFoo &#123; // Error: Can't access generic param T func foo() -&gt; T &#123; return T() &#125;&#125; // Error: extension can't be constrainedextension NSFoo where T: NSString &#123;&#125; 基本容器类NS[Mutable]Array， NS[Mutable]Set，和NS[Mutable]Dictionary现在仍然做为非泛型类型引入。 ​ 迁移之后虽然迁移程序会替你处理那些固定的变动，但还是可能需要你进行大量的手动修改以保证在迁移程序做出迁移改动之后能成功构建出项目。 你可能会看到一些已经关联到的fixit错误；虽然迁移程序是用来消除Swift 3编译器提供的fixit的，但是一个已知的限制就是迁移程序不能保证100%的没问题(特别是在二个target之间有内部之间的依赖的的时候)，可能会有些fixit会被忽略掉。 即使编译没问题，迁移程序生成的代码也不是完美的，比如，你可能会看到转换为带‘NS’前缀的类型(url as NSURL)，这样的代码显然是使用相关API重构为新的URL类型更为合适。你会看到迁移程序会在需要转换为更合适的代码的地方加入了新的注释(/*Migrator FIXME: ...*/)。 查看Known Migration Issues这节，是一个你在迁移工程的过程中可能会遇到的问题的列表。]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端午节后碎念]]></title>
    <url>%2F2016%2F06%2F27%2F%E7%AB%AF%E5%8D%88%E8%8A%82%E5%90%8E%E7%A2%8E%E5%BF%B5.html</url>
    <content type="text"><![CDATA[一个月内一直在各种忙，项目马上上线，各种问题都来了，虽然不是身居要职但是问题也特别多，说焦头烂额也不为过，每天处于各种加班状态中感觉时间过得特别快。端午节没休息，国内游戏行业好像都是这个状态，一言不合就疯狂加班😂。 不同公司技术栈不同特别是游戏这个东西，到后期在大陆上的游戏都避免不了一个事情就是Android的各种渠道商的接入，不同公司有不同处理方式，可能是对Android没有深入了解过，只知道比葫芦画瓢，很多时候会出各种问题，尤其对Android的各种线程的处理，回调函数里非线程安全的操作要Handle到主线程操作之类的，虽然之前进过坑，但是突然发现『每个坑里的风景也是不尽相同呐……』。最近补一下Android线程相关的东西。找时间整理记录一下。 上个在掘金网站看到一个讲配色的文章，里面有一个地铁站的例子，给了一个配色网格图，个人特别喜欢，一直想参照那个配色把它搞成Vim的Colorscheme，名字都想好了—bugcolor，本打算在端午节完成，无奈又加了三天班，近期完成一下。 上周看了一下《天启》，看得时候好爽，各种特效爽翻，看得一愣一愣的，但是看完了脑袋里除了各种特效场面啥也没有，剧情照着《逆转未来》差太多，天启这么一个无敌的存在，最后就让凤凰女给秒了，后来就想，如果让幻影猫把天启和哨兵搞到一起，是不是很欢乐🤔。最近又把《火炬之光2》玩了一下，就回想起当年在高中放假就去网吧刷《暗黑破坏神》，手残就喜欢这种无脑点鼠标。给媳妇儿买了一年的爱奇艺会员，然后看《Mr. Robot》的时候给推荐了一个叫《余罪》网络剧，随便点了看了一下，结果一发不可收拾，二天直接看完了，还挺有意思的。 最近玩了几个好玩的单机手机游戏 《Mekorama》类似《纪念碑谷》，画面没有后者精细，但是可以自定义关卡。 《DreamMachine》也类似，但是画就更糙了一些，但是感觉还挺耐玩儿的。 《Beat Racer》放一首歌，然后控制一个小车在跑道上跑，画面挺带感的，突然就想起了当年的盛大的那个《疯狂赛车》，一玩儿就是一下午，暴露年龄😳。 完这阵真得找个时间放松一下，找个地儿去溜达一圈，今年还没出去溜达过。也算是给自己的一点回报和鼓励吧。 End]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function Currying]]></title>
    <url>%2F2016%2F06%2F26%2FFunction-Currying.html</url>
    <content type="text"><![CDATA[函数柯里化前几天Swift发布3.0预览版，改动的还不小，不兼容Swift2.2，加了诸多特性，也去掉了不少语法，看到的第一个就是在Swift3.0里去掉了Function Currying(函数柯里化)的语法声明形式，具体可以看这里。之前从来没有了解过这个术语，只知道大致的意思，这里记录一下。 概念函数柯里化是计算机科学里的术语，简单的说就是把一个接受多个参数的函数转换为接受一个参数的函数，并且返回一个这样的函数，这个函数接受剩下没有处理的参数且把最终结果返回。具体可参照Wiki的解释。 为什么要使用函数柯里化函数式编程的思想，把函数变成”一个输入一个输出”的单个小片段，从而可以更好的与其他接口组合出更强大的功能，整个过程也更易理解，看起来就是把一大堆复杂的东西，”一步一步的”构造出来，而这中间的过程都是单一的可组合的，更加灵活的。至于为什么Swift3.0会去掉函数柯里化的语法，SE-0002提案给出的解释是在Swift里柯里化的功能有限，且增加了语言实现的复杂度。 ExampleLua中实现类似的函数柯里化 123456789function currying_test(fir) return function(sec) return function(thr) return fir * sec * thr end endendprint(currying_test(2)(3)(4)) -- 输出24 Python中也是类似，不过Python中的functiontools包中还有partial，可以组合出类似的功能。通过固定某些参数的值，组合出更灵活的返回函数完成更多功能。 Swift2.2中的函数柯里化 12345678910func curryingFunction(fir:Int)(_ sec:Int)(_ thr:Int) -&gt; Int &#123; return fir + sec + thr&#125;let addSec = curryingFunction(10)let addThr = addSec(11)let res = addThr(12)print(res) // 输出33// 也可以直接像上面lua那样直接调用print(curryingFunction(10)(11)(12)) 可能在实际项目中不会追根究底的去这样儿用，只求达到最终目的，或者是并没有理解到柯里化的真正精髓，但是多知道一些总是好的。 End记录]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好用的shell命令和常用的SVN命令记录]]></title>
    <url>%2F2016%2F06%2F16%2F%E5%A5%BD%E7%94%A8%E7%9A%84shell%E5%91%BD%E4%BB%A4%E5%92%8C%E5%B8%B8%E7%94%A8%E7%9A%84SVN%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[常用的命令行SVN命令现在的版本管理工具都有相当人性化的GUI版本，无论是免费的收费的，都做得相当好，点几个按钮，选几个文件，提交，回退，更新，一步就完成了，但是最近在公司的Mac下(低配Mac mini，你懂的…)，很多GUI版本的工具都非常慢，卡顿非常严重，而且对SVN的外链(external)支持不好(像CornerStone这个SVN的GUI工具)，也就是在版本管理工具的内部的文件视图里，看不到external属性下的文件，只能看到最上级的目录，而实际的目录中却有对应的文件，只是不能在GUI的版本工具中进行操作，这个情况下就只能在对应的外链目录下通过终端进行提交了。一段时间下来，发现一堆命令都忘了，只会在GUI工具上点来点去，一旦遇到上面那种情况，就得傻眼半天，这里记录一下常用的SVN命令行命令。 检出(Check Out) svn checkout ex: svn checkout svn://dev.bugcode.net/demo/svn_demo short: svn co 更新文件 svn update [-r version_code] svn update # 直接更新当前目录和子目录的所有文件 ex: svn update -r 1028 demo.c # 把当前目录下的demo.c还原到版本号是1028的版本 svn update # 更新指定文件到最新 short: svn up 向版本库添加文件，支持通配符 svn add ex: svn add demo.swift / svn add *.cpp 提交文件 svn commit -m “commit-log” ex: svn commit -m “commit message for svn” ./demo_dir/demo.c short: svn ci 回退文件(直接解决冲突状态，但不会回退被删除的文件) svn revert ex: svn revert ./demo/demo.c 删除文件 svn delete -m “delete message” ex: svn delete svn://dev.bugcode.net/demo/demo_need_file -m “delete message for svn” # 相当于直接删除版本库里的文件 ex svn delete ./demo/demo_need_file -&gt; svn commit -m “delete message” # 先删除本地副本中的对应文件，再提交 short: svn delete / svn remove / svn rm 查看log svn log 比较差异 svn diff svn diff version1:version2 ex: svn diff ./demo.c / svn diff 1028:1000 ./demo.c short: svn di 显示属于版本库管理的目录和文件，直接创建属于版本库管理的目录 svn list ex: svn list ./ short: svn ls svn mkdir ex svn mkdir test_dir 解决冲突，这里的命令只是用来移除对应文件的冲突状态(删除对应的标记冲突的文件)，具体的文件冲突还是需要手动去文件解决 svn resolved ex: svn resolved ./conflicted_file_name 有用的shell命令shell命令天天在用，除了ls，cat，pwd，cp，mv类似这些常用的，有些提高效率的命令用起来还是可以缩短不少输入时间的。脑袋不好使这里一起记录一下 zsh下的进入当前目录下的前二级目录，bash没有！ cd … 都知道 ~ 是home目录，但是cd之后什么也不加也是相当于 cd ~ 中划线，直接cd -可以进入上次cd进入的目录，比如现在test目录进入test目录下的next目录，这时执行cd -,就会再回到test目录下，再执行cd -就又回到test目录下的next目录下了。 快捷键 ctrl + a: 回到行首 ctrl + e: 去到行尾 ctrl + u / ctrl + y: undo / redo ctrl + z: 当前正在运行的程序放到后台执行 $? 获取上一个命令的返回结果，比如 123456#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; printf("Terminal output test.") return 0;&#125; 编译后生成的可执行文件运行后，想看一下main函数的返回值，就可以在文件运行后，使用$?来查看return的具体值。 !! 输出上一次命令，并执行 !$ 输出上一次命令的最后一个字符串 快速创建文件，touch file 或者 &gt; file(更短更快) fgrep “string” 快速查找当前目录包含string这个串的文件并输出，加-r选项可以查所有子目录 end 生活不只有眼前的苟且，还有远方的苟且。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADB命令使用记录]]></title>
    <url>%2F2016%2F06%2F14%2FADB%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[经常在Mac在安装操作Android真机，但是Mac对于Android的设备支持，你懂的，没有Windows那么方便，经常把文件copy来copy去就为了把文件放到Android手机里，特别不方便，现在知道了Android sdk的adb(Android Debug Bridge)，这里面的adb push 和adb pull命令特别好用，直接可以用Android真机连Mac把文件从电脑push到Android，或者使用pull命令把Android机拉到Mac机上。这里记录一下其他的adb命令，在调试真机的时候还真是特别有用，可以在电脑上全面操作Android真机。安装不需多说，直接把对应的adb所在目录加到环境变量里就行。 查看adb 帮助 adb help 从电脑向电脑上复制文件 adb push local_file device_path 从真机向电脑上复制文件 adb pull device_path_file local_path 直接进入真机shell adb shell #进入之后可以使用一般的linux命令来查看相关信息 也可以直接使用adb shell + 命令来执行，类似如下： adb shell cat /proc/meminfo # 内存占用 adb shell cat /proc/cpuinfo # cpu序列号 adb shell procrank # 查看各个进程的内存情况 # 还有类似cd，ls，top，ps，grep，rename，rm，mv，chomd，mkdir等命令… 安装，卸载apk adb install # 安装到手机内存 adb install -s # 安装到手机sd卡 adb install -r # 重新安装文件，不清除数据和缓存 adb uninstall # 这里的参数不是apk文件名，是安装之后的包的名字 查看后台service信息 adb service list 查看bug反馈 adb bugreport 清除logcat缓存，在命令行里查看logcat输出 adb logcat -c adb logcat -s &lt;过滤标签名&gt; 还可以查看wifi密码，获取设备名称 adb shell cat /data/misc/wifi/*.conf adb shell cat /system/build.prop 重启机器 adb reboot # 和linux命令行差不多 查看连接所有的设备，获取序列号，设备ID adb services adb get-serialno adb get-product Android 系统中sd卡的路径 cd /sdcardX # X是sd卡序号 如sdcard1 退出adb的shell模式 exit # 直接exit退出adb shell 到此已经差不多够用了。 记录end]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pyinstaller使用记录]]></title>
    <url>%2F2016%2F06%2F11%2FPyinstaller%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[起因接上次的Android加载动态库的问题，因为很多应用或者游戏，在某些商店上架的时候会进行二次打包，会将自己的SDK的资源(动态库，各种资源之类的)打包到应用或者游戏的apk包里，这样儿就出现了之前说过的问题，如果一个应用或者游戏只提供了一个armeabi平台的动态库(其他平台兼容armeabi)，这样问题就在于如果某些渠道的SDK封装了动态库并且提供不同平台的动态库(性能或者其他考虑，类似x86，armeabi-v7a)，就会出现二次打包后，某些非armeabi的平台，打开应用或者游戏的瞬间，应用或者游戏就崩溃了，因为lib下有对应的文件夹，而应用或者游戏本身并没提供对应的动态库，动态库只存在于armeabi文件夹中。所以为了解决这个问题，就需要每次打包前都检查各个sdk提供的二次打包的zip包，将其中的除armeabi的文件夹都删除，再打包。因为可能windows和mac都需要，所以选择用Python来写这样儿一个脚本，删除zip包内指定的文件夹的功能，废话一堆，主要目的是这个，每次打包打开命令行再输入python命令其实也很繁琐，最好就是双击一下可执行文件，当前目录下的sdk的zip包就都经过删除非armeabi的处理了(脚本逻辑非常简单，解包，搜索root文件夹，把非armeabi的文件夹都删除)，之前用过pyinstaller打包过python脚本为可执行文件，这里做一下记录。 使用方法PyInstaller很强大，可以为多个平台(windows，mac，linux)生成可执行文件。 mac下的pyinstaller使用 mac下的pyinstaller使用很简单，直接去pyinstaller官网主页右下角下载最新版本zip包，直接解压在某个目录里就可以，然后终端进入pyinstaller-xx的目录里，直接使用 python pyinstaller.py YOUR_PYTHON_FILE 就会生成mac下可执行文件了，这样生成的是一个文件夹(里面包含所了所有需要的动态库)，如果想把资源，库都打包到一整个文件里，使用-F选项，即 python pyinstaller.py -F YOUR_PYTHON_FILE 然后会在pyinstaller-xx文件夹下生一个与YOUR_PYTHON_FILE相同的文件夹，里面的dist文件夹里就有你想要的名为YOUR_PYTHON_FILE的可执行文件了。这样方便发送给别人使用，如果发送给别人使用无应，应该是打包好的这个可执行文件在另一台电脑上没有执行权限，直接执行 chmod 755 YOUR_EXECUTE_FILE 通常可以直接解决问题。 windows下pyinstaller的使用 安装python2.7，python加入环境变量(为了随处都可以使用控制台使用python命令) 然后pyinstaller需要一个单独的pywin32包，这里可以下载到，注意:要下载对应的与python2.7版本相同的。下载完成直接一路安装next就可以了。如果出现中间一步无法继续，应该是下载的pywin32版本与安装的python环境版本不同导致的。 下载pyinstaller2.0包，解压到指定目录不需要python setup.py install这步，也不需要configure这步。 下载upx可执行文件，下载最新的对应windows下的zip包即可，把zip包里的upx.exe提取，放到上一步解压的pyinstaller文件夹的根目录中。 在pyinstaller目录中直接执行 python pyinstaller.py YOUR_PYTHON_FILE 或者 python pyinstaller.py -F YOUR_PYTHON_FILE 表现与mac上致，如果不加-F，生成与YOUR_PYTHON_FIlE相同的文件夹，里面包含了动态库(dll，资源之类)，加-F选项直接生成一个打包好的exe。 记录end]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android加载动态库规则笔记]]></title>
    <url>%2F2016%2F06%2F05%2FAndroid%E5%8A%A0%E8%BD%BD%E5%8A%A8%E6%80%81%E5%BA%93%E8%A7%84%E5%88%99%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[Android菜鸟，距离上次长时间调试Android平台下的游戏是一年前了，最近几乎都没调试过Android上的东西，特别还是这种需要跨平台的游戏，各种JNI调用，各种动态库齐上，各种渠道各种接。尤其是类似那种AnySDK的一站式的接入SDK的，不出问题皆大欢喜，只要出了一个问题就够排查上半天，因为游戏和渠道SDK的中间又多了一层中间层代码，这样问题排查起来更麻烦。非常菜的问题，长时间不用就会忘记，这里记录一下，都是零碎的小知识。 涉及到JNI调用肯定就有第三方的动态库(.so文件)，在游戏里也就是C++代码的封的动态库。因为到现在为止Android下台支持的CPU架构已经达到7种(ARMv5，ARMv7， ARMv8，x86，x86_64，mips)，不同CPU架构上的不同的ABI(Application Binary Interface)，其定义了二进制文件如何在对应的架构的系统平台上运行，如指令集，可用的系统库函数等。在Android系统上，上面7种不同的CPU架构对应的ABI分别是armeabi，armeabi-v7a，arm64-v8，x86，x86_64，mips。而这些平台ABI就体现在C++(或者C代码)生成的so文件打包到apk里面时所在libs的具体目录，Eclipse生成的Android工程都会有libs目录，可以看到对应的libs文件夹下有如armeabi这样的文件夹，这就是相应平台的二进制包，当然最好就是为支持的每一种平台都提供对应的二进制包，这样Android的包管理器在安装apk的时候就会把相应平台的二进制包拷贝到相应程序的私有目录的lib目录里(并不会拷贝所有的二进制包，apk里有因为apk可能会安到种被支持的设备上)，问题就是apk包体会变得特别大，如果一个游戏的C++的so库到了十几M，这样给每个平台都提供一个，无形就多了近百M的apk包大小。 这次遇到的问题就是游戏只提供了一个armeabi的so库，这样就能兼容大部分机型(ARM向前兼容，x86兼容armeabi和armeabi-v7a，当然mips就略过了)，为了兼顾包体大小与机型兼容。游戏本身只提供了armeabi的so，上文说接通用型的渠道SDK，由通用SDK提供工具进行游戏的apk进行再解包打包，问题来了，某些渠道直接打开游戏就闪退，中间排查原因过程不多说了，接了Eclipse看log直接是报UnsatisfiedLinkError错，也就是调用loadLibrary的时候没找到对应的so库，直接解包apk看libs文件夹下，果不其然多了一个armeabi-v7a文件夹，也就是渠道提供了不同平台下的自己的二进制包，解包把对应的armeabi-v7a文件夹删除，再封包，再打开游戏，不再崩溃了。 记录End]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六一碎念]]></title>
    <url>%2F2016%2F06%2F01%2F%E5%85%AD%E4%B8%80%E7%A2%8E%E5%BF%B5.html</url>
    <content type="text"><![CDATA[又一个六一儿童节 真就像段子里说得，是不是只有我们这个年代的人才天天嚷嚷着过六一，来北京的第三个儿童节，早晨起来就听到旁边的小学已经在诗朗诵了。晚上算是给我们这些”大孩子”过个儿童节，早下班了一会儿☹️，这就是福利了么？(手动哭脸) 最终还是没忍住，败了Dell p2415q 一直对4K显示器长草，终于败了Dell的23.8寸这款，和Macbook pro 2015 mid真是绝配，雷电口直接插minidp，显示器默认1080P非常清晰和Retina基本没区别。淘汰了原来的三星显示器，加了一个乐歌的支架，安上各种角度可以转各种爽，HDMI接Windows主机玩游戏看电影，dp线接Macbook。还找到了大二时候买的Cherry出的一个薄膜键盘型号是G230，当时买是299块，还心疼了好久，晚上还真不能用机械键盘，声音太大，这个是剪刀脚的，几乎没声音，手感还不错，可能是用了五六年有感情了吧。来个合照 SwiftCalendar 看了好久的Swift了(虽然3.0都来了可能语法会变不少)，打算比葫芦画瓢弄一个Mac上的万年历App，显示农历的那种，因为发现现有的都有符合心意的，自己造一个合心意的。刚把工具函数写了一些，项目不忙着重摆弄一个这个，对之前的学习也有个交代呢。 Github github这阵子改变了好多，虽然还是在墙内间歇式的抽风，但总归还是能访问的，github去掉了streak days也就是连续contribution的天数，官方的解释就是让项目提交回归初心吧，大意就是做有意义的提交，不是为了提交而提交(刷连续天数)，我感觉这是一个好的改变，虽然chrome有对应的插件依然可以做到之前的各种统计，这个插件的”颜值”还是很高的，直接用插件gihub上的截图 插件的名字叫isometric-contributions，不需要做什么特殊设置，打开自己的gihub就可以看到了。 而今天github又在个人主页上加一个新的玩意就是bio，词典给出的解释是『简历，小传』，我感觉这个东西更像是一句”个性签名”，像QQ那种。不过了挺好玩的，在头像底下又可以加一个可以装逼的话了。我直接加了一句『coding like rookie…』,虽然我本来就是一个菜鸟。 “执行力” 可能是最近加班导致的身体因素，导致最近的拖延有些过度，很多事情都延后了。”执行力”直线下降，在这个特殊的日子里，得找回之前的状态。 项目终于要到尾声了，近二个月的加班加点，还弄得咳嗽了好一阵子，咳嗽也好了，项目也终于快了，就看最后的战果了。饭后散步和保证睡眠还得非常有必要的。 碎念End]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alfred-Python-Tutorial]]></title>
    <url>%2F2016%2F05%2F23%2FAlfred-Python-Tutorial.html</url>
    <content type="text"><![CDATA[Alfred不再多说，试用一次之后，直接32欧上了Mega授权，杀器其实是Alfred Workflow，配置action，filter，可以有无限可能的操作。这里把deanishe上的Python写Afred Workflow的入门翻译一下放在这里，但是国内pinboard用的不多，这里用V2ex提供的最新主题列表的API，通过Alfred获取V2ex上的最新主题列表，来“本土化”翻译一下deanishe网站上的Python写workflow的入门。Alfred Workflow支持多种脚本语言编写，完全可以使用自己擅长的脚本来写。 Alfred Workflow支持多种脚本语言编写：bash,zsh,php,python,ruby,applescript,perl 下面按步用Python来做一个简单的的workflow。 创建一个新的Workflow首先打开Alfred的首首选项(Preference)， 切换到Workflow页签下。 如上图点击加号创建一个空白的workflow(Blank Workflow)。 为新创建的空白Workflow添加必要的描述点击创建当弹出Workflow的信息面板时，这里就要给你要创建的Workflow添加名称，Bundle Id，还有可选的对workflow的简要描述。 Bundle Id是必须要填写的，因为在Aldred 和 Alfred Workflow内部需要依赖这个Bundle Id来唯一区分你这个Alfred Workflow，没有这个Bundle Id，Alfred Workflow就不能正常运行了。 除了这些必要的信息，还可以拖拽一图片到左侧的Icon区域，这会让你的Workflow看起来更漂亮些(这个icon会在Alfred Workflow的每条结果中显示出来)。 加入Script Filter(脚本过滤器)组件下一步就是加入一个Script Filter(翻译成”脚本过滤器”)，Script Filter接收Alfred的输入内容(即用户输入的查询内容)并将结果列表返回给Alfred。这个Script Filter(内部代码实现)需要尽可能的快速执行，因为用户每在Alfred的搜索框内输入一个字符都会调用执行一次这个Script Filter: 接下来点击这个Script Filter组件，为其加入更详细的信息。(Escaping选项暂时不必理会，这个Workflow不会接收查询) 想一个关键词，这个Keyword(关键词)的作用就是在你打开Alfred搜索框输入这个关键词的时候就会激活这个Workflow，现这个Workflow不接收任何参数，这里填No Argument，这个PlaceHolder Title(占位标题)和Subtext的作用就是在你输入Keyword(关键词)的过程中会显示出来(也就是用作提示的)。 “请稍等”这个提示是在你的Workflow工作的时候显示出来的(表明Workflow正在做相关的查询或者操作，这个例子里就是正在从网上的V2ex网站请求数据)。 非常重要的一点，设置Language(脚本语言)时，选择/bin/bash，并且在Script文本框里填写： 1python v2ex_new.py 马上我们就会创建v2ex_new.py这个脚本文件，Escaping选项暂时不用管，这个例子里不会接收参数。 你也可以选择Language为/use/bin/python，并把实现的python代码粘贴到Script文本框里，但是这并不是最好的方法。 如果这样做(指粘贴Python代码到Script对应的文本框里)，你就不能在终端里运行代码了，而且你也不能用一个顺手的编辑器，这样调试代码会非常困难。Python会告诉你哪一行代码出错，但是在Alfred的Script文本框里并没有行数标识，这样就凭空多出很多额外工作。 到这Alfred已经创建出来了Workflow，我们可以打开它并加入我们的脚本代码了，在左侧Workflow列表中右击你刚创建的Workflow，选择Open in Finder 打开目录会看到一个或者二个文件(取决于你之前是否拖拽了Icon图标) 此时需要从Github下载一个叫Afred-Workflow的包，拷贝解压到当前的Workflow目录 现在可以开始写代码了^_^ 编写Python脚本使用文本编辑器在当前的Workflow文件夹下创建v2ex_new.py并保存，向v2ex_new.py加下以下代码 1234567891011121314151617181920212223242526272829# encoding: utf-8import sysfrom workflow import Workflow, ICON_WEB, webdef main(wf): url = 'https://www.v2ex.com/api/topics/latest.json' r = web.get(url, None) # throw an error if request failed # Workflow will catch this and show it to the user r.raise_for_status() # Parse the JSON returned by pinboard and extract the posts result = r.json() for post in result: wf.add_item(title=post['title'], subtitle=post['content'], icon=None) # Send the results to Alfred as XML wf.send_feedback()if __name__ == u"__main__": wf = Workflow() sys.exit(wf.run(main)) 好，一切就绪，我们的Alfred Workflow应该可以工作了，打开Alfred搜索框，输入v2exnew并回车。你会看到如下界面： 可能会像下面这样发生错误 如果Alfred没有展示任何结果，那可能是Python脚本没有完全执行，在终端中打开Workflow的文件夹，使用如下命令运行Python脚本，应该会发现错误信息。 继续加入Workflow动作(action)现在我们可以看到v2ex网站上的最新主题列表了，但是我们只能看，不能对每条结果做任何事情，现在我们就要让这些结果条目带上”动作”(比如，在某条结果上按回车就会发生一些事情，在这个例子中，我们就在浏览器中打开应最新主题的页面)。在v2ex_new.py文件加入下面高亮的二行。 12345678910111213141516171819202122232425262728293031# encoding: utf-8import sysfrom workflow import Workflow, ICON_WEB, webdef main(wf): url = 'https://www.v2ex.com/api/topics/latest.json' r = web.get(url, None) # throw an error if request failed # Workflow will catch this and show it to the user r.raise_for_status() # Parse the JSON returned by pinboard and extract the posts result = r.json() for post in result: wf.add_item(title=post['title'], subtitle=post['content'], arg=post['url'], # 新加入这二行 valid=True, icon=None) # Send the results to Alfred as XML wf.send_feedback()if __name__ == u"__main__": wf = Workflow() sys.exit(wf.run(main)) “valid=True”的意思就是告知Alred这条结果上的动作和对应的value值要传递给下一个action(动作)，在这个例子里，就是URL。 此时再回到Alfred Preference(首选项) 面板切到Workflow界面，像添加ScriptFilter一样在Actions条目中找到Open URL，添加这个action: 详情界面在URL项中填入{query}(即上一步动作中传入的value值，就是对应主题的URL)，下面还可以选项打开链接的浏览器。 这时把鼠标放到ScriptFilter上时就会在这个组件的右侧出现一个小的”突起”。 点住这个”突起”拖拽连接至Open URL动作上。 现在再次在Alfred中运行你的Workflow，选中任一一个结果并点击回车，对应的新主题就会在指定的浏览器中打开了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SwiftNote-11]]></title>
    <url>%2F2016%2F05%2F22%2FSwiftNote-11.html</url>
    <content type="text"><![CDATA[扩展Swift允许对一个已存在类型进行功能的扩展(包括基础类型，如Int)，扩展可以做到： 添加计算型属性，包括计算型静态属性 添加实例方法和类型方法 添加新的构造方法 定义下标 添加新嵌套类型并使用 还可以在扩展一个类型的同时，适配一个或者多个协议 语法使用extension关键字，后接对应的需要扩展的类型 12345678extension ExistType // 扩展一个类型&#123; // extension code here&#125;extension ExistType: ExistProtocol,SomeProcotol // 扩展一个类型的同时并符合某个协议&#123; &#125; 扩展可以添加功能，但是不能重写已有的方法功能 扩展计算型属性 添加静态计算属性 12345extension Float&#123; static var PI:Float&#123;return 3.14159&#125;&#125;print(Float.PI) // 3.14159 添加实例计算属性 1234567extension Float&#123; var dividedBy10:Float&#123;return self / 10.0&#125;&#125;var x:Float = 11.0let res = x.dividedBy10print(res) 扩展构造方法指定构造方法必须由原始实现给出，所以扩展只能扩展便捷构造方法 12345678extension Int&#123; init(i:Float) // 四舍五入 &#123; self = Int(i + 0.5) &#125;&#125;print(Int(i:1.6)) // 输出2 扩展方法可以扩展实例方法的类型方法 扩展实例方法，如果实例方法要改变自身需要mutating关键字 1234567891011121314151617181920212223242526extension Int&#123; func repeatOutput() &#123; for _ in 1 ..&lt; self &#123; print("repeat value \(self)") &#125; &#125;&#125;5.repeatOutput()extension Int&#123; mutating func powBy(powNum powNum:Int) // 需要改变自己的值 &#123; let origion = self for _ in 1 ..&lt; powNum &#123; self = self * origion &#125; &#125;&#125;var x = 5x.powBy(powNum:3)print(x) 扩展类型方法 12345678910111213141516extension Int&#123; func repeatOutput() &#123; for _ in 1 ..&lt; self &#123; print("repeat value \(self)") &#125; &#125; static func printSelf() &#123; print("static method \(self)") &#125;&#125;5.repeatOutput()Int.printSelf() 扩展下标可添加新下标，类似于添加新方法。 123456789101112131415extension Int &#123; subscript(digitIndex: Int) -&gt; Int // int对应位置的数字 &#123; var index = digitIndex var decimalBase = 1 while index &gt; 0 &#123; decimalBase *= 10 index -= 1 &#125; return (self / decimalBase) % 10 &#125;&#125;print(34567[3]) 扩展添加嵌套类型可以向已有的类类型，枚举类型，结构体添加新的嵌套类型 12345678910111213141516171819202122232425262728293031323334extension Int &#123; enum Kind &#123; case Negative, Zero, Positive &#125; var kind: Kind &#123; switch self &#123; case 0: return .Zero case let tmp where tmp &gt; 0: return .Positive default: return .Negative &#125; &#125; &#125;func jugdeNum(num:Int)&#123; switch num.kind &#123; case .Zero: print("Zero") case .Positive: print("Positive") case .Negative: print("Negative") &#125;&#125;jugdeNum(-12) // NegativejugdeNum(0) // ZerojugdeNum(12) // Positive]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftNote-10]]></title>
    <url>%2F2016%2F05%2F16%2FSwiftNote-10.html</url>
    <content type="text"><![CDATA[构造方法与其他编程语言类似，Swift的构造方法也是在实例初始化的时候为其存储属性赋初值的操作。使用init关键字，可以自定义参数，但是不指定返回值。形式如下： 1234init([parameterlist])&#123; // initialize code&#125; 存储属性赋初值 在存储属性没有默认值时候，必须在构造方法完成的时候，所有的存储属性都有对应初值(可选类型默认是nil) 123456789101112class Constructor&#123; var str:String var optionalVal:Int? init() &#123; // 为str赋初值 self.str = "Constructor init method has been called" print(self.str) // optionalVal 默认是nil值 &#125;&#125; 定义时默认赋初值 123456class TestDefaultAssign&#123; var defaultVal = 10&#125;let tda = TestDefaultAssign()print(tda.defaultVal) // 不需要构造方法赋初值 自定义构造方法 自定义构造参数 像一般方法一样，init方法也可以传入参数，通过实例化的时候传入的参数来初始化对应的属性，如上例可自定义构造参数，修改如下： 12345678910111213class Constructor&#123; var str:String var optionalVal:Int? // 自定义二个参数 init(str:String, optionInt:Int) &#123; self.str = str self.optionalVal = optionInt &#125;&#125;// 构造实例时传入初始化值let con = Constructor(str:"constructor", optionInt:12) 外部/局部参数名 因为构造方法都叫init，所以通过参数名来分辨是哪个init方法特别重要，Swift默认给每个没有外部参数名的init方法都生成了一个和局部参数名相同的参数，如果确实想忽略掉对应的外部参数名，还是由下划线显式忽略外部参数名 123456789101112131415161718192021222324class ConstructorName&#123; var test:String var num:Int = 12 var isName:Bool // 显示忽略外部参数，不需要传入外部参数名 init(_ test:String, _ num:Int) &#123; self.test = test self.num = num self.isName = false // init 方法结束必须所有的存储属性都赋初值 &#125; // 显示指定外部参数名，生成实例的时候必须显式指定 init(externalTest test:String, externalNum num:Int, externalIsName isName:Bool) &#123; self.test = test self.num = num self.isName = isName &#125;&#125;let con = ConstructorName("name", 12)let con1 = ConstructorName(externalTest: "another", externalNum:12, externalIsName:true) 可选值与常量赋初值 某个时刻需要将某个变量赋值为nil，这个变量的类型就需要是可选类型，可选类型默认是初始化为nil的，也就是在定义时就默认有一个nil值。 12345class OptionalTest&#123; var option:Int? // 可以用init来进行实例时赋值，这里option就是nil&#125; 常量在定义时可以没有初值，只要保证在实例化完成的时候(也就是init方法结束时)保证常量属性有一个确定的值就可以 12345678910class ConstTest&#123; let constVal:Int // 可以没有初值 init(_ constVal:Int) &#123; self.constVal = constVal // 可以给常量赋值 &#125;&#125;let ct = ConstTest(23)print(ct.constVal) 默认构造方法如果结构体或者类里面的所有属性都有对应的初始值，Swift就会自动生成一个把这些属性都设置为初始值的构造方法。 类和结构体 12345678class Test&#123; var v1:Int = 10 var v2:String = "v2" // 生成默认构造方法，初值都已存在&#125;var t = Test()print("t.v1 = \(t.v1) t.v2 = \(t.v2)") 结构体的默认带参数逐一构造方法 即结构体会提供一个默认的逐一构造方法，参数名称就是结构体成员变量的名字，前提是没有给结构体提供自定义的构造方法 123456struct Test&#123; var vs:String = "" var vi:Int = 0&#125;let t = Test(vs:"vs", vi:12) // 默认提供的逐一成员构造方法 构造方法代理就是类或者结构体内定义多个init方法，通过init之间的调用来减少代码重复。 值类型的构造方法代理，因为结构体或者枚举不能继承，所以构造方法代理简单，直接在内部定义不同的init方法，之间互相调用即可。官方文档的例子特别好 12345678910111213141516171819202122232425262728struct Size&#123; var wid = 0.0, hgt = 0.0&#125;struct Point&#123; var x = 0.0, y = 0.0&#125;struct Rect&#123; var origion = Point() var size = Size() init()&#123;&#125; // 相当于提供默认构造方法，使用Size和Point的默认值来构造实例 init(origion:Point, size:Size) // 直接指定点和尺寸的Rect构造方法 &#123; self.origion = origion self.size = size &#125; // 根据中心点来和尺寸来确定Rect实例的构造方法 init(center:Point, size:Size) &#123; // 由中心点算出原始点，再由上一个构造方法直接构造实例，不再重复代码 let origionX = center.x - (size.wid / 2) let origionY = center.y - (size.hgt / 2) // 这里使用Point结构体的逐一成员初始化构造方法 self.init(origion:Point(x: origionX, y: origionY), size:size) &#125;&#125; 类的继承&amp;构造方法 Swift规定类中的存储属性必须在构造方法中完成初值设置，Swift提供了二种构造方法来给类的存储属性赋初值– 指定构造方法和便捷构造方法。 指定构造方法 指定构造方法就是一个普通的构造方法，语法也是init(){}的形式，同时指定构造方法将初始化类中所有的存储属性，并顺着继承链依次向上初始化基类的所有属性，实现基类的实例化。需要注意：每个类都至少有一个指定构造方法。 便捷构造方法 便捷构造方法是辅助类型的构造方法，不是类里面必须的。便捷构造方法的语法与普通的不同，在init关键字前需要加一个convenience关键字，指明其是便捷构造方法。类似 convenience init(){}这种形式。 Swift明确规定了指定构造方法和便捷构造方法之间的如何调用 指定构造方法必须直接调用其基类的指定构造方法。 便捷构造方法只能只能调用本类中的便捷构造方法。 便捷构造方法必须以调用本类中的指定构造方法来结束。 “二段式”的构造。首先通过类的构造方法来确定属性的初始值。然后在每个类使用前再一次通过实例访问属性来自定义属性的值。 构造方法的继承与重写 Swift中的子类不会默认继承基类的的构造方法，因为可能子类已经定义了更详细的构造方法。而简单的继承过来可能会导致生成出的实例不是子类的更详细的构造方法生成出来的。如果子类需要实现与基类相同的参数的构造方法，需要使用override关键字。子类不能使用继承过来的常量属性，因为已在基类中完成了初始化，不能再次更改。二个构造方法的继承规则： 规则如果子类没有任何自定义的构造方法，那么就会继承基类所有的指定构造方法。 如果子类有了基类所有指定构造方法的实现(可以像1说的那样完全继承过来的)，那么子类也会自动继承所有的基类便捷构造方法。 可失败的构造方法，构造方法可能返回nil，也就是实例化不成功的情况。使用这种语法形式 init?(){}的形式，生成实例的时候需要使用值绑定的方式来判定实例是否是nil。就相当于返回的是一个可选值。 子类可以重写基类的可失败构造方法，甚至重写成为一个不可失败的构造方法。 基类定义需要子类必须实现的构造方法使用required关键字。重写时必须也带着required关键字，此时不再需要override关键字。]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua正则相关小记]]></title>
    <url>%2F2016%2F05%2F15%2FLua%E6%AD%A3%E5%88%99%E7%9B%B8%E5%85%B3%E5%B0%8F%E8%AE%B0.html</url>
    <content type="text"><![CDATA[Lua正则表达式Lua的正则表达式不是标准的Posix的标准实现，有自己的一些标准，由于长时间不使用，最近用到一个相关的业务逻辑，在一个标签中提取价格，但是这个标签是不规则的，可能前后有很多其他字符(￥XXX priceNum XXX)，用固定长度截取显然不成，想到了用正则，最后google了一下，才搞定，但是发现很多都忘记了，这里记录一下。 相关库函数 string.find 字符串查找，匹配第一个符合条件的位置与最终位置 string.gfind是5.0中的函数，在5.1是被标记为deprecated的，在5.2被移除，替换为string.gmatch string.match 匹配第一个符合的字符串 string.sub 截取字符串的一部分 string.gsub 全局字符串替换，替换目标字符串多次，返回替换后的字符串，同时返回的匹配替换的次数 string.gmatch 全局字符串查找，匹配多次符合条件的，并返回一个迭代器，可以在一个for循环里得到所有的匹配 Lua正则元字符 字符类 % 转义符，转义其他的有特殊意义的元字符串，转义双引号(“)使用反斜杠(\) . 匹配任意字符 %a 所有字母 %b 边界匹配 如%bse，匹配以s开头e结尾中间的所有 %c 控制字符，类似响铃，退格，具体参照Wiki %d 所有数字 %l 所有小写 %u 所有大写 %p 标点符号 %s 空白字符，包括空格，四格制表，换行(\r，\n) %w 字母和数字 %x 十六进制数字 %z 表示0的字符 大写表示其补集，如%P，表示所有不是标点的。 字符集表示 使用一对中括号[]，中括号内是对应的集合，可以使用-(中划线)表示一个范围 [0-9A-Za-Z]表示所有字母与数字 匹配次数指示 指示对应的模式匹配几次 + 匹配其前面的pattern一次或者多次，按最多长匹配 * 匹配其前面的pattern0次或者多次，按最长匹配 - 匹配其前面的pattern0次或者多次，按最短匹配 ? 匹配其前面的pattern0次或者一次 匹配开头和结尾 开头，使用^，如^x，匹配以x开头的模式 结尾，使用$，如x$，匹配以x结尾的模式 捕获指定内容 使用一对小括号()，捕获指定的内容并返回，用小括号括起对应的模式串 Example 获取标签内价格 开头说的获取标签内的价格信息，就可以使用string.match匹配对应的字符串，使用小括号捕获想要的内容，使用转义符%转义价格中可能出现的小数点，小数点后可能有数字也可能是一个整数价格，使用*来匹配0个或者多个小数点后的数字，小数前是一定有价格的，不然就不是价格标签了，使用+来匹配至少一个数字，最终得到如下正则表达式： pattern = “(%d+%.%d*)” 1234local moneyLabel = "￥ 666.02 - 元"-- 获取666.02这个价格local price = string.match(moneyLabel, "(%d+%.?%d*)")print(price) -- 输出666.02 string.gsub，模式串替换 123456789101112131415161718local str = "worse is better"local dest, count = string.gsub(str, "%a+", "lua")-- 三个单词都被替换成lua，替换次数是3print(dest .. " replace count = " .. tostring(count))local gsubStr = " something with space "-- 第三个参数，捕获对应的前面第几个分组内的匹配串local trimStr = string.gsub(gsubStr, "^%s*(.-)%s*$", "%1") print(trimStr)local matchString = "1 2 3 4"-- 第三个参数是把对应前的面捕获的1个替换为4个重复的local repeatString = string.gsub(matchString, "(%d+)%s*", "%1 %1 %1 %1 ")-- 第个参数表示执行几次替换local repeatStringCount = string.gsub(matchString, "(%d+)%s*", "%1+", 2) print(repeatString)print(repeatStringCount) string.match，匹配串，首次匹配的结果，不是位置 12345local tmp = "first1 second2 thrid3"local resFromBehind = string.match(tmp, "%d", -2)local res = string.match(tmp, "%D+")print(resFromBehind) -- 输出3，最后参数指定由右侧第二字符开始匹配print(res) -- 输出first，即非数字的其他字符一个或者多个，+是贪婪模式 string.find，串查找，首次查找的位置，返回起始结束位置 123456local findStr = "phone number: 19922337755"-- 第三个参数是查找的起始位置，默认由1开始local startIndex, endIndex = string.find(findStr, "%d+", 1) print(startIndex, endIndex) -- 输出 15, 25local result = string.sub(findStr, startIndex, endIndex)print(result) -- 输出 19922337755 string.gmatch，串匹配，返回一个迭代器，多次匹配 12345678910111213local gmatchStr = "one1, two2, three3, four4, five5"-- 包含字母和数字的单词for word in string.gmatch(gmatchStr, "%w+") do print(word)end-- 只包含字母的单词for onlyLetters in string.gmatch(gmatchStr, "%a+") do print(onlyLetters)end-- 只要数字for onlyNums in string.gmatch(gmatchStr, "%d+") do print(onlyNums)end 记录完毕]]></content>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三元运算小记]]></title>
    <url>%2F2016%2F05%2F12%2FPython%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E5%B0%8F%E8%AE%B0.html</url>
    <content type="text"><![CDATA[好久没有用Python的，昨天写一个简单的Alred workflow的时候，突然用到了三元运算符，只记得刚学的时候，是用的类似于Lua的那种三元运算的实现方式(Lua没有原生的三元运算符，使用了二个逻辑运算来实现)，然后在google上找了一下，这里做一下记录。 Lua的三元运算实现方式，就是巧妙的利用了与或运算的”短路”法则。 123456789local tmp = falselocal res = not tmp and "and" or "or"print(res) // 输出"and"-- 等价于if not tmp then res = "and"else res = "or"end Lua使用的形式就是 result = condition and true_res or false_res。Lua这里这样使用不会现问题，因为Lua对于false值只有二种，nil和false是false，其余都是true。 Python一般情况下对于类似Lua的那种实现也没有太大问题 1print(True and "True" or "False") # 输出True 但是Python对于False值的规定却与Lua不同，Python认为一切空值都是False，下面的值都被认为是False，如下： False (布尔值False) None (空对象值) 等于0的数 [整型0，浮点0.0，长整型0L，复数0.0 + 0j] “”(空字符串) [](空列表) {}(空字典) ()(空元组) 那这样就会出现问题，如某个条件下想置空个列表为空，或者置为空字符串，可能得到的都是相反的效果 1print(True and "" or "False") # 输出False 这种情况下空字符串被认为是False，逻辑运算继续，or后为真，得到最终结果是”False”，与预期结果相反。 Python原生的三元运算形式，在Python2.5开始有了这个三元运算操作，形式就是： true_res if condition else false_res 真值在前，条件在中间，假值在else分支 1print("True" if True else "False") # 输出True 这时就不存在使用逻辑运算形式的问题了。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-for-Mac简要入门记录]]></title>
    <url>%2F2016%2F05%2F10%2FDocker-for-Mac%E7%AE%80%E8%A6%81%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[依据官方的Get Started的简要入门(简略翻译修改官方的Docker文档，很多信息来自官方Doc)，基于Beta版的Docker for mac(目前正在邀请测试，测试邀请链接)。 概述根据官方的入门简介，可以做到如下: 使用DockerTool工具安装Docker相关软件(可以直接使用Docker for mac略过此步) 在Docker容器中运行软件 在Docker Hub上查看镜像 创建属于你自己的镜像并在Docker容器中运行 创建Docker Hub帐号和镜像仓库 创建属于你自己的镜像 把镜像推到Docker Hub上共享给他人使用 入门前提： 会使用最基本的命令行，使用简单的命令(多多益善)，类似如何浏览目录，列出当前进程，操作文件等命令。 安装Docker直接使用使用DockerTool工具安装即可，pkg文件，需要密码向bin目录写入东西，安装完成会出lanuchpad中会现一个叫Docker Quick Start的图标，点击即可快速打开终端，可以通过输入如下命令来检测是否成功安装工具 docker run hello-world 了解镜像和容器Docker引擎的核心就是镜像和容器。 容器就是简化版本的Linux操作系统，而镜像就是加载到容器中的软件。如上面的例子中的 docker run hello-world命令，当执行这个命令的时候，Docker引擎就会做一系列下面的操作： 检查你机器的本地是否有hello-world这个镜像。 如果没有，从Docker Hub上下载对应名称的镜像 加载这个镜像到容器中，并执行它。 根据镜像构建的内容，hello-world这个镜像执行了一个简单的命令然后就退出了。 Docker镜像可以做更多更复杂的事情。比如镜像可以启动像数据库那么复杂的软件，然后等你(或其他人)添加数据，并把数据存储以供以后使用，与此同时还能服务其他人。 那么是谁构建了这个hello-world镜像呢?Docker本身不能，但是任何“人”都能。Docker引擎可以让人(或者某个组织)通过Docker镜像中创建并分享软件。使用Docker时不需要担心你的电脑能否运行Docker镜像里面的软件–因为Docker容器一定能运行它。 找到并运行whalesay镜像世界上所有的人都能创建Docker镜像，你可以通过Docker Hub来搜索这些镜像，接下来，你就需要在Docker Hub中找一个需要在入门简介中会用到的镜像 在Docker Hub的右上角搜索栏中搜索whalesay，并打开结果页。 要结果页中打开docker/whalesay这项结果。每个镜像仓库都会包含对应的镜像的相关信息，这个镜像是什么类型的软件，如何使用等。whalesay就是基于一个叫Unbuntu的Linux发行版的镜像 打开命令行(Docker Quick Start，如果有Docker for mac就是直接打开终端)，直接输入下边的命令并执行 docker run docker/whalesay cowsay boo 这个命令就是在容器中运行docker/whalesay这个镜像，然后终端会有一大堆输出，这里不贴图了，就是在本地没有找到docker/whalesay这个镜像，然后去Docker Hub拉了一份下来的过程。 运行完成后，在终端内继续输入下面的命令 docker images 会列出你在本地已有的docker镜像(带有横向标题)，当你在容器中运行Docker镜像的时候，Docker会下载你本地没有镜像到你本地保存起来，Docker只会在Docker Hub上的对应的镜像源发生变化的时候，才会再次下载对应的新镜像到本地。当然你可以自己手动删除在本地的Docker镜像。 使用更长或者更短的话，再试一下运行docker/whalesay，查看结果。 创建属于你自己的镜像通过增强docker/whalesay的功能来练习创建Docker镜像。 首先用编辑器(TextEdit或者MacVim，其他…)编写一个简短的Dockerfile。Dockerfile描述了软件如何被加入镜像文件中，它告诉软件需要用到什么运行环境或者需要运行什么命令。 打开终端，创建一个叫做mydockerbuild的文件夹，这个文件夹里就是放创建镜像需要的所有东西。进入mydockerbuild文件夹。 mkdir mydockerbuild cd mydockerbuild 创建Dockerfile文件。并在编辑器中打开Dockerfile touch Dockerfile vi Dockerfile 首先在文件中输入如下内容 FROM docker/whalesay:last FROM关键字告诉Docker你即将创建的Docker镜像是基于哪个已有镜像的。现在是基于已的docker/whalesay镜像。 接下来向镜像中加入fortunes程序，继续向Dockerfile中加入以下内容 RUN apt-get -y update &amp;&amp; apt-get install -y fortunes fortunes程序含有一个命令可以“智能的”打印出whale要说的话。所以第一步应该安装这个程序，这一行内容使用apt-get这个管理器程序安装fortunes程序。如果这对于来说非常困难，没有关系，照着一步一步做就是。 现在镜像已有了它需要的的软件程序，要做的就是当镜像加载完之后告知fortunes程序运行起来，最后向Dockerfile中加入如下内容 CMD /usr/games/fortunes -a | cowsay 这行内容就是告诉fortunes程序把对话输出发送给cowsay程序。 保存Dockerfile，现在在Dockerfile中已经有了全部的软件依赖和命令描述，现在可以准备构建一个新Docker镜像了。 cat Dockerfile确认一下Dockerfile的内容没错，通过以下命令来构建一个新镜像。 docker build -t docker-whale . 不要看错，最后还有一个句点，最后出现sucessfully build XXXX就表示构建镜像成功。构建过程需要几分钟，先了解一下构建的过程。 了解构建过程docker build -t docker-whale .这行命令通过当前目录的Dockerfile的内容，在你的机器本地构建了一个叫docker-whale的镜像。 首先Docker会确认构建所需要的所有东西都已齐全。同时会载入whale这个镜像，由于之前已经下载了docker/whalesay镜像，Docker就不会再次去下载镜像了。 接下来，开始更新apt-get包管理器，这里会显示多好条信息，数量太多，不再展示。 更新完成，开始安装新的叫fortunes的程序。 最后Docker完成构建并输出构建成功的提示信息。 运行你新构建出来的镜像这一步就要验证刚刚构建成功的Docker镜像并且加载运行它。 再次打开Docker Quick Start终端，输入docker images命令查看本地的Docker镜像，就会发现在docker-whale已经存在了。 运行如下命令 docker run docker-whale 这次就会发现whale说出的话更”智能”了，而且运行的命令也更短了，你可能会发现，这次Docker并没有下载斜体东西，就能可运行了，那是因为这个docker-whale镜像是在当前本地机器上构建而成的。 创建Docker Hub帐号和仓库这步非常简单，大部分略过 打开链接，注册Docker Hub帐号 成功注册，验证邮箱，登陆帐号 选择Create Repository，选public，然后填上必要信息点击Create就成功创建了一个仓库。 标注，推送，拉取你自己的镜像这一步里，需要标注，推送自己的镜像到刚才在Docker Hub的仓库里，完成之后再从自己的仓库里拉取对应的镜像测试一下。 标注自己刚构建出的镜像，打开终端，docker images命令查看已有的镜像，找到刚才构建成的docker-whale的镜像的IMAGE-ID这一列，记下对应的字符串 注意，当前信息的RESPOSITORY列显示的信息是不带namespace的，需要用你自己的Docker Hub帐号名称指定namespace，类似这样: ​ YOUR_DOCKERHUB_NAME/docker-whale 使用刚才记下的字符串(也就是IMAGE-ID)使用docker tag命令给给docker/whale打标签。 docker tag IMAGE-ID YOUR_DOCKERHUB_NAME/docker-whale 大写部分替换成对应的自己实际值就可以了，这时再用docker images命令查看就可以看到刚新打标签的YOUR_DOCKERHUB_NAME/docker-whale镜像了。 命令里登陆Docker Hub，如下命令 docker login —username=YOUR_DOCKERHUB_NAME —email=YOUR_EMAIL 回车根据提示输入密码就可以了 输入如下命令来将新的镜像推送到刚才创建的仓库里 docker push YOUR_DOCKERHUB_NAME/docker-whale 出现成功提示就可以在网页上打开刚才Docker Hub里刚才创建的仓库里看内容了。 测试刚push上去的镜像 因为本地已以存在了对应的docker/whale的镜像了，为了测试，这里需要将对应的本地镜像删除，使用docker rmi命令删除本地的镜像。 使用指定的文件名 docker rmi -f docker-whale 使用指定的IMAGE-ID docker rmi -f IMAGE-ID 像最开始的操作，直接使用docker run命令 docker run YOUR_DOCKERHUB_NAME/docker-whale Docker发现在本地没有对应的镜像，直接就下载对应的镜像到本地。 简要入门笔记完毕。]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftNote-9]]></title>
    <url>%2F2016%2F05%2F09%2FSwiftNote-9.html</url>
    <content type="text"><![CDATA[方法同其他面向对象语言的成员方法，细节略有不同 实例方法 属于某个类实例，与类型方法相对应，实例化某个类实例出来之后，才可以使用类实例进行调用。(结构体与枚举也可以定义方法) 123456789101112131415161718192021class Person&#123; var name:String = "Jack" var age:Int = 15 var education:String = "MiddleSchool" // instance method func introduceSelf() &#123; print("Hello, Everyone! My name is \(self.name), I am \(age) years old.") &#125; func growUp(age:Int, _ education:String) &#123; self.age = age self.education = education &#125;&#125;let p = Person()p.introduceSelf()// 第一个参数不需要外部参数名，第二个及之后的需要外部参数名p.growUp(18, "College") introduceSelf方法就是针对第个生成出来的Person的具体实例的，因为不同的person的属性是不同的。self与C++中的this意义相同，就指代当前的对象。 方法参数，Swift默认给除了第一个参数之外的参数一个外部参数名，不指定外部参数名的情况下与局部参数相同，这里Swift的默认行为，如果不想有外部参数名，可以使用_(下划线)显式忽略掉对应的外部参数名，这样就会覆盖掉Swift的默认行为。如上例中的growUp方法，显式忽略第二个参数的外部参数名。 值类型的实例方法不能修改实例属性， 结构体，枚举值类型的实例方法不能修改实例内部的属性，如果需要修改，需在方法前加可变的关键字mutating，否则会报错 1234567891011121314151617181920212223struct Rect&#123; var wid = 0, hgt = 0 mutating func modifyWid(wid:Int) &#123; self.wid = wid &#125; func modifyHgtTedt(hgt:Int) &#123; // self.hgt = hgt 这里会报错 &#125; mutating func modifySelf(wid:Int, hgt:Int) &#123; self = Rect(wid: wid, hgt: hgt) &#125;&#125;var r = Rect(wid: 100, hgt: 100)r.modifyWid(10)print(r.wid) // 输出10// 修改self的值r.modifySelf(120, hgt: 30)print(r.hgt) // 输出30 可变方法中可以直接修改self的值，也就是自身实例的值可以在可变方法中直接修改。上例中的modifySelf方法，可直接给self赋值 类型方法 区别于实例方法，不需要生成实例即可调用，属性类级别的，直接使用ClassName.StaticMethod()的形式调用即可。方法定义使用static在func关键字前面。 12345678910class StaticTest&#123; static var staticInt:String = "Static Variable" static func ClassTypeMethod() &#123; print(self.staticInt) &#125;&#125;// 直接使用类名调用StaticTest.ClassTypeMethod() 同类型差不多，如果需要子类重写对应的类型方法，不使用static而使用class关键字 下标Swift中可以自定义类的中括号的实现，类似字典和数组那样的形式，使用subscript关键字，参数没有限制(包括个数与类型都没有限制)，内部实现就像getter与setter。 下标语法 就像多了一层大括号的setter与getter实现 1234567891011121314151617181920212223class Test&#123; subscript(row:Int, col:Int, ex:String) -&gt; String &#123; set&#123; print(newValue) // newValue的值类型必须与返回值类型相同，这里是String &#125; get&#123; if row &lt; 5 &amp;&amp; col &lt; 5 &#123; return "1 2 3 4" &#125; else &#123; return "More than 5" &#125; &#125; &#125;&#125;let t = Test()print(t[5, 3, "3"])t[3, 3, "4"] = "Test" 下标使用事项 下标参数可以是变量或者变参，但是不是是inout类型的，数量类型不限，也不可以设置参数默认值。可以有多个下标实现，Swift会根据不同的入参类型进行判定调用哪一个。 继承这个特性只有类有，结构体与枚举不存在继承这一说。Swift的类继承在定义类时，类名后使用:(冒号)后面是基类名。 1234class SubClass:BaseClass&#123; // some code&#125; 基类 一个没有继承其他任何类的类就是基类，它可能不被继承，也可能被继承，上边例子里面的Person就是一个基类。 子类 通过上述语法继承一个基类，这个类就是子类，子类拥有基类的的所有特性，并且还可以继续添加子类自己的特性 123456789101112131415161718192021222324252627class Person&#123; var name:String = "Jack" var age:Int = 15 var education:String = "MiddleSchool" func introduceSelf() &#123; print("Hello, Everyone! My name is \(self.name), I am \(age) years old.") &#125; func growUp(age:Int, education:String) &#123; self.age = age self.education = education &#125;&#125;class Programmer:Person&#123; var codingSkill = "code" func codingWith(lang:String) &#123; print("DO NOT TOUCH ME, I am coding with \(lang) language!") &#125;&#125;let p = Programmer()p.introduceSelf() // 继承了Person的属性和方法，正常调用p.codingWith("Swift") // 自己添加的新行为，coding 重写 子类可以把继承过来的计算属性/属性观察器(不能同时重写setter和属性观察器，setter里就可以观察到属性变化了)，方法，下标，都按子类的规则重新实现，叫做重写。就是覆盖了基类的实现，再次调用的时候就是子类自己的实现。使用override关键字，访问基类使用super关键字，比如在重写的过程中，需要先调用一下基类的实现，可以直接使用super.implement()这种形式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Person&#123; var name:String = "Jack" var age:Int = 15 var education:String = "MiddleSchool" var address:String &#123; get&#123; return "" &#125; &#125; func introduceSelf() &#123; print("Hello, Everyone! My name is \(self.name), I am \(age) years old.") &#125; func growUp(age:Int, education:String) &#123; self.age = age self.education = education &#125;&#125;class Programmer:Person&#123; // 重写了基类的address计算属性的get override var address:String &#123; get&#123; return "Computer" &#125; &#125; var codingSkill = "code" func codingWith(lang:String) &#123; print("DO NOT TOUCH ME, I am coding with \(lang) language!") &#125; override func introduceSelf() &#123; super.introduceSelf() // 使用super来访问基类 print("... And I am a PROGRAMMER, I am changing the world!") &#125;&#125;let person = Person()person.introduceSelf()print(person.address)let p = Programmer()p.introduceSelf() // 程序员的自我介绍与Person不同了p.codingWith("Swift")print(p.address)// 重写了计算属性的getter 禁止重写 基类中使用final关键字，防止子类重写此特性。同样适用于计算属性，属性观察器，方法，下标，如果一个类不想被继承，直接在class关键字前使用final，类即不可以被继承。试图重写被final标记的属性，方法，下标，继续被final标记的类，都会直接报错。]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftNote-8]]></title>
    <url>%2F2016%2F05%2F06%2FSwiftNote-8.html</url>
    <content type="text"><![CDATA[类的属性 相当于其他编程语言中的类成员变量，在Swift中叫做属性。 存储型属性相当于普通成员，用于类实例中变量/常量，实例可以通过点号的方式来访问/修改 123456class Person&#123; var name:String = ""&#125;var p = Person()p.name = "Jack" name就是普通的存储属性，可以通过实例直接访问和修改，需要注意的是生成一个常量结构体实例，即使里面的存储属性是var定义的，也不能通过结构体实例来修改属性值，因为结构体是值类型 1234567struct Test&#123; var temp:Int32 = 0&#125;let t = Test()// 即使temp是变量，也不能用t.temp = 12来修改实例内的属性值// t.temp = 12 这里直接报错 延迟存储属性，使用lazy关键字，表示此存储属性被访问的时候才会被求值。 1234567891011121314struct LazyTest&#123; var lazyVar = 12&#125;class LazyDemoTest&#123; lazy var lt = LazyTest() var dict:[Int:String] = [:]&#125;// 此时LazyDemoTest中的lt还没有创建出来var ldt = LazyDemoTest()// 这时lt才被计算创建print(ldt.lt.lazyVar) 计算型属性不能直接通过类，结构体，枚举实例来访问/修改的属性，但是提供了一个getter与一个可选的setter来访问和修改属性的值，这样的属性叫计算型属性。只有getter的叫只读属性，因为只能获取值，不能设置值。setter不设置新值的名字时默认使用newValue这个变量就可以访问新设置的值。计算型属性一定是var定义的，因为常量不可以修改。 123456789101112131415161718192021import Cocoastruct Cube&#123; var len = 0.0 var area:Double&#123; get &#123; return len * len &#125; set(newArea) // 可以不设置新值名称，默认使用newValue &#123; print("newValue = \(newArea)") len = sqrt(newArea) &#125; &#125;&#125;var cube = Cube(len: 10.0)print(cube.area)cube.area = 200print(cube.len) 只读属性，甚至get还可以省略，直接大括号内返回语句就可以了。 12345678910111213141516171819202122class Rect&#123; var wid = 0.0, hgt = 0.0 var area:Double&#123; get &#123; return wid * hgt &#125; &#125; /* // 可以省略掉get var area:Double&#123; return wid * hgt &#125; */&#125;var rect = Rect()rect.hgt = 10rect.wid = 12print(rect.area)//rect.area = 100 // 报错，只有get，没有setter，不能设置其值 属性观察器就是在属性值设置之前/设置完被调用，这样就可以监控属性值的变化，分别用didSet和willSet，从名字上就能猜到功能。willSet传入将要设置的新值，不提供名称使用newValue，didSet传入旧的值(被设置之前的属性值)，不提供名称使用oldValue。 1234567891011121314151617181920212223242526struct Wallet&#123; var totalMoney:Float = 0.0&#123; willSet &#123; print("totalMoney = \(newValue) called from willSet") &#125; didSet(haveMoney) &#123; print("oldValue = \(haveMoney) called from didSet") if totalMoney &gt; haveMoney &#123; print("Add \(totalMoney - haveMoney)") &#125; // 如果在属性观察器里再次进行对本属性进行属性，这会替换掉之前设置的值 // totalMoney = 10.0 // 此时实例中的totalMoney已经变成了10 &#125; &#125;&#125;var wallet = Wallet(totalMoney: 100)wallet.totalMoney = 120 // willSet和didSet都被调用// 输出// totalMoney = 120.0 called from willSet// oldValue = 100.0 called from didSet// Add 20.0 类型属性也就是类型C++的静态成员变量，不属于实例，属性类级别所有，用类名来访问，Swift也相同，同样是用static关键字来定义，className.staticVarName方式来访问和修改，同样也支持计算属性，针对类而言，如果子类需要重写父类属性实现，需要使用class关键字来代替static关键字。 12345678910111213class StaticDemo&#123; static var staticInt:Int = 0 static var staticString:String&#123; return "StaticString" &#125; // 支持子类重写此属性 class var needOverrideVariable:Bool&#123; return false &#125;&#125;StaticDemo.staticInt = 12print(StaticDemo.staticString)]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftNote-7]]></title>
    <url>%2F2016%2F05%2F05%2FSwiftNote-7.html</url>
    <content type="text"><![CDATA[枚举 枚举语法 enum关键字接大括号，内部case分隔不同的枚举值，也可以多个枚举值在同一个case后，用逗号分隔，在Swift里枚举是一种自定义类型，Swift对其功能进行了增强 123456789101112enum Color&#123; case RED case GREEN case BLACK case GRAY&#125;enum RecommondType&#123; case PERFEECT, RECOMMOND, QUALIFIED&#125;var color = Color.RED 使用点号访问枚举值，确定其类型后，可以直接使用点号后加枚举值的形式 1color = .BLACK // 前面已知道color是Color类型的 switch 匹配枚举的值 必须匹配所有枚举值的情况 12345678let c = Color.GRAYswitch c&#123;case .RED: print("Color id Red")case (let color): print(" handle all ")&#125; 关联值，都知道C语言的枚举默认都是整型的，指定的数字开始依次向后加，Swift增强了关联值，每个不同的枚举值可以关键完成不同的值类型，比如可以关联字符串，整型，元组等 12345678910enum ColorShow&#123; case ColorString(String) case ColorDec(Int, Int, Int) case ColorHex(Int)&#125;var red = ColorShow.ColorHex(0xFFFF7777)red = ColorShow.ColorDec(255, 0, 0)red = ColorShow.ColorString("Red") 一种颜色的三种不表现方式，分别是字符串，十进制数，十六进制数，类似于C语言的联合，同一时间只有一个存在。 原始值，枚举在定义是可以有必须类型相同的初始值，如果枚举定义时显式指定枚举是整型或者字符串时，原始值会隐式进行赋值，整型会默认依次递增1，字符串会默认是枚举值的字符串值 12345678enum Order:Int&#123; case zero, fir, sec, thir // 依次是 0, 1, 2, 3&#125;enum Dir:String&#123; case W, E, S, N // 依次是 "W" "E" "S" "N"&#125; 用原始值初始化新枚举值 如果使用原始值创建了枚举，那枚举就会自动生成一个带rawValue的初始化方法，用这个初始值去枚举定义里找对应的枚举值，有可能找不到，所以返回的是可选值，需要在拿到返回值时值绑定判定一下非空，可以使用这个初始化方法创建一个新枚举实例 12345678910111213141516enum Order:Int&#123; case fir, sec, thir&#125;enum Dir:String&#123; case W, E, S, N&#125;if let up = Dir(rawValue: "U")&#123; // some code&#125;else&#123; print("Up dir not found")&#125; 类/结构体概念 定义类/结构体，这与C++是一样的，都是使用class和struct关键字，并且Swift对结构体的功能做了增强，定义一个类或者结构体，class/struct关键字后接大括号，内部定义属性/方法 1234567891011class DemoClass&#123; var demoMember:String = "DefaultValue"&#125;struct DemoStruct&#123; let demoMember:Int32 = 42 var noneDefaultValue:Bool&#125;// 可以定义所有的基本类型，自定义类型等在class和strut里 与其他面向对象语言相似，都使用类名使用大写驼峰命名法，属性与方法使用小写驼峰命名法，具体内容可参照Wiki。 实例化类/结构体 与C++类似，类名(参数表)的形式 12var dc = DemoClass()let ds = DemoStruct(noneDefaultValue:false) // 结构体默认提供构造方法带未初始化内部成员 成员访问(属性访问) 使用点号.，常量属性初始后不可更改，常量实例不可对其属性进行赋值 12dc.demoMember = "assignStringFromExternal"// ds.noneDefaultValue = true // 报错 ds是常量 结构体默认提供了结构体内属性的初始化构造方法，类并不提供 12345678910struct Person&#123; var age:Int16 = 0 var name:String = "" var address:String = "" var height:Float = 0.0&#125;// 并不需要在结构体内部定义初始构造方法，就可以直接调用let p = Person(age: 27, name: "bugcode", address: "BeiJing", height: 65.5) 如果将上文中的struct改为class，下面的实例构造处就会报错，因为类内部并没有定义对应的构造方法。 类是引用类型，结构体和其他的Swift的基础类型(包括集合)都是值类型，Swift引入了恒等去处符来确定二个变量/常量是否引用了同一个类实例，分别是===/!== 12345var dcc = dcif dcc === dc&#123; print("dcc same as dc")&#125;]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo多说评论踩坑记录]]></title>
    <url>%2F2016%2F05%2F05%2FHexo%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[Fexo的主题的评论数量显示的Hexo默认的评论系统disqus，国内还是用多说的多一些，Fexo主题集成了多说插件(其实就是内嵌的一段js代码)，但是并不是用的这个路径下的themes/fexo/layout/_partial/duoshuo.ejs而包含的component中的duoshuo.ejs，对web前端不了解，尝试修改了一下，因为查看多说的官方文档的时候，说评论数依据的是data-thread-key（标识文章的唯一ID），一个样式表中的class的名字，而Fexo真正包含的那个duoshuo.ejs并没有设置data-thread-key的值，所以手动改一下，我改成了page.path，文章的路径用来做唯一key(年月日加文章名，重复的机会不太大)，这样重新hexo clean再hexo g，就能生成唯一data-thread-key值了。 Fexo默认是评论次数是显示的disqus的，没有对多说进行处理，这里改动一下themes/fexo/layout/_partial/路径下的article.ejs的20行左右，将其自定义的disqus的评论数改为多说的评论数量显示，根据多说文档，加入一个带data-thread-key的class的span标签即可: 123456&lt;% if (theme.duoshuo_shortname &amp;&amp; theme.url)&#123; %&gt; &lt;span&gt; &lt;i class=&quot;icon-comment&quot;&gt;&lt;/i&gt; &lt;a href=&quot;&lt;%= theme.url + url_for(page.path) + &apos;#ds-thread&apos; %&gt;&quot;&gt;&lt;span class=&quot;ds-thread-count&quot; data-thread-key=&quot;&lt;%= page.path %&gt;&quot; data-count-type=&quot;comments&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;% &#125; %&gt; 还有一个需要注意的是，这里的data-thread-key与刚才设置的data-thread-key要完全一致(针对每篇文章)，同时在主题的_config.yml中定义的duoshuo_shortname要与申请的多说二级域名的完全一致，不然也会导致评论数不正确，可以先创建一个简单的md生成一个页面，然后回复一个评论，再去多说的管理后台去看对应的data-thread-key是否正确，只有key和short完全一致，对应的文章才能获取正确的评论数。 踩坑完毕！]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh+iTerm2折腾记录]]></title>
    <url>%2F2016%2F05%2F03%2Fzsh-iTerm2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[一直就感觉Mac自带的Terminal很好用，可以开多个Tab，功能也够，自从开始用Hexo倒腾博客之后突然感觉自带Terminal的窗口切换功能不够强大了，然后去Google了一下，然后就发现了iTerm2，之前也在一些其他博客中看到iTerm2的推荐，但是一直没在意，这次果断去官网下载了一个，开源免费。用了一会感觉特别不错，可设置的选项比自带的多好多，而且关联的文章看了下去还有oh-my-zsh这个zsh的配置的框架，还有好看的主题，一番折腾，终端大致变成了这个样子 iTerm2 官网下载，按自己需求设置一下，比如设置隐藏显示的快捷键，设置主题，设置字体，设置字体里需要额外说明一下，如果是使用上面截图的主题agnoster，就需要一个叫做Powerline的打补丁的字体，不然无法正常显示上面右侧那个实体箭头和主题内的一些特殊字符，倒腾过Vim的Powerline或者Airline状态栏应该都知道这个补丁字体，传送门可以在这里直接下载已经打好补丁的字体，比如Melon for powerline。总之可以设置得合自己心意就好，iTerm2只是个外壳，真正的还得是zsh，二个搭配起来真好用的一塌糊涂。几个常用快捷键： 多Tab操作 CMD + T 分屏 CMD + D 自定义的显示与隐藏iTerm CMD + . 看看光标在哪儿 CMD + / 选择Tab CMD + Tab窗口数字 用Alfred的还有另一个问题，就是Alfred快捷执行终端命令时，如果不是默认的Terminal的需要自己写一下AppleScript来执行自定义的Terminal的逻辑，万能的git早就有对应的repository了，传送门，按ReadMe进行操作就可以，里面甚至还有操作视频和gif，真是贴心！ 12# 最新版本是2.9 终端中输入下面的命令，弹出框允许即可，然后对应的applescript代码就在剪贴板curl --silent 'https://raw.githubusercontent.com/stuartcryan/custom-iterm-applescripts-for-alfred/master/custom_iterm_script_iterm_2.9.applescript' | pbcopy Zsh 切换zsh为默认shell Shell的一种，Mac默认的是bash，还有诸如csh，sh，ksh等，Mac默认已经有了zsh，可以cat一下/etc/shells来看一下当前一共有几个可用的shell，还可以通过echo $SHELL的回显来查看当前用的是哪个shell。现在要切换到zsh，输入以下命令： 1chsh -s /bin/zsh 重启终端就可以看到变化了，再次echo $SHELL，应该就是zsh了。 安装oh-my-zsh配置框架 可以通过git直接来clone repository 1234# 将oh-my-zsh克隆到本地的用户目录下的/.oh-my-zshgit clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh# 按oh-my-zsh的ReamMe将模板的zshrc拷贝一份到用户目录cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 也可以使用wget的方式，这样一步到位，不需要自己指定目录，拷贝zshrc了 123sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"# 或者wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 这步完成，就会在用户目录下看到.zshrc文件和.on-my-zsh目录了。 配置基本的oh-my-zsh信息 第一步当然是设置主题，直接vi ~/.zshrc，定位到ZSH_THEME行，设置ZSH_THEME=”agnoster”，zsh默认目录是不带颜色的，在.zshrc末尾加上 1export LSCOLORS="exfxcxdxbxexexabagacad" 同时将原bash用的各种alias都移到这里，因为原来的alias是属于bash的，zsh里需要重新alias一下命令。 到这步，如果字体没问题的话，大致的样子就是上文的图示的样子了。 继续自定义主题 默认agnoster主题的目录是显示全路径的，进入的路径越深，后面的就越长，看起来很不爽，对个人来说没啥必要，改一下主题的配置文件，只显示当前目录，并修改一下背景和前景色，定位到~/.oh-my-zsh/themes目录下，编辑器打开agnoster.zsh-theme，找到prompt_dir函数，修改如下： 123prompt_dir() &#123; prompt_segment 6 black '%c' # 6和black分别是前景和背景色，这里是上图我的配置&#125; 这时重启iTerm2就可以看到目录不是全路径了，主题颜色也改了。 默认agnoster主题每行的最前面显示的”userName@localhost”的形式，看了一下git上对于agnoster的说明，可选的配置有一项是DEFAULT_USER项(在.zshrc定义DEFAULT_USER项)，可以显示自定义的字符串，但是也不如意，这里自定义一下，同样修改主题内部的函数实现，如果找到DEFAULT_USER项时，不显示其他只显示其对应的字符串，同时设定前景背景，定位到~/.oh-my-zsh/themes目录下，编辑器打开agnoster.zsh-theme，找到prompt_context函数，修改如下： 123456prompt_context() &#123; if [ $DEFAULT_USER ]; then prompt_segment blue white "%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$DEFAULT_USER" #只显示自己定义的字符串 fi&#125;# 如果有其他显示需要可以继续在这个函数里elif分支继续改写 保存修改，重启iTerm2，就可以看到对应的最前面的字符串已经改为在.zshrc里定义的DEFAULT_USER的值了，并且是蓝底白字。 其他想自己自定义的还可继续改写里面的函数进行自定义配置 zsh插件 zsh自带的插件是git且只有这一个，另一个好用的的插件是zsh-syntax-highlighting功能是shell当前可用的命令都高亮显示，绿色表示命令可用，橙色表示打错或者命令不可用。安装方法参照git里的ReadMe，进到~/.oh-my-zsh/plugins目录，执行如下： 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 完成之后再在~/.zshrc里的plugin行最后填上zsh-syntax-highlighting插件名字 1plugins=(git zsh-syntax-highlighting) 重启iTerm就可以试着敲命令看效果了。到此终端就与上图完全一致了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SwiftNote-6]]></title>
    <url>%2F2016%2F05%2F02%2FSwiftNote-6.html</url>
    <content type="text"><![CDATA[闭包Swift支持闭包，相当于其他函数里面的匿名函数的意思。经常是在一些需要传递给其他函数的参数也是一个函数类型的时候，而这个需要被传递的函数又包含的代码是短小的。 创建闭包 闭包语法 形式就是{(parameter list)-&gt; return type in function implements} in关键字用来分隔函数体与函数类型 1234567891011121314151617181920212223// 用之前函数排序那个例子func sortIntArray(inout array:[Int], compare:(Int, Int)-&gt;Bool)&#123; for i in 0 ..&lt; array.count - 1 &#123; for j in 0 ..&lt; array.count - 1 - i &#123; if compare(array[j], array[j + 1]) &#123; let tmp = array[j] array[j] = array[j + 1] array[j + 1] = tmp &#125; &#125; &#125;&#125;var intArray = [1, 3, 10, -1, 100, 99]// compare后的参数就是闭包的基本形式，这里不再像之前那样再写一个短小的比较函数// 直接使用&#123;&#125;定义一个闭包就可以，效果与之前的lessFunc相同sortIntArray(&amp;intArray, compare: &#123;(fir:Int, sec:Int)-&gt;Bool in return fir &gt;= sec&#125;)print(intArray) 除了in和func关键字，还有函数名基本与定义一个函数类似。 闭包形式简化 已知的函数类型可以省略函数类型，因为Swift可以自动推断对应的函数类型，只需要知道对应的局部参数名称即可 12345// 上例中的compare是明确知道函数类型是(Int, Int)-&gt;Bool类型的// 上文中的闭可进一步简化成下面的形式sortIntArray(&amp;intArray, compare: &#123;(fir, sec) in return fir &gt;= sec&#125;)// 甚至参数列表的小括号也可以不要sortIntArray(&amp;intArray, compare: &#123;fir, sec in return fir &gt;= sec&#125;) 闭包还可以进一步简化，Swift可以隐式的推断单行表达式的返回结果，如上文中的compare参数，需要一个Bool的返回值，而闭包的函数体只有一个单行的表达式，所以这里可以继续把return关键字省略 12// 进一步省略如下sortIntArray(&amp;intArray, compare: &#123;(fir, sec) in fir &gt;= sec&#125;) // 去掉return关键字 还可以再次简化，Swift支持闭包中的参数缩写，即对应使用$ + 对应参数列表中的位置来代表对应的参数列表中的局部参数，比如上文中的fir和sec可以使用 $1和$2来代替，这样就可以把局部参数名称的声明也去掉了，没有函数类型，所以也就不需要in关键字了 12// 参数名称缩写，进一步简化sortIntArray(&amp;intArray, compare: (&#123;$1 &gt;= $2&#125;) 尾闭包当闭包表达式是一个参数的最后一个参数时，可以将闭包的{}部分放在函数调用的函数列表之外，以此来增强函数体实现的可读性。 多个参数的尾闭包 12345// 上文的例子就是一个尾闭包，闭包表达式是函数参数的最后一个参数// 可以这样进行书写sortIntArray(&amp;intArray)&#123;(fir:Int, sec:Int)-&gt;Bool in return fir &gt;= sec&#125;// 最后的简化形式，按尾闭包来写sortIntArray(&amp;intArray)&#123;$1 &gt;= $2&#125; 只有一个参数的尾闭包，甚至还可以去函数调用的小括号去掉，直接接上闭包的{} 12// 如内置的sort函数numbers.sort&#123;n2 &gt;= n2&#125; // sort只接受一个函数类型 值捕获闭包可以捕获其上下文中的变量/常量，即使出了对应的变量/常量已经出了对应的作用域，也能正常保持该值的引用和修改，类似像在一个函数返回另一个嵌套的函数，这个嵌套的函数就可以保持住在原函数中变量/常量的值，并且Swift会全权对闭包内存进行管理。 123456789101112131415161718192021func makeIncrementByNum(num:Int)-&gt;()-&gt;Int&#123; var sum = 0 func increment()-&gt;Int &#123; sum += num print("increment = \(sum)") return sum &#125; return increment&#125;// 值按1递增let makeInc1 = makeIncrementByNum(1)makeInc1() // 1makeInc1() // 2// 值按10递增，与makeInc1不重合不冲突let makeInc2 = makeIncrementByNum(10)makeInc2() // 10makeInc2() // 20 闭包是引用类型闭包无论赋值给几个变量或者是常量，闭包内的变量/常量值都是对应函数的引用，不会随着赋值进行拷贝，所以无论你将同一个闭包赋值给几个变量/常量，还是原来的引用 123// 如上例中的makeInc1再次赋值给makeInc2var makeInc3 = makeInc1makeInc3() // 3 不会产生一个新值的拷贝，因为是原闭包的引用 逃逸/非逃逸闭包 非逃逸闭包 非逃逸闭包的意思就是闭包传入一个函数中，函数执行完了，这个闭包也就不再起作用了，而逃逸闭包正好相反。Swift中的闭包默认是逃逸的，如果要使一个闭包是非逃逸闭包，在传入函数的参数前使用@noescape标签 12345// 上文中sortArray，使compare是非逃逸闭包func sortIntArray(inout array:[Int], @noescape compare:(Int, Int)-&gt;Bool)&#123; //...&#125; 逃逸闭包 使闭包逃逸出函数的执行体的办法是将闭包存到一个外部的集合里(如数组，集合)，在函数返回的时候再调用对应的集合里的闭包代码，这时如果将对应函数参数标为@noescape的话就会被Swift检测到，会报错。 123456789101112// 保存要escape的闭包var funcDict:[String:()-&gt;String] = [:]func testEscape(f:()-&gt;String)&#123; funcDict["testEscape"] = f print("testEscape function execute completed")&#125;// 先输出testEscape function execute completed// 再输出closure in testEscapetestEscape&#123;return "closure in testEscape"&#125;print(funcDict["testEscape"]!())]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记]]></title>
    <url>%2F2016%2F05%2F02%2F%E6%9D%82%E8%AE%B0.html</url>
    <content type="text"><![CDATA[5.1在家宅了三天，每天都会打二次羽毛球，好久没这么运动过了，出出汗的感觉真好，当了码农都快坐成一个胖子了-_-!，尤其是忙成狗的时期，一坐就是几个小时，总感觉自己像个佛爷! 在Kindle上又看了一遍韩寒的文集《青春》，就是他的博客文集，也算回忆了一下自己屌丝的大学时代，新买的据说是高分的《无声告白》看了半章就看不下去了总感觉是翻译的问题，总结了一下自己还是喜欢看那个叫《一个也不正经》那种扯淡的闲书，再就是看看技术类的书了，上周网上有活动买了十来本，其中有一套《被禁止的知识》，本以为是多么高深的知识，到手翻了一下才知道，这就是小时候看的『未解之迷』系列，怪不得被同事鄙视了。看了一个叫《彗星来的那一夜》的电影，看完了脑袋懵，上网找了解析， 看完了之后睡觉前总是神神叨叨的。 一直不知道Kindle有截屏的功能，同时按住屏幕的二个对角点，就截图到Kindle的根目录。之前还一直用手机照和别人分享文字片段。 Vim找好到了一个好用的插件smartim(Vim里智能切换输入法)，每次打开Vim写东西的时候都会有这个问题，进入Insert模式的时候有可能要写注释之类的，要切换成中文输入法，然后又马上要回到Normal模式，这时候在中文输入法Normal模式的时候就会各种按键错乱的问题，smartim就是在回到Normal模式的时候自动切换成英文输入法，回到Insert模式的时候再回到原来的输入法状态，貌似目前只有Mac上能用，因为用了一个Mac的切换输入法的api。 某社上买了一件众筹的Vim短袖，虽然不是Vim大神，但是也用了五六年了，程序员的情怀别人好像理解不了。一点不好的就是背上是!wq，我还是喜欢help 42，没错就是这个德性的😀 找到了一个非常好的免费提供各种Retina高清风景壁纸的国外的网站，而且质量特别好(个人看法)，网站叫InterfaceLift，现在有个毛病，没事儿的时候就爱找找壁纸，总有一种七八十岁老爷爷过年在地摊上挑年画的即视感😂。 Markdown编辑器typora，简约好用，一生推，这篇和之前的包括以后的blog都是用这个编辑器写的。 Alfred 3已经发beta测试邀请了，mega授权现在还是有些好处的。 喜欢上了Nightwish的《I want my tears back》，译名相当文艺—《悲伤逆流》，每天各种单曲循环。 前天CloudMagic(邮件客户端)的Mac版本限免了(原价￥128)，一直在手机端的，简约好用，知道了Mac版本限免一路小跑回家下载了，一直用正版软件，感觉这样又赚了不少^_^ 有一些小事儿有些是该记一下的，不然以后都不知道在哪儿找到回忆啥的。岁数大了容易怀旧😟。]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftNote-5]]></title>
    <url>%2F2016%2F05%2F01%2FSwiftNote-5.html</url>
    <content type="text"><![CDATA[函数函数做为抽象的最基本构成元素，几乎是编程语言里绝不可缺少的。Swift的函数足够灵活，可以有各种使用方式。 函数定义和调用 函数定义 函数定义使用func关键字，后跟函数名，其后是参数小括号，内部是参数列表，如果有返回值，后接一个-&gt;(一个中划线后一个右尖括号)，其后接返回值类型，下面加上大括号内部加上实现，就是一个完整的函数体。 1234func hasRetVal(name:String) -&gt; String&#123; return name + "! Welcom to Earth!"&#125; 函数调用 调用方式同其他语言类型，直接使用函数名小括号里加参数列表的形式调用 123// 二个函数调用都输出对应的欢迎语noneRetVal("John")print(hasRetVal("Nick")) 参数与返回值 参数 无参数，一个参数，多个参数三种，无参数的情况直接小括号留空即可，一个参数的直接在小括号内写明参数名与类型即可，多参数的用逗号分隔 123456789101112func noneParam()&#123; print("None parameter function")&#125;func oneParam(param:String)&#123; print("Have 1 parameter")&#125;func mulParam(para1:Int, para2:String, para3:Bool)&#123; print("multiple parameters function")&#125; 参数名称，(外部参数名与局部参数名) 函数都有一个外部参数名，意为由外部调用函数时候传参指定的参数名，局部参数名就是在函数体内部使用的参数名。局部参数必须不同，外部参数名可以相同，但是为了区分尽量外总参数也不同，通常的情况，不指定外部参数名的情况下，第一个参数省略参数名，后面的由局部参数名来当外部参数名，函数体显式指定外部参数名的时候，调用的时候必须指定外部参数名， 如果想忽略掉后面的外部参数名，在定义函数的时候，使用_(下划线)显式指定此参数需要指定外部参数名。 123456789101112131415// 指定外部参数的情况下，调用必须使用外部参数名func externalFuncName(externalName localName :String, externalFlagName flagName:String)&#123; print("localName = \(localName) flagName = \(flagName)")&#125;// 调用的时候必须指明外部参数名externalFuncName(externalName: "Name", externalFlagName: "1")// 上面的例子中多参数函数，如下调用方式mulParam(1, para2: "Swift", para3: false)// 此处第二个参数忽略掉外部参数名，直接使用ignoreExternalParamName("str", 1)调用func ignoreExternalParamName(first:String, _, second:Int)&#123; &#125; 默认参数 像C++一样，Swift也提供了默认参数，即函数在调用的时候如果不传实参，函数体会使用默认参数的值，虽然Swift不像C++那样默认参数必须在最后，写的时候也最好将默认参数放在最后，这样不会导致非默认参数的传参顺序不会错乱。 123456789101112// 可以使用这种定义方式，但是不建议func defaultValFunc(first:String, second:Bool = false, third:Int)&#123; &#125;func gotoSomeWhere(location:String, date:String, isDrive:Bool = false)&#123; print("我想在\(date)\(isDrive ? "开车" : "坐地铁") 去\(location)")&#125;gotoSomeWhere("三亚", date: "2016年5月1日")gotoSomeWhere("长城", date: "2016年6月1日", isDrive: true) 变长参数 Swift定义长度不定的参数，使用…，0个或者多个参数值，前提是相同类型的参数，函数体内部可以像通过访问同类型的数组一样访问变长参数 123456789101112131415161718func getAverage(varParamList:Int...) -&gt; Float?&#123; if varParamList.isEmpty &#123; return nil &#125; var sum:Int = 0 for num in varParamList &#123; sum += num &#125; return Float(sum) / Float(varParamList.count)&#125;// 通过可选值绑定来获取平均值if let avg = getAverage(1, 2, 4, 5, 6, 7)&#123; print("average = \(avg)")&#125; 输入输出参数，类似C++的引用，即在函数体内部需要修改实参的值，使用inout关键字修饰变量，并且在传实参的时在变量前使用&amp;符号，实参类型只能是var声明的，也就是只能是变量，常量和字面量是不可以传参给inout修饰的参数值的，最常用的例子就是交换二个数 12345678910func swap2Val(inout param1:Int, inout param2:Int)&#123; let tmp = param1 param1 = param2 param2 = tmp&#125;var p1 = 12var p2 = 14swap2Val(&amp;p1, param2: &amp;p2) 返回值 无返回值，一个返回值，多个返回值三种情况，无返回值的情况不需要在函数定义用箭头标明返回值，一个返回值，直接由箭头处标明返回值类型，多个返回值使用元组，且内部标明类型 12345678910111213141516171819202122232425262728293031323334func getOneMax(array:[Int]) -&gt; Int&#123; var max:Int = 0 for num in array &#123; if num &gt; max &#123; max = num &#125; &#125; return max&#125;func getMinAndMax(array:[Int]) -&gt; (min:Int, max:Int)&#123; var min, max:Int min = Int.max max = Int.min for number in array &#123; if number &gt; max &#123; max = number &#125; if number &lt; min &#123; min = number &#125; &#125; return (min, max) // 不需要再次在这里进行元组内部元素名称指定，在函数返回处已指定&#125;getOneMax([1, 10, -1, 100])let tpl = getMinAndMax([90, 100, 1000])print("\(tpl.min)") 可选元组的返回类型 实际编程中经常会遇到这种情况，就会返回多个的值元组可能为空的，这时候需要将元组指定为可选类型，这样在返回的时候使用可选绑定来确认是否返回值为空，上面的例子可以改为如下： 1234567891011121314151617181920212223242526func getMinAndMax(array:[Int]) -&gt; (min:Int, max:Int)?&#123; if array.isEmpty &#123; return nil &#125; var min, max:Int min = Int.max max = Int.min for number in array &#123; if number &gt; max &#123; max = number &#125; if number &lt; min &#123; min = number &#125; &#125; return (min, max)&#125;if let tpl = getMinAndMax([90, 100, 1000])&#123; print("\(tpl.min)")&#125; 函数类型Swift中函数是first class， 可以做为变量传递，也可以做为函数参数和返回值，函数是有类型的，函数类型由参数列表和返回值来确定的，如(Int, Stirng)-&gt;Bool就代表参数是Int和String返回值是Bool的函数类型，这以使用这种类型创建一个变量，然后将某一个实现了的函数赋值给这个变量，然后就可以通过这个变量来调用那个函数 作为变量，函数类型的变量 123456789var add2Func:(Int, Int)-&gt;Intfunc funcAdd2(fir:Int, _ sec:Int)-&gt;Int&#123; return fir + sec&#125;add2Func = funcAdd2add2Func(1, 2) // 相当于调用funcAdd2 作为函数参数 同变量差不多，只不过是写在另一个函数的参数列表里， 如同C语言的函数指针 123456789101112131415161718192021222324func lessFunc(p1:Int, _ p2:Int)-&gt;Bool&#123; return p1 &lt;= p2&#125;func sortIntArray(inout array:[Int], compare:(Int, Int)-&gt;Bool)&#123; for i in 0 ..&lt; array.count - 1 &#123; for j in 0 ..&lt; array.count - 1 - i &#123; if compare(array[j], array[j + 1]) &#123; let tmp = array[j] array[j] = array[j + 1] array[j + 1] = tmp &#125; &#125; &#125;&#125;var intArray = [1, 3, 10, -1, 100, 99]sortIntArray(&amp;intArray, compare: lessFunc) // 函数作为比较的参数传入另一个函数中print(intArray) 作为另一个函数的返回值，同时包含了嵌套函数，可以在一个函数内定义另一个函数并将这个函数返回，如果变量赋值一样，返回后赋值给变量，可以直接用变量来调用这个函数内部定义的嵌套的函数 123456789101112func makePowerOf2() -&gt; (Int)-&gt;Int&#123; // 生成一个计算二次方结果的函数 func power2(num:Int)-&gt;Int &#123; return num * num &#125; return power2&#125;let power2 = makePowerOf2()print( (power2(12))) // 144]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftNote-4]]></title>
    <url>%2F2016%2F04%2F27%2FSwiftNote-4.html</url>
    <content type="text"><![CDATA[for语句Swift对for语句进行了增强，不但有C语言里那种普通形式的三段式的for循环，还增加了for in这种区间式for循环 常规for循环，同其他语言三段式的for循环，形式相同，只不过Swift省略了中间的括号 1234for var i = 0; i &lt; 10; i += 2&#123; print("output same 5 times")&#125; for .. in形式的循环，可以遍历数组，字典，集合，也可以遍历一个区间，有点类型于lua的for in 语法形式 区间内循环 1234for index in 1 ..&lt; 10&#123; print("index = \(i)")&#125; 这里的index不需要let或者var声明，每次迭代都对对index自动赋值，一直到区间结束。 集合的遍历 12345let dictionary:[Int:String] = [1:"Swift", 2:"bugcode", 3:"Github"]for (key, val) in dictionary // 以元组的形式拿出数据&#123; print("key = \(key) value = \(val)")&#125; 遍历字符串，与遍历集合类似 12345var string:String = "Swift Demo"for char in string.characters&#123; print("single character = \(char)")&#125; while 语句与C形式相同，只是去掉了括号，类似的还有repeat .. while，与C语言的do .. while形式相同，也是至少执行一次 While 1234567var count = 0var summary = 0while count &lt; 10&#123; summary += count count += 1&#125; repeat .. while 1234repeat&#123; print("execute 1 time at less")&#125;while false 条件语句 if语句 与C语言形式相同，也只是省去了括号 12345678910111213let flag = 1if flag == 1 // 这里必须是一个bool值&#123; print("flag == 1")&#125;else if flag == -1&#123; print("flag == -1")&#125;else&#123; print("flag == \(flag)")&#125; switch 语句 Swift对switch语句进行了非常大的增加，不仅仅可以对相同与否作比较，还支持各种类型的各种形式的比较与操作。包括where子句，区间对比，元组匹配等 常规switch，Swift的switch的case也不像C语言那样需要手动加break，不加break就会一直贯穿下去，如下： 123456789101112int x = 10;switch (x)&#123; case 1: // 这里即是隐式的贯穿 case 2: case 3: printf("x == 1 or x == 2 or x == 3"); break; // 必须手动加break，不然会一直贯穿到下一个case case 4: default: printf("default");&#125; Swift不存在隐式的贯穿，且必须有default分支，不然会有语法错误，每个case和default下必须有可执行的语句，否则也会报语法错误，如果想要case贯穿下去，则需要显式指定，使用fallthough关键字，可以在case后有n个备选值，这样来达到某些情况的贯穿需求 1234567891011121314151617var switchTest = 1switch switchTest&#123;case 1: print("1") fallthrough // 显式的贯穿，case 2也会执行case 2: print("2")case 3: print("3")case 4: print("4")case 5, 6, 7: // 多个匹配值，都会匹配到这个case print("5 or 6 or 7")default: print("default case") // default必须存在&#125; 区间匹配的switch 123456789switch switchTest&#123;case 1 ... 4: print("1 &lt;= \(switchTest) &lt;= 4")case 5 ..&lt; 10: print("5 &lt;= \(switchTest) &lt; 10") // 进入这个casedefault: print("defualt")&#125; 元组匹配，Apple开发者官网上的例子非常好，直接移过来，可以匹配具体的某一个元组，也可以匹配二个区间的元组，如果元组内某个值要匹配任意值，就使用_(下划线)来表示任意值 123456789101112var point = (1, 1)switch point&#123;case (1, 2): // 匹配某个具体点 print("point (1, 2)")case (-2 ... 2, -2 ... 2): // 匹配一个区间 print("in range -2 -&gt; 2")case (_, 1): // 只匹配第二个值 print("just matching y")case (_, _): // 匹配任意， 因为此处已能处理所有情况，所以这个switch可以没有default print("match any point")&#125; case中的值绑定和where子句，可以在case语句中对匹配的值进行赋值给一个临时变量/常量，然后可以在case语句中直接引用这个变量/常量，where子句相当于是针对值绑定的做了一个更深入的条件匹配，这里就能体现出switch不仅仅只能做一般的普通比较，可以自定义各种条件来匹配case 123456789101112point = (2, 5)switch point&#123;case (1, let y): // 第二个值绑定到y上，这个case里就可以使用y print("point (1, 2)")case (let x, 1) where x % 2 == 0: // x绑定到了第一个值上，且使用where子句过滤掉x不是2的倍数的值，相当是case的加强条件 print("just matching y")case (let x, let y) where x + y == 7: // 二个值分别绑定在了x和y上，匹配x + y == 7的元组 print("x + y == 7")default: print("default handler")&#125; 循环条件转移语句 break 常规用法与C语言相同，中断一个循环或者switch语句，跳到循环体或者switch大括号的下一句代码继续执行。通常用在switch的情况就是想忽略某个分支而不想写无用的语句，case语句里就可以直接写break，比如default里不想处理时，就可以直接default中写break语句直接忽略掉default。 带标签的break，可以为某个循环或者switch指定标签，而break后带一个标签，显式指定要中断哪个循环或者switch labeName: for i in range break labelName // 显式指定要中断的循环体，直接跳出对应的标签的循环体去下一行执行 continue 常用用法也是与C语言相同，直接跳过本次循环，继续下一次循环。 continue也有与break相同的带标签的用法，意思就是直接开始标签所标示的的循环的下一次循环 123456789101112outerLabel:for i in 1 ... 5&#123; print("outter loop \(1)") for j in 5 ... 10 &#123; print("inner loop \(j)") if j == 6 &#123; continue outerLabel // 内部循环不再往后进行，直接开始下次外层循环 &#125; &#125;&#125; ​]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftNote-3]]></title>
    <url>%2F2016%2F04%2F26%2FSwiftNote-3.html</url>
    <content type="text"><![CDATA[运算符基本的运算符与C语言无二致，并且对很多地方做了增强。 基本加减乘除，取正负，逻辑运算，组合赋值，比较运算，自增自减，三元运算 均与C语言完全一致，且swift加了类型数据溢出的检测。运算结果超出类型的最大值会给出提示 12let addNum = Int32.maxvar res:Int32 = addNum + 1 // 这里会给出提示，因为res已放不下Int32的最大值 + 1的数据 赋值运算的形式与C语言相同，但是swift的赋值不会返回值，也就是swift里不能像C语言中一样进行连续赋值，也不能在if判定里做赋值操作。 12345var res = 1var assign:Intif assign = res // 这里会报语法错误&#123;&#125; 增强的取余操作，可以对浮点数进行取余 12var res = 8 % 2.5 print("remainder = \(res)") // 此时res == 0.5 8 = 3 * 2.5 + 0.5 针对可选类型加入空合运算符(??)，形式是a ?? b， a必须是可选类型，b必须是可选类型内容的值类型 意思就是如果可选值a是nil，则会取b的值，就是简单化的三元运算符的操作。 1234var optionStr:String? = "optional"var optionInt:Int32? // 此时optionInt == nilvar resStr = optionStr ?? "NotReachHere" // optionStr非空，取optionStr的值var resInt = optionInt ?? 42 // optionInt为空，取42赋给resInt 区间运算符 ..&lt; 与…，分别表示半开区间与闭区间 1 ..&lt; 6 表示 1 2 3 4 5 1 … 6 表示 1 2 3 4 5 6 字符串 字符串字面量 由双引号括起来的一组Unicode字符集合(Swift中单个字符都是Unicode的形式)。 1let stringDemo:String = "swift string demo" 空串构造 12let stringEmpty = "" // 直接使用空字符串初始化swift字符串var anotherEmptyStr = String() // 使用swift的默认字符串构造 字符串构成 Swift字符串都是单个Unicode字符构成，在Swift里是Character字符类型，可以使用字符串的characters属性来访问单个的String内部的Character字符集合，并可以通过for in的形式迭代出来 123456let stringDemo = "雨燕 Swift"// for .. in的形式遍历整个stringfor char in stringDemo.characters &#123; print("Single Character = \(char)")&#125; 获取字符串的长度需要使用字符串的characters属性内的count属性 123var stringForTest = "SwiftTesting"// 使用characters属性里的count属性获取共有多少个Unicode字符，即字符串的长度print("string length = \(stringForTest.characters.count)") 字符串比较 使用通用的等于与不等于来进行字符串比较，通用的比较操作符 (!= 与==) 123456let string1 = "swift"let string2 = "bugcode"if string1 != string2&#123; print("\(string1) is not same to \(string2)")&#125; Swift提供字符串前缀与后缀的比较方法，分别是hasPrefix, hasSuffix 123456789var prefixStr = "http://bugcode.net"if prefixStr.hasPrefix("http://")&#123; print("\(prefixStr) has prefix \'http://\'")&#125;if prefixStr.hasSuffix("net")&#123; // logic statements&#125; 字符串插值，swift可以在字符串内以\()的形式来对其他格式的数据进行格式化。 123let intDemo:Int32 = 42let floatDemo:Float = 10.2print("string is \(intDemo) \(floatDemo)") // intDemo和floatDemo会被转换成字符串的形式 字符串的访问与修改，因为swift的字符串采用的是Unicode的形式，每个的字符的长度是不一定的，所以牵引到某个字符需要从头对字符串进行索引查找，不可以像元组那样用String.index的方式来访问。Swift提供了一系列的访问属性和修改字符串的方法，并且可以按索引进行访问和修改，也可以按区间进行访问和修改。 startIndex 字符串第一个位置，endIndex 字符串最后一个位置的下一个位置，并不是有有效的String索引，字符的查找索引修改都基于这二个属性来操作。 可以独列一节来记录 获取字符串对应的utf的表示形式 utf-8与utf-16的utf形式直接使用字符串的utf8与utf16属性 123var utfStyleStr = "SwiftString"utfStyleStr.utf8utfStyleStr.utf16 utf-32的使用unicodeScalars的集合属性来访问 12let utf32Str = "utf32"utf32.unicodeScalars // 可通过for..in来遍历]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftNote-2]]></title>
    <url>%2F2016%2F04%2F24%2FSwiftNote-2.html</url>
    <content type="text"><![CDATA[针对Note1进行细节补充。 可选值的概念 Swift加入了一个Optional Value(可选值)的概念，就是一个变量可能是空的，也可能有具体的值，类似C语言中的指针，可能有指向，也可能是NULL。Swift中可选值可以针对所有类型，基本类型，类，自定义类型，都可以声明成可选值类型，即这个值可能是有值的，也可能是空的(nil)，定义的方法就是在定义的语句之后加一个?： 12var optionValue:String? = "swift" //此时可选值optionValue有值var optionValueInt:Int32? // 可选值没值，此时optionValueInt == nil 有这样的定义之后那使用的时候就需要使用if语句判定可选的值内容是否为空，并且可以使用强制解析来取出可选值的内容，强制解析语法是在可选值类型变量后直接加!，即可以取出对应的值。 12345if optionValue != nil&#123; // 意思就是，知道可选值已经不是nil了，直接使用强制解析拿到值 print("optionValue = \(optionValue!)") &#125; 在返回可选值的地方都需要使用if语句判定其值是否为空！ 对一个没有判空的可选值直接进行强制解析会引起崩溃！ 在if语句中还有可选绑定的语法，即将可选值的内容赋值给一个变量/常量，if语句内对这个赋值后的常量/变量进行操作。 12345if let receive = optionValue // 赋值已判空&#123; // 这里不再需要对receive进行强制解析，receive里就是optionValue值的内容 // statements&#125; 上面的使用!强制解析是显式的强制解析，还有一种隐式的强制解析，即有一种情况就是类型是可选值，但是明确其肯定有值的情况下(比如声明同时直接赋值，然后就马上使用)，这时可以使用隐式强制解析，语法就是直接在声明的时候使用!，不使用? 123456var optionImp:Float! = 10.0if optionImp != nil &#123; // 此时的非空判定还是有效的，且此时不再需要再次进行强制解析，直接使用其值就好 print("optionImp = \(optionImp)")&#125; 关于变量与注释 变量可以使用所有unicode字符(符合标识符规则的前提)，比如可使用使用中文和Emoji表情当做变量名等 注释与形式与C++相同单行可以用//, 多行可以/* statements */这种，Swift中对多行的注释增强了，可以在多行注释中进行嵌套注释。(在C和C++中多行注释是不可以嵌套的，以后写swift代码可以肆无忌惮的多行注释了😃) 对Int类型的变量，有N种变体，不同长度需要类型的名字不同，分别是不同长度的有等号类型/无符号类型： Int8/UInt8、Int16/UInt16、Int32/UInt32、Int64/UInt64 在对应平台下Int与对应的平台下最大的相同，即在32位平台下Int与Int32相同，UInt与UInt32相同，依次类推。获取某个整型的最大与最小值，使用max与min二个方法: 1print("Int32.max = \(Int32.max) Int32.min = \(Int32.min)") 数字字面量 Swift提供了四种数字字面量的表示方法 十进制，直接使用数字，如 1024，Swift数字内加入下划线来区分位置，如 1_000 等效于1000 二进制，0b开头，如 0b1001 相当于十进制的9。(感觉这个好方便！) 八进制，0o开头，如 0o11 相当于十进制的9。 十六进制，0x开头，与其他语言一致 如0x13相当于十进制的19。 以上四种0后面字母均为小写。 元组，很多语言都提供的一种结构 由N种不同类型数据组合在一起由逗号分隔，小括号括起来。 12var tupple = ("swift", 10.0, false) //一个元组var tuppleWithName = (name:"bugcode", age:27, married:false) // 指定元组中单元的名字 可以使用下村来访问，由0开始，也可以使用成员的名字来访问 12print("fisrt member of tupple = \(tupple.0)")print("age of bugcode = \(tuppleWithName.age)") 类型的别名，类型C语言中的typedef，Swift中是一个更加”贴切”的关键字typealias 12typealias AgeType = UInt8 // 这里AgeType就是UInt8print("AgeType.min = \(AgeType.min)")]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftNote-1]]></title>
    <url>%2F2016%2F04%2F22%2FSwiftNote-1.html</url>
    <content type="text"><![CDATA[Swift简要记录 - 值，类型 Hello, World 1print("Hello, World") // 不需要分号结尾 变量，常量定义 定义变量 var关键字，直接赋值swift根据值推断类型，显示指定需要变量名后冒号+变量类型 12var variable = 100 // 自动推断variable类型是Intvar anotherVar:String = "bugcode.net" // 显式指定变量是字符串 常量定义let关键字，类型规则变量定义，赋值后值不可更改 12let PAGE_SIZE = 120 // 自动推断let WINDOW_WID:Double = 80.0 // 指定浮点型 swift可以根据定义时的赋值自动推断变量/常量类型，自动推断的前提是定义的赋值给了足够的信息可以让swift推断出类型，如果不能推断，那么就需要显式指定变量的类型。变量/常量可以自动推断类型，但是不会自动隐式的转换类型，如果需要将一种类型转换为另一种类型，需要手动显式转换，即类型名(需要转换的值) 1var transType = String(12) // 12显式转换成为String类型 tips: print函数输出时，需要格式化时候，只需要将要显示的数据(变量，常量)放到括号中，前面加反斜线即可，一切都在输出字符串内完成即可。 123var ver = 12.0let info:String = "http://bugcode.net"print("ouput information: \(info) version: \(ver)") 数组，字典，集合 定义都是使用中括号([])同普通变量常量一样也可以自动推断，也可以显式指定类型。 数组的初始化，三种方式: 1234var arrayStr = ["bugcode", "demo", "swift"] // 自动推断为String类型数组var arrayRepeat = [String](count: 5, repeatedValue:"Ha") // 重复n次的值初始化let arrayInt:[Int64] = [1, 2, 3] // 显式指定为int64的数组var arrayOfEmpty= [Float]() // 显式创建空数组，因为空，无数据，需要指定类型 数组可以进行加法操作，即二个数组合成一个新的数组 123var sumOfArray = arrayStr + arrayStrsumOfArray += ["Objective-C", "C++"]print(sumofArray) 元素的访问，使用下标即可访问对应位置元素，支持区间访问 12print("index of arrayStr 2 = \(arrayStr[2])")print("area of sumOfArray[1...2] \(sumOfArray[1...4]) same as \(sumOfArray[1..&lt;5])") 数组操作还内置了大量的方法来操作数组。 tips: 区间操作符号，…三个点表示一个闭区间，..&lt;表示一个开区间 字典初始化 12345var dictIntString = [1:"swift", 2:"Objective-c"] // 自动推断为[Int:String]let dictStrStr:[String:String] = ["Addr":"Bejing", "Job":"Coder"] // 显式指定字典类型var dictOfEmpty = [Int:String]() // 空字典var emptyDict = [String:String]()emptyDict = [:]// 同样是空字典 字典的元素访问，使用字典的key，相当于把数组的下标换成key，这里需要注意的是，字典访问元素时拿出来的值是optional的(可选值)，意思就是拿出来的值可能是nil，所以使用下标key形式的访问字典值会返回一个对应字典value的可选类型，使用类型+?的形式来表示，如： 1dictIntString[1] // 这个值的类型就是String? 因为对应字典key下的值可能是空的，所以使用optional来表示，也就是如果这个key下的的值存在，这个值就是字典值类型，否则就是nil。所以使用key下标取出的值最好取出选判定一下空值。 1234if let x = dictIntString[1]&#123; // do someting&#125; 二个重要的字典方法，更新某个key下对应的value，移动某个key对应的字典项，返回值都是之前的对应key下的value值 12345678if let removeValue = dictIntString.removeValueForKey(2)&#123; // some code here&#125;if let updateOldValue = dictIntString.updateValue("New Value", forKey:3)&#123; // some code &#125; ​ 集合初始化 使用Set关键字 123var emptySets = Set&lt;String&gt;() // 空集合var sets:Set = ["1", "2"] // 自动推断var typeSets:Set&lt;Int&gt; = [314, 1024] // 显式指定类型 集合的四种基本操作(截图来自于Apple开发者官网)]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac常用的快捷操作方式]]></title>
    <url>%2F2016%2F04%2F18%2FMac%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[用Mac也有一段时间了，无论是开发还是日常总有一些快捷操作，写在这里算是备忘，备忘持续更新。 截屏操作 截取全屏 Command + Shift + 3 自由截取某个区域 Command + Shift + 4 (鼠标指定区域) 截取某个窗口 Command + Shift + 4 + Space (按完鼠标会变成相机，然后选中窗口就能截取了，很多人不知道这个截屏产生的图像是带窗口阴影了，ps: 是不是老乔想的👍)，这种效果： 以上三个截取的时候都会产生一个具体的截屏文件在桌面上，如果不想产生这个文件，可以按住快捷键的同时再按住Control，这样产生的截屏就会直接在剪贴板里了。 一个特别有用的是，经常在打字的时候需要输入一个emoji表情，通常做法都是打开汉字输入法去里面找，Mac下有一个快捷键可以快速打开emoji表情输入 Command + Control + Space就会弹出emoji表情的搜索框了😀。 比较通用的一个Option辅助按钮，几乎在任何情况下，按住Option操作都能整出一点出其不意的情况，比如按住Option打开前往会出现用户的资源库，按住Option再按，菜单会有变化，比较常用的是窗口的全屏按钮在按住Option之后再按就是普通的全屏了，反之是恢复，等等。 Finder下前往某个文件夹，Commond + Shift + g，会弹出一个路径输入框，输入具体路径就可以直接打开了，隐藏文件夹也可以。 按住Option +Shift再调节音量就可以对每个音量的小格子再细微(4小格)的调整。 按住Command + 鼠标拖动可以拖动当前不是激活状态的窗口，并且也不会激活那个窗口。这个还挺常用的。 还有一个是刚遇到的，全用MindNode的时候，每个子节点文字多了想换行发现直接Enter不能换行，试了半天才发现按住Option + Enter才是文字里的回车换行。]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法简要说明]]></title>
    <url>%2F2016%2F04%2F17%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[最近Blog迁移到了Hexo ，开始全用Markdown这种标记语言进行记录，Markdown好处不再多说，自行参照Markdown Wiki，由于最近频繁使用，这里对Markdown语法进行简要记录。 标题，分N(1-6)级，有几个#号即是几级标题，对应html中的H1-H6，需要注意的是#后需要跟一个半角空格。 1### Title ### Title 列表，分有序与无序列表， a. 有序列表，数字.半角空格， 121. order table 12. order table 2 order table 1 order table 2 b. 无序列表，+，-，*都可，后接一个半角空格，可以在嵌套时分别使用 123+ 1 - 1-1 * 1-1-1 1 1-1 1-1-1 引用，&gt; (右尖括号+半角空格) 1&gt; References Display References Display 代码块， ```语言名称 + 代码块 ```，现在一般的编辑器都支持代码块高亮 源格式如下： ```python def functionName(): ​ pass ``` 生成的代码块如下： 12def functionName(): pass 链接，分为行内的链接和注脚形式的链接 a. 行内链接显示：[要显示的链接文字](真正的链接) 1[Link Text](http://xxx.xxx) bugcode.net b. 注脚形式的链接 [链接显示的文字 ][链接引用的标签] [链接引用的标签]:链接地址 “链接标题” 12[SubscriptLinkText][Tag][Tag]:http://bugcode.net "Bugcode" 图片，! [AltText](/path/to/image)，这里的图片路径可以是本地的，也可以是网络上的路径 1![WikiLogo](https://zh.wikipedia.org/static/images/project-logos/zhwiki-hans-2x.png) ![BingPic](https://zh.wikipedia.org/static/images/project-logos/zhwiki-hans-2x.png) 强调文本，粗体，斜体，粗斜体 a. 粗体 __下划线粗体__ 或者 **星号粗体** 12__下划线粗体__ **星号粗体** 下划线粗体 星号粗体 b. 斜体 _下划线斜体_，*星号斜体* 12_下划线斜体_*星号斜体* 下划线斜体 星号斜体 分段， 行尾连续二回车 换行，行尾至少二个空格 + 回车 表格，是Markdown扩展语法，Hexo支持不太好，全用可以用html中的标签。 扩展语法中的表格语法： 123| 1 | 2 ||:-:|:-:|| 3 | 4 | 分隔线，连续输入三个以上的水平分隔符，星号，下划线都可 123---*******_________]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和C++与Java互相调用(续)]]></title>
    <url>%2F2015%2F06%2F15%2FC%E5%92%8CC-%E4%B8%8EJava%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8-%E7%BB%AD.html</url>
    <content type="text"><![CDATA[上一篇说的是java的本地调用，即使用jni完成java调用c/c++编写的代码，这回仍然是使用jni，不过是倒过来，使用c/c++调用java编写的代码。本次使用环境是：centos5.4，gcc4.9.0，jdk1.6_45。 配置相关环境。 配置jdk环境，加入JAVA_HOME环境变量，即jdk目录加入path。 配置加载jvm所需要的libjvm.so动态库，所以需要指定LD_LIBRARY_PATH这个环境变量，也就是libjvm.so这个动态库所在的路径， 通常都是： 1export LD_LIBRARY_PATH=$&#123;JAVA_HOME&#125;/jre/lib/i386/client:$LD_LIBRARY_PATH 这样程序运行的时候如果在lib里找不到jvm这个动态库，就会去LD_LIBRARY_PATH所指定路径下去找。c/c++相关编译环境linux下自带。 因为是c/c++调用java代码，然后就先写java的测试代码。写了一个简单的测试类，如下： 1234567891011121314151617181920212223class CCallJavaTest&#123; //类成员 public String mTestStr; private static final int CONST_VAL = 10; //静态方法 public static String staticCallTest(int val) &#123; System.out.println("[staticCallTest] called"); return new Integer(val).toString(); &#125; //成员方法 public int getVal() &#123; System.out.println("[getVal] called"); return CONST_VAL + 10; &#125; public String getTestStr() &#123; return this.mTestStr; &#125;&#125; 1javac CCallJavaTest.java 无错生成.class文件，这里只是一个简单的测试，所以没有指定包名，如果指定包名，下文中使用jni在寻找java类的时候就需要全名（包名/类名这种形式，下文会说明）。 查看刚才写的测试类的签名，下面用jni获取类内部类型（包括方法和成员）会用到，这里用到一个jdk里自带的一个分析工具，叫做javap，终端里直接键入javap -help查看帮助。 -s选项是将内部的类型的签名打印出来，-private选项是输出所有的类与成员。这里就使用这二个选项，将输出重定向到一个文件中，以便之后查看： 1javap -private -s CCallJavaTest &gt; CCallJavaTest.sig 查看sig文件会看到类似如下内容： 123456789101112131415161718192021222324252627class CCallJavaTest extends java.lang.Object&#123;public java.lang.String mTestStr; Signature: Ljava/lang/String;private static final int CONST_VAL; Signature: ICCallJavaTest(); Signature: ()Vpublic static java.lang.String staticCallTest(int); Signature: (I)Ljava/lang/String;public int getVal(); Signature: ()Ipublic java.lang.String getTestStr(); Signature: ()Ljava/lang/String;&#125; Signature部分就是我们需要的部分。 编写c代码（这里使用c语言）通过jni调用java代码，先上代码再看细节： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;int main(int argc, char *argv[])&#123; //Java虚拟机 JavaVM *jvm = NULL; //Jni运行环境 JNIEnv *env = NULL; //虚拟机初始化参数 JavaVMInitArgs jvm_args; //java虚拟机参数, 这里只使用classpath这一项，所以长度为1 JavaVMOption opt[1]; //设置初始化参数（classpath 为当前目录） opt[0].optionString = "-Djava.class.path=."; //初始化虚拟机初始化参数 memset(&amp;jvm_args, 0, sizeof(jvm_args)); //设置jni环境版本 jvm_args.version = JNI_VERSION16; //参数的个数 jvm_args.nOptions = 1; //虚拟机参数 jvm_args.options = opt; //创建java虚拟机 返回0为启动成功，其他数值的意义在头文件中有定义 long jvm_stat = JNI_CreateJavaVM(&amp;jvm, (void **)&amp;env, &amp;jvm_args); //错误处理 if (jvm_stat) &#123; fprintf(stderr, "%s\n", "JVM Create Error!"); exit(-1); &#125; //找到类定义 jclass cls = (*env)-&gt;FindClass(env, "CCallJavaTest"); //找到做相应处理 if (cls != 0) &#123; //获取静态方法的ID, 通过方法签名和方法的名字 jmethodID static_method = (*env)-&gt;GetStaticMethodID(env, cls, "staticCallTest", "(I)Ljava/lang/String"); //找到方法 if (static_method) &#123; jint val = 1024; //调用静态方法并获取返回值 jstring return_str = (jstring)(*env)-&gt;CallStaticObjectMethod(env, cls, static_method, val); const char trans_str = (env)-&gt;GetStringUTFChars(env, return_str, 0); fprintf(stdout, "%s\n", trans_str); //释放内存(减引用) (*env)-&gt;ReleaseStringUTFChars(env, return_str, 0); &#125; //通过新建对象调用方法, 调用默认构造方法 jobject obj = (*env)-&gt;AllocObject(env, cls); if (!obj) &#123; fprintf(stderr, "%s\n", "Alloc New Object Error!"); exit(-1); &#125; //调用类成员方法 jmethodID member_method = (*env)-&gt;GetMethodID(env, cls, "getVal", "()I"); if (member_method) &#123; //调用成员方法 jint res = (jint)(*env)-&gt;CallObjectMethod(env, obj, member_method); fprintf(stdout, "[%s] %d\n", "Call Member Method", (int)res); &#125; //获取类成员 jfieldID member_field = (jfieldID)(*env)-&gt;GetFieldID(env, cls, "mTestStr", "Ljava/lang/String;"); if (member_field) &#123; //对象成员的新的成员值 const char *modify_str = "new class member"; //分配待传参数 jstring arg_str = (*env)-&gt;NewStringUTF(env, modify_str); //设置新的成员值 (*env)-&gt;SetObjectField(env, obj, member_field, arg_str); &#125; //查看新的string的值 member_method = (*env)-&gt;GetMethodID(env, cls, "getTestStr", "()Ljava/lang/String;"); if (member_method) &#123; jstring new_set_str = (jstring)(*env)-&gt;CallObjectMethod(env, obj, member_method); const char new_c_str = (env)-&gt;GetStringUTFChars(env, new_set_str, 0); fprintf(stdout, "[new set str]: %s\n", new_c_str); (*env)-&gt;ReleaseStringUTFChars(env, new_set_str, 0); &#125; //使用完成销毁虚拟机 (*jvm)-&gt;DestroyJavaVM(jvm); &#125; return 0;&#125; 注释已经算详细了，大体的步骤： 1）初始化jni环境，因为都是基于jni来操作的，初始化创建并加载java虚拟机（jvm），因为java生成的字节码需要在jvm中运行。因为就有一个java类在当前目录中，所以JavaVMOption的长度为1，只指定了一个classpath参数。通过JNI_CreateJavaVM函数创建jvm。 2）创建了jvm之后就可以执行java代码了，但是要找到java的类，才能调用方法，获取成员，所以接下来就是找到要装载的java类。通过jni提供的FindClass方法传入java的类名，找到对应的类。（C语言调用：（*env）-&gt;FindClass(env, “ClassName”);C++调用：env-&gt;FindClass(“ClassName”);）返回的jclass不为空则找到了对应的类。通过找到的类就可以进行访问成员，调用方法操作了。 现在得到了java类，还得继续通过类获取方法，（这里就用到javap所生成出来的类文件的签名了） 1）静态方法。静态方法是不需要实例化对象的，它是类级的。可以通过类名.静态方法名来调用。jni提供了GetStaticMethodID函数通过方法名和方法签名来获取类的静态方法，提供了CallStaticObjectMethod函数来调用获取到的方法。GetStaticMethodID返回一个jni的包装类型jmethodID，对应方法的ID，再把这个ID传给CallStaticObjectMethod函数，通过这个获取到的ID来调用对应的方法。代码中的第42行，GetStaticMethodID函数的最后一个参数就是这个方法的签名，括号里的是方法的形参类型，后面的是方法的返回类型，这里使用的就是javap直接分析出来的对应的签名（区别方法重载）。代码中42-54行就是通过类获取静态方法再调用并获得返回值的过程。 2）成员方法。需要通过对象来调用。通过实例对象.成员方法的形式来调用。所以这里要调用成员方法就必须先产生一个类的实例，再通过这个类的实例去调用成员方法。jni提供了AllocObject来调用java类的默认构造方法。返回一个jobject的jni包装的对象类型。通过GetMethodID函数获取类的成员方法。（如果不是默认构造方法，就可以使用普通的GetMethodID方法获取构造方法如： 1jmethodID constructor_method = (*env)-&gt;GetMethodID(env, cls, "&lt;init&gt;", "(I)"); 类似这样，再使用jni的NewObject函数得到了这个类的对象。）这里使用的方法签名也同样是javap工具得来的。得到jmethodID后通过jni提供的CallObjectMethod传入对象与方法ID，调用这个方法并获取返回值。代码58-72行就是生成新对象，调用成员方法的过程。 3）成员变量。同样是需要实例对象来进行获取，修改等操作。jni提供一个叫做GetFieldID的函数，传入类名，成员变量名称，还有其变量类型（javap生成的签名），返回一个jni的jFieldID的包装类型。获取其ID之后，通过SetObjectField函数将新的值设置给这个成员变量。函数依次传入，对象、成员变量ID，将要设置的值。设置完成，再次使用GetMethodID调用对应的get方法查看其值是否改变。代码中74-97就是获取成员变量并设置新值，再次查看的过程。 以上过程都调用都完成之后，使用创建出的jvm指针销毁jvm，释放加载的虚拟机。 gcc下编译代码查看结果： 12gcc -Wall -o c_call_java c_call_java.c -I$&#123;JAVA_HOME&#125;/include \-I$&#123;JAVA_HOME&#125;/include/linux -L$&#123;JAVA_HOME&#125;/jre/lib/i386/client/ -ljvm -I指定头文件目录，这里是jni的头文件目录（另一个办法是把里面的h文件都拷贝到/usr/local/inlcude中），-L指定要链接的库的目录，-l选项直接指定库的名称，这里要链接的是$JAVA_HOME/jre/lib/i386/client/下的libjvm.so动态库。 编译无错生成c_call_java可执行文件。终端下运行输出： 123[getVal] called[Call Member Method] 20[new set str]: new class member c通过jni成功调用了java代码。以上就是在没有线程的情况下，c/c++调用java的jni的一般操作方法。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和C++与Java的互相调用]]></title>
    <url>%2F2015%2F06%2F05%2FC%E5%92%8CC-%E4%B8%8EJava%E7%9A%84%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8.html</url>
    <content type="text"><![CDATA[因为adnroid项目中用到了获取mac地址做为唯一码的功能，c和c++在android却没有对应的api，还好有jni这个东西，用java写好获取mac地址的代码，用c/c++调用代码就可以直接获取mac字符串了。 JNI(Java Native Interface)Java本地接口，详情点击此处，就是java用来与本地的已经编译的语言交互的接口。这里使用的环境是windows 7 64，gcc 4.6.2，jdk 1.6。 首先看在Java中调用c/c++: 创建Java类（JavaJni），创建要交互的本地方法，使用native关键字，加载我们要调用的动态库。 编译创建的Java类，无错生成.class文件。 通过JDK中javah工具生成本地方法声明的头文件。（这里没有使用包名，正确方法是javah 包名.类名） 生成本地声明的头文件之后，编写对应的c或者c++文件，实现具体的本地方法。 编译生成动态链接库，windows下是dll文件，linux是so文件。这里是使用windows下的MinGW编译生成dll文件。（因为windows下jni的默认是使用vc的调用约定， 所以这步使用gcc生成dll文件时候需要注意不同平台调用约定的实现，下文会说）。 生成动态库后，将其放入java.library.path所指定的路径中，可能通过getProperty方法查看java.library.path所在的路径，将其放入任意一个即可加载。 执行java JavaJni，查看结果。 下面写一个测试，具体实现一下上面的步骤： a. 创建Java类（JavaJni）如下： 123456789101112131415161718192021222324252627282930313233343536373839public class JavaJni&#123; public static void main (String [] args) &#123; JavaJni jni = new JavaJni(); //本地方法测试 jni.jniVoidTest(); System.out.println("==============================="); System.out.println(jni.jniStringTest()); System.out.println("==============================="); System.out.println(jni.jniIntTest()); System.out.println("==============================="); System.out.println(jni.jniWithString("From JavaJni")); System.out.println("==============================="); int[] array = jni.jniArray(); for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; System.out.println("==============================="); int[] temp = &#123;1, 2, 3, 4, 5, 6, 7&#125;; System.out.println(jni.jniWithArray(temp, temp.length)); System.out.println("==============================="); &#125; //类初始化时候加载动态库 static &#123; System.loadLibrary("JavaJni"); &#125; //本地方法声明 使用native关键字 native void jniVoidTest(); native String jniStringTest(); native int jniIntTest(); native String jniWithString(String str); native int[] jniArray(); native boolean jniWithArray(int[] array, int len);&#125; native关键字声明本地dll中要调用的方法，静态块在类初始化的时候加载动态库。主方法中调用本地方法做一个简单的测试，六个不同的返回值，不同参数的测试方法。 b.编译创建的Java类： 1javac JavaJni.java c. 通过javah工具生成本地方法声明的头文件，由于这里没有指定包名，直接使用类名: 1javah JavaJni(注意这里是JavaJni，没有后缀) 这里会生成一个JavaJni.h的本地方法的头文件声明，类似如下： 123456789101112131415/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class JavaJni */#ifndef _Included_JavaJni#define _Included_JavaJni#ifdef __cplusplusextern "C" &#123;#endif/** Class: JavaJni* Method: jniVoidTest* Signature: ()V*/JNIEXPORT void JNICALL Java_JavaJni_jniVoidTest (JNIEnv *, jobject); #ifdef __cplusplus}#endif#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566d. 如注释所说，这是机器生成的方法声明，直接使用即可。现在要对应头文件创建JavaJni.c文件实现每个声明的本地方法，这里做简单的实现：```c#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &quot;JavaJni.h&quot; #define BUFF_SIZE 5 JNIEXPORT void JNICALL Java_JavaJni_jniVoidTest(JNIEnv *env, jobject obj)&#123; printf(&quot;&gt;&gt;: Excute [jniVoidTest] success\n&quot;);&#125;JNIEXPORT jstring JNICALL Java_JavaJni_jniStringTest(JNIEnv *env, jobject obj)&#123; char *static_str = &quot;excute [jniStringTest] success\n&quot;; //创建可供返回的jstring jstring jstr = (*env)-&gt;NewStringUTF(env, static_str); return jstr;&#125;JNIEXPORT jint JNICALL Java_JavaJni_jniIntTest(JNIEnv *env, jobject obj)&#123; printf(&quot;excute [jniIntTest] success\n&quot;); return 1024;&#125;JNIEXPORT jstring JNICALL Java_JavaJni_jniWithString(JNIEnv *env, jobject obj, jstring str)&#123; const char *temp = NULL; //由传入的参数获取c类型的字符串 temp = (*env)-&gt;GetStringUTFChars(env, str, 0); //只做测试，简单的写一个断言，其他的要做对应的参数为空处理 assert(temp); printf(temp); //减引用计数 (*env)-&gt;ReleaseStringUTFChars(env, str, temp); char *r_str = &quot;excute [jniWithString] success\n&quot;; jstring jstr = (*env)-&gt;NewStringUTF(env, r_str); return jstr;&#125;JNIEXPORT jintArray JNICALL Java_JavaJni_jniArray(JNIEnv *env, jobject obj)&#123; jint tmp_buffer[BUFF_SIZE] = &#123;0&#125;; for (int i = 0; i &lt; BUFF_SIZE; i++) &#123; tmp_buffer[i] = i + 4; &#125; jintArray int_array = (*env)-&gt;NewIntArray(env, BUFF_SIZE); //将数所设设置到将要返回给java端的数组中去 (*env)-&gt;SetIntArrayRegion(env, int_array, 0, BUFF_SIZE, tmp_buffer); return int_array;&#125;JNIEXPORT jboolean JNICALL Java_JavaJni_jniWithArray(JNIEnv *env, jobject obj, jintArray array, jint len)&#123; //此处使用从java处copy数组数据到此，不对java处的数据做修改 jint tmp_array[len]; //由java处的数组获取数组数据，之后不要忘记减少引用计数 (*env)-&gt;GetIntArrayRegion(env, array, 0, len, tmp_array); for (int i = 0; i &lt; len; i++) &#123; printf(&quot;%d\t&quot;, tmp_array[i]); &#125; printf(&quot;\n&quot;);&#125; 关键部分都做了注释，注意的地方就是：NewStringXXX之后不要忘记ReleaseString减少对应的引用计数以防止内存泄露。 e. 编译上一步所写的实现文件生成动态库，这里环境是windows，所以使用gcc生成dll文件。 1gcc -Wl, --kill-at -std=c99 -shared -o JavaJni.dll JavaJni.c 参数一个一个看： -std=c99 这里是使用C语言的c99标准，包括for循环的初始化部分变量声明和变长数组。 -shared 链接器选项，用于生成一个共享库目标文件。也就是生成这个动态库的选项。 -o 指定输出（地球人都知道） -Wl, 这个选项是把这个后面的选项传递给链接器。后面的–kill-at才是真正起作用的。 由于JNI加载dll的中导出的函数名在windows下是与MSVC相同的。而JNI的调用约定使用的是__stdcall，gcc下生成的dll导出的函数名是func_name@shift_value的形式。MSVC下生成的dll导出的函数名是func_name，这里出现了差异，那么JNI在使用gcc生成的dll的时候就会出现找不到对应的函数名的错误，链接错误，是因为导出的函数名不同的原因。所以才会使用Wl, –kill-at给链接器的选项，使生成的dll导出的函数名是func_name这种形式，kill-at的意思也就是去掉@之后的部分。[这里如有说得不对，请指正，非常感激！]这里是一个不同的调用约定，在不同编译器下导出函数名： 还可以使用另一个链接器的选项，-Wl,–add-stdcall-alias即同时导出func_name@shift_value和func_name二种函数名的。 这里生成动态库的时候可能还会出现jni.h找不到的情况，在MinGW下最简单的方法就是把JDK目录下的include下的所有文件都拷贝到MinGW的include目录中（包括win32目录下的头文件都复制到MinGW下的include文件夹中）。这样gcc就可以找到jni.h了。 f. 生成dll之后加入java.library.path中，如果不知道具体的目录在哪，可以放到system32，或者自己看一下java.library.path，如下： 12345678class OutJavaPath&#123; public static void main (String [] args) &#123; String path = System.getProperty("java.library.path"); System.out.println(path); &#125;&#125; 得到path的值之后，把dll放到合适的目录。 g. 执行JavaJni(java JavaJni)。到这里就会看到console里的输出。如下： 到这里就是使用Java本地接口JNI调用本地语言实现的实现的整个过程。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的umask]]></title>
    <url>%2F2015%2F05%2F16%2FLinux%E4%B8%8B%E7%9A%84umask.html</url>
    <content type="text"><![CDATA[​ 偶然看到一本书上写umask(掩码)的计算，说是用户的实际文件(夹)权限是通过默认文件(夹)权限与掩码相减得到的。感觉不太对。​ 先说掩码，Linux下的文件有三个权限“段”，一个文件所有者的权限，一个同用户组的权限，一个是其他用户的权限，三个“段”又分了三个部分，可读，可写，可执行，每个部分用一个八进制数表示，那么权限也就可以表示成000à777之间的数字（例如421，就表示文件拥有者有读权限，同用户组的有写权限，其他用户有执行权限）。而Linux针对文件和文件夹又有一个默认的原始权限，文件的是666，也就是三个不同有用户都有读写权限没有执行权限，文件夹是777，也就是三个不同的用户拥有所有的权限，而掩码，就是对文件（夹）默认权限的“遮掩”，通过对umask的设置，对文件（夹）重新设置了权限。使用umask命令可以查看用户当前的掩码。具体参考man umask。​ 而通过掩码又是怎么算得到对应的权限呢，比如大多用户的掩码都是0002，那通过这个掩码和文件（夹）默认权限如何得到最终文件的权限，很多书上都说是默认权限减去掩码，或者默认权限与掩码作异或，再或者就是对掩码取反，也就是从默认权限上“抽离”对应的“段”里面的位。像上面所说，掩码0002，文件默认权限0666，第一种，相减，结果当然是0664，正确了，第二种，异或，结果0664，也正确了，第三种，对0002的二进制取反，结果也是0664，也正确了。好像都是对的，但是假如，是说假如，把对应的0002改成0033，那么这几种还能正确吗？其实所有的上面的说法都是在二个前提下的，也就是掩码的“遮掩”的规则： Linux下文件的默认权限都是0666，也就是都没有执行权限。 Linux下的文件夹的默认权限是0777，也就是都有执行权限。 ​ 在这二个前提下，上面的无论是异或，取反，都要考虑到文件的特殊性就是没有可执行权限，一旦出现一个像0033这样的“奇葩”掩码，就要考虑到文件的默认权限里没有可执行权限，就是三个位中的421中的1是没有的，知道了这个，那0033，也就相当于0022了，因为对应的可执行权限是本来就没有的。可以像下边这样试一下： 123% umask 033% touch test% ls –al test 应该可以看到对应的文件权限还是-rwxr–r–，也就是644。 ​ Linux下还有一个umask的函数，通过umask函数设置文件掩码，此时文件的权限就是由创建文件的函数来指定了（也就是说文件的权限不是666了，而是由创建文件函数来指定的）。下机是一个简单的例子： 123456789101112131415161718192021222324#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; int permission = 00777; umask(0000);//相当于没有设置掩码 if (creat("test_file", permission) &lt; 0)//创建一个文件,以查看权限 &#123; printf("Create File Error!\n"); exit(-1); &#125; int mask = 0033; umask(mask);//设置文件权限掩码 if (creat("test_mask_file", permission) &lt; 0)//掩码作用于同用户组和其他的写和执行权限 &#123; printf("Create File Error!\n"); exit(-1); &#125; return 0;&#125; % gcc –Wall –std=c99 test_umask.c –o test_umask 执行后产生二个文件，详细如下（centOS编译）： 也就是没有设置掩码的文件权限是777，设置了033掩码的文件权限是755，有人说不对啊，掩码是033，原来的是777，最终的应该是744啊，没错，这里的确有点儿小问题，问题就在creat函数上，creat函数在生成文件的时候只取与读和写相关的参数，也就是没有与执行相关的参数，到这里就又回来上面去了，也就是掩码其实就是0022，总结出来就是，掩码如果含有奇数，要么直接计算，然后在结果的奇数对应位上各加上1，或者，直接参与运算的时候把掩码位中含有奇数的位直接减去1。这样也就是最终的777 与 022 ，生成的最终的文件权限就是755。 ​ 综上，与文件相关，掩码含有奇数，直接在奇数位减去1，再计算，如果为偶数，就直接算出权限。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SIGCHLD信号异步清理子进程]]></title>
    <url>%2F2015%2F04%2F19%2F%E4%BD%BF%E7%94%A8SIGCHLD%E4%BF%A1%E5%8F%B7%E5%BC%82%E6%AD%A5%E6%B8%85%E7%90%86%E5%AD%90%E8%BF%9B%E7%A8%8B.html</url>
    <content type="text"><![CDATA[首先说为什么要清理子进程（由父进程），在Unix系统中经常会听到一个词“僵尸进程”(Zombie Process[可不是植物大战僵尸^_*])，而“僵尸进程”就是由子进程而来的。而“僵尸子进程”产生的原因，简单来说，就是子进程结束的时候，它的父进程没有wait它，内核释放了这个子进程的空间但进程却没有从进程表中被删除（空占进程表），而Unix保证每个进程都可以访问其子进程的退出信息，但必须wait它才可以取出对应进程的退出信息，这样儿就出现了一个问题，父进程可能太忙没有wait子进程，子进程却结束了，子进程对应的退出信息就会一直保留（包括进程ID等），资源会一直被占用，小数量的可能没有危害，一旦“僵尸进程”数量变多，主要是进程数限制，可能就会造成无法产生新的进程。这就是典型的“僵尸进程”的危害。（另外说明一种情况，如果在子进程结束前，父进程已经结束，这样不会造成“僵尸进程”，因为Unix提供一种机制，如果一个进程结束，系统会检查进程，如果有进程正好是已经结束进程的子进程，那么这个进程就会被init进程接管，也就是说init进程变成了它的父进程。） 下面是一个小例子，先对“僵尸进程”有一个视觉的了解：(zombie.c) 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;//产生子进程int spawn_process()&#123; pid_t child_pid; child_pid = fork(); //父进程返回子进程ID if (child_pid != 0) &#123; return child_pid; &#125; else//子进程中，做一些事情 &#123; sleep(10); abort(); &#125;&#125; int main(int argc, char *argv[])&#123; int child_status; //产生子进程并wait spawn_process(); wait(&amp;child_status); printf("child_process finished!\n"); return 0;&#125; 正常编译运行，主程序会sleep一分钟。此时打开另一个终端窗口，输入：1ps –e –o pid,ppid,state,cmd 查看所有进程，包括进程ID，父进程ID，进程状态，进程命令行，如果不出什么差错，应该可以看到类似下面的信息： 这个进程状态为Z，命令行为defunct的就是大名鼎鼎的“僵尸进程”了(Z-&gt;Zombie)。而我们应该怎么避免呢？根据上面，首先肯定想到，由父进程wait子进程，直接到子进程结束，再由父进程wait到其状态。但是这样又带来一个问题，父进程与子进程的运行本身就是一个异步的过程，父进程没法预料什么时候子进程结束，一直wait子进程？那父进程就会一直挂起到子进程结束的那一刻，下面看一个例子： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;//产生子进程int spawn_process()&#123; pid_t child_pid; child_pid = fork(); //父进程返回子进程ID if (child_pid != 0) &#123; return child_pid; &#125; else//子进程中，做一些事情 &#123; sleep(10); abort(); &#125;&#125;int main(int argc, char *argv[])&#123; int child_status; //产生子进程并wait spawn_process(); wait(&amp;child_status); printf("child_process finished!\n"); return 0;&#125; 正常编译运行，可以看到，直到子进程结束，父进程也就是main中的printf才打印出child_process finished!，在此之前进程一直处于挂起状态(Hang Up)，也就是父进程要一直等，等子进程结束，父进程才会结束，这显然不是我们想要的优雅的解决方式。 一种优雅的解决方式就是，当每个子进程结束的时候，通知父进程（儿子出去玩不知道什么时候回来，父亲不知道什么时候该做饭等他，如果儿子回来的时候打电话告诉父亲，父亲再等他，这样儿父亲还不耽误其他时间），而子进程怎么通知父进程呢？通知的方法有几种，进程间通信(将在以后讨论)，现在最容易想到的就是信号，Linux下一个子进程结束的时候，会向父进程发送一个SIGCHLD信号，而Linux系统对这个信号的默认是什么也不做，于是，我们就可以通过捕获SIGCHLD信号，再去让父进程wait子进程，这样就可以父进程就可以异步的清理子进程，也就是只在子进程结束的时候才去wait子进程退出状态。接下来的问题就是如何捕获对应的信号，设置对应的信号处理了。这里我们使用sigaction，简单说一下sigaction，它是用来设定对应信号处理的函数，三个参数，第一个设置要处理信号的信号值，第二个参数，设置对应的sigaction结构，结构中最重要的是信号处理函数，也就是对应的handler域，第三个也是一个sigaction结构，可以理解为保存上一个的信号处理的sigaction结构，如果第二个参数不为空则当前使用第二个参数中的处理，如果第三个参数不空，上一个处理的sigaction就会保存在这里（如要具体了解，参见man 2 sigaction）。 下面给出例子，父进程通过捕获SIGCHLD信号，wait子进程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;//全局变量保存退出状态sig_atomic_t exit_status;int spawn_process()&#123; pid_t child_pid; child_pid = fork(); //父进程返回子进程ID if (child_pid != 0) &#123; return child_pid; &#125; else//子进程中，做一些事情 &#123; sleep(10); abort(); &#125;&#125;//SIGCHLD信号处理函数void cleanup_child_process(int sig_num)&#123; int status; wait(&amp;status);//wait子进程 printf("child_process prepare terminate!"); exit_status = status;//保存退出状态信息&#125;int main(int argc, char *argv[])&#123; /* 通过调用cleanup_child_process处理SIGCHLD信号 */ struct sigaction sigchild_action; memset(&amp;sigchild_action, 0, sizeof(sigchild_action)); sigchild_action.sa_handler = &amp;cleanup_child_process; sigaction(SIGCHLD, &amp;sigchild_action, NULL);//设置对应的信号处理 //产生子进程并wait spawn_process(); while (1) &#123; printf("parent_process do something!\n"); sleep(1); &#125; return 0;&#125; 编译运行，可以看到，这次父进程没有一直Hang Up等待子进程结束，父进程一直在做自己的事，直接接收到了SIGCHLD信号，才对子进程做出处理，这样儿，就通过对SIGCHLD信号的处理达到了对子进程异步清理（wait）的目的。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua简要笔记-2]]></title>
    <url>%2F2015%2F03%2F29%2FLua%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0-2.html</url>
    <content type="text"><![CDATA[接上文，控制语句下来就是一门语言不可或缺的一部分—函数。 函数 Lua中的函数可以做为First Class(第一类值)，即函数可以做为变量赋值给其他变量，可以做为参数传递，还可以做为另一个函数的返回值返回，传递赋值返回之后，函数还可以通过func()的方式继续进行调用使用。 函数形式 function关键字 12345function LuaFunc(param1, param2) local val = param1 + param2 -- do something return valend a). 函数名称LuaFunc，调用或者传递时使用这个名称，param1，param2形参，val是返回值，不必多说。 b). 可以通过LuaFunc(1, 2)这种方式来调用。也可以local funcReceiver = LuaFunc这样来赋值。当然， 你还可以这样调用，Lua并不会像静态编译语言一样进行参数个数匹配检查。 LuaFunc(19) — 此时param2=nil LuaFunc(1, 2, 3) — 此时3没有任何作用，被舍弃 也就是，少于形参个数之个的参数默认是nil，多于形参个数的参数默认被行么，这就lua函数的最基本形式。 多个返回值 Lua可以返回多个可以是不同类型的返回值，形式就是在return关键之后按逗号分隔所有需要返回的值即可。 123function MultipleReturnVal(para1) return "bugcode", 26, &#123;[2] = "bugcode.net"&#125;, 1.0end 如果MulitipleReturnVal只是单独调用，没有表达式，那所有的返回值都舍弃，如果有构成表达式，那Lua会保留尽可能多的返回值。如： local x, y, z = MultipleReturnVal(1)，Lua会将x，y，z分别赋值为”bugcode”, 26, {[2] = “bugcode.net”}，最后一个1.0没有接收的变量即被舍弃 另一种情况如果接收的值多于返回的值，则多余的接收的值被置为nil。以上二个规则也同样适用于某个返回多个值的函数被另一个函数做为参数的情况。 如果想主动舍弃某个返回的变量， 使用下划线来占位即可，如：不想接收第三个是table的参数 local x, y, _, z = MultipleReturnVal(1) — 这样返回值中第三个参数就会初舍弃 变长参数。 函数参数可能是多个不定数量的参数，这时就需要Lua的变长参数。用法非常简单： 123456789function VarArgsFunc(mixedParm, ...) local sum = 0 for k, v in pairs(...) do if type(v) == "number" then sum = sum + v end end return sumend ​ a). 变参使用三个点(…)来表示，可以把它想成一个table，也可以想成一个多返回值的函数，它可以被传递也可以赋值给别的变量。变参之前也可以有固定参数，传入实参会按顺序将参数赋值给对应的实参然后把其余的都传递给变参。 b). 如上例，VarArgsFunc(1, 2, 3, 4, 5, 6, 7)，这样调用会将1赋值给mixedParam，其余都在…中，这样在迭代体中，检测如果是数字类型就对其累加，最后的结果就是7个实参的后6个数之和。 具名参数。 普通的lua函数与其他编程语言的函数一样，函数参数都是函数定义时的函数参数一一对应，包括位置。 1234567function LocationPara(str, num) string.format("string = %s", str) string.format("number = %f", num)endLocationPara("bugcode", 3.14)LocationPram(3.14, "bugcode") -- 会出问题 如上例，参数位置不同了，可能就会出现各种问题。但是Lua并不支持类似这种func(first = “1”, second = “2”)语法，但是通过table可以变相的实现这种机制，就是函数只接收一个table类型的参数，然后table里的面的每个key都对应不同的名字，变相的要table里的value做参数值，key就是那个参数的名字。 paramTable = {first = “0”, second = “0”}， 那再进行传参的时候就不必关心位置了，只需要关心table内的对应的key下的value是否赋值就可以了。 12345678local tbl = &#123;second = "222", first = "111", num = 2&#125;function NamedArgs(nameArgs) -- 类似这样，无需关心参数顺序，只需要关心参数值与值类型即可 if nameArgs["first"] and type(nameArgs["first"]) == "string" then -- do something end --end 下文继续记录Lua函数相关的深入要点。]]></content>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua简要笔记-1]]></title>
    <url>%2F2015%2F03%2F24%2FLua%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0-1.html</url>
    <content type="text"><![CDATA[Hello, World 直接在命令行运行(前提lua已加入环境变量中): >>print(“Hello, World!”) print语句写在文件中，如hello.lua, print(“Hello, World!”)保存在文件所在目录打开命令行，然后再执行命令: lua hello.lua lua还提供一个e选项可以直接在命令行中执行lua代码: lua -e “print(‘Hello, World!’)” lua也可以像c语言一样支持命令行参数，然后在lua中捕获这些参数值参数值都存在一个arg的全局表中 1234-- 直接输出包括脚本文件名称在内的所有参数for i = 0, table.getn(arg) do print(arg[i])end lua test.lua arg1 arg2 arg3 注释 单行注释，二个连续的中划线”–”，一行内二个中划线后的内容就被认为是注释内容 1-- single line comment in lua 多行注释，以”–[[“开头，然后以”]]”结尾的部分都会被认为是多行注释(块注释) 1234--[[muilti line comment in luaby bugcode]] 变量定义 全局变量 在lua中因为是脚本语言，不需要声明，需要变量的时候直接定义使用(就是需要的时候拿过来用) 不需要类型关键字等信息，定义的这些变量都是全局变量。 1234--未加local标识符，下面定义的都是全局变量var_def_num = 12 --定义了一个数值变量var_def_str = 'string' --定义了一个字符串var_def_bool = false --定义了一个布尔类型 局部变量 如果你想定义一下局部变量，需要在变量前加”local”关键字。应该尽可能使用局部变量，因为一来可以避免冲突，二来局部变量访问速度快于全局变量 1local var_def_loc_num = 20 --定义了一个局部变量 各种类型 可以通过lua的内置函数type来得知每个变量的类型，type函数返回一个字符串 123print(type("string"))--stringprint(type(type))--functionprint(type(nil))--nil nil nil表示没有使用过的变量，一个使用过的全局变量赋值为nil即表示删除了这个变量。 nil是值，也是一个类型，可以直接给一个变量赋值为nil。 1var_global = nil 布尔类型 false与true，只有false与nil表示false，其他的所有都表示为true(包括数值0与空字符串””) 也可以直接给变量赋值false或者true。 1local boolean = false 数值类型 在lua中数值只有一种，就是c语言中的double，并不会有浮点数的效率问题，下面的赋值都是合法的 1234var_int = 12var_float = 20.01var_math = 1.34e12var_math_neg = 0.12e-12 字符串 定义与使用，lua中比较常用的一种数据类型，可以处理_量_很大的字符串，定义的方式就是使用单引号或者双引号括起来都可以。 12var_string_dou_qt = "string in lua with double quot"var_string_sig_qt = 'string in lua with single quot' 转义 在lua中也如c语言中，支持一些转义字符，如换行，响铃之类，如下： | 符号 | 含义 || :–: | :—-: || \a | 响铃 || \b | 退格 || \f | 换页 || \n | 换行 || \r | 回车 || \t | 横向制表 || \v | 纵向制表 ||  | 转义 || \” | 双引号 || \’ | 单引号 || [] | 左，右中括号 | lua中也支持使用\xxx的方式表示字符(x为一个十进制的数字)，如\049就是数字1，\98就是小写字母b。 有些情况就是使用一些大段的字符串，而且显示的时候需要换行，这样就会在单行的字符串中出现多个\n之类的转义字符出现 可能美观上不太好看，lua提供了另一个字符串的表示方法，就是用”[[“与”]]”将要显示或者处理的字符串括起来，那么二个[[与]]之间的字符串就会是保持原样。 1234var_string_in_bracket = [[keep origion style string in luathat use double square bracket]] 字符串连接 先提一下字符的连接是”..”使用二个句点连接字符串: 12var_str = "prefix_string"print(var_str .. "_middle_string" .. "_suffix_string") 输出的就是_prefix_string_middle_string_suffix_string_。 lua中的字符串是定义后是不可修改的(类似于c语言中的字符串字面量)，但是可以用一个新的字符串变量接收修改后的字符串。这里的字符串也是不需要手动分配内存与释放内存的，都是lua自动分配与释放的。 12345var_str = "string for lua"--这里并没有改动var_str的内容，而是返回了一个新的字符串，被str_res接收var_res = string.gsub(var_str, "lua", "python")print("var_res: " .. var_res)print("var_str: " .. var_str) 字符串与数值的互转 lua会自动的在字符串与数值类型间相互转换，比如对一个字符串进行数值上才有的操作时，这时字符串就会转为数值，会在期望一个数值的地方将字符串转为数值，如果期望数值的地方不是数值或者转不成数值就会报错。同理，在期望一个字符串的地方遇到了数值，就会把数值转换成字符串。 12345-- 此时"25"会转换为数值25，var_rst就是37var_rst = "25" + 12print("12" * "4")--输出48print("12" * "str")--报错，期望str是一个数值然后与12做乘法，但是str无法转换成数值，报错！print(100 .. 200) -- 100200，数字后的连接符号前要有空格，不然可能会被解释错。 函数在lua中函数也是一个类型，也就是表示，函数在lua可以当做参数，可以赋值给变量，可以做为函数的返回值定义方法，function关键字，end结束 123function lua_function(param) --todoend Userdata和Threads userdata是c中的定义的新数据类型，它可以直接将c中的数据放在lua的变量中，并且userdata在lua中除了赋值与相等操作并没有其他预定义好的操作，threads是协同的时候需要用到的。 表达式 算术运算符 乘方操作符^，其他与C语言一致，对于减号，如果是二元运算(有二个操作数)，表示减法操作，如果一元操作(只有一个操作数)表示取负数，这些运算符的操作数都是实数，也就是上文类型中的数值类型。 关系运算符 不等于操作等是~=，其他与C语言一致，除了不等于其他都与c语言相同，进行相等比较的时候，在lua中比较二个操作数的值，如果值类型不同，那么lua认为二个值不同，对于userdata，table，function三种数据，lua则是通过比较引用来确定二个对象是否相等，也就是说，单单内部的值相等是不够的，要二个操作数表示的是同一个对象，才相等。 “10” == 10 这是不同类型的二个值，这个表达式生成false10 &gt; “2” 类似这种数值与字符串的大小比较，lua会直接报错 逻辑运算符 | 符号 | 作用 || :–: | :–: || and | 与 || or | 或 || not | 非 | 上文布尔类型的时候说过，lua中除了nil和false是false，其他都是true，逻辑运算也就与c语言相同了有二个技巧可以用，因为在lua没有三元运算符，可以这样实现 12-- x ? y : z(x and y) or z 还有一种常用的变量非nil测试并赋值 12345x = x or val--等价于if x == nil then x = valend 连接运算 字符串的时候提到过了，二个句点，用于连接二个字符串，如果操作数是数值类型，则会把数值转换为字符串，但是数值使用连接符号的时候空格是必须的，以防解释错连接符作用 构造表由构造器(constructor)来构造表，最简单的表的构造 1tbl = &#123;&#125; -- 这就构造了一个空的表 也可以直接像c语言的数组初始化一样定义的同时初始化表1halfy_month_tbl = &#123;"1", "2", "3", "4", "5", "6"&#125; 这就相当于把”1”放在了halfy_month_tbl[1]中，依次类推(lua中索引从1开始，而不是从0开始)还可以使用类似于键值的方式来初始化表1rect_tbl = &#123;wid = 10, hgt = 20, name = "Rectangle"&#125; 此时访问对应的表中的数据，需要使用标签索引，rect_tbl[“wid”] -&gt; 10, rect_tbl[“name”] -&gt; “Rectangle”也可以使用rect_tbl.hgt来访问hgt域而且我们可以随时向表中添加或者删除任何类型的域，构造器只是在初始化的时候起作用1234567891011--初始化一个表ext_tbl = &#123;x = 10, y = 15, desc = "extension"&#125;tmp_tbl = &#123;is_add = false, z = 10.01&#125;--向ext_tbl中添加一个域，内容是一个表ext_tbl["ext"] = tmp_tblext_tbl[1] = "test_area"--删除ext_tbl的一个域ext_tbl["x"] = nilprint(ext_tbl[1]) -- "test_area"print(ext_tbl.ext["z"]) -- 10.01print(ext_tbl.x) -- nil 因为每次使用构造器的时候都产生一个新的表，可以用这个特性生成一个链表1234567891011linked_list = nil--构造链表for i = 1, 20, 2 do linked_list = &#123;n = linked_list, v = i&#125;end--反序输出tmp = linked_listwhile tmp do print(tmp.v) tmp = tmp.nend 表也可以在初始化的时候同时使用没有域名字与有域名字的1234567tbl = &#123;x = 10, y = 30, "first"&#125;print(tbl.x) -- 10print(tbl[1]) -- "first"--还可以使用嵌套表的结构init_tbl = &#123;name = "table", area = 10, &#123;a = 1, b = 2&#125;, &#123;is_loop = true, has_prefix = false&#125;&#125;print(init_tbl[1].a) -- 1print(init_tbl[2].has_prefix) --false 我们不能使用负索引来初始化，还有一种更通用的方式来初始化字符串索引的表,使用[exp] (中括号加字符串的方式来表示字符串索引)12week_tbl = &#123;["mon"] = 1, ["tues"] = 2, ["wed"] = 3, ["thu"] = 4, ["fri"] = 5, ["sat"] = 6, ["sun"] = 7&#125;print(week_tbl["mon"]) -- 1 表初化的最后一个域后的逗号是可选的，可加可不加，加上是为了经后的扩展，逗号也可以用分号(;)来替代，通过的做法是同类型的用逗号，不同类型间的用分号分隔1type_tbl = &#123;num = 10, 100; str = "string", "value"; boolean = false, true&#125; 语法 赋值语句 单变量赋值，像c语言一样，等号左边是变量右边是表达式 12assign_var = 100var_str = "pre" .. "str" 多变量赋值，左边是用逗号分隔开的一个变量的列表，右边是表达式的列表，如果变量数目多于表达式个数，则后面的变量是nil，如果表达式数目多于变量数目，那么多的表达式就会丢弃: 123x, y, z = 100, false, "multi" .. " assignment"a, b = 10, 20, 30 --30会被丢弃k, l, m = 1, 2 -- m --&gt; nil 交换变量，在lua中交换二个变量非常简单，反序赋值就可以了 12x = 10; y = 20x, y = y, x -- 完成了交换 x --&gt; 20, y --&gt; 10 流程控制语句 if..else 形式是这样的 12345678910111213141516171819x = nil--单个的ifif not x then x = 100end--if与elseif x == 100 then x = x - 10else x = x + 10end--if..elif..elseif x == 100 then print(x) elif x == 10 then print("x == 10")else print("else condition")end while 形式是 123456index = 1fact = 1while i &lt; 10 do fact = fact * iendprint(fact) repeat..until 类似于c语言的do..while 12345678i = 1sum = 0-- compute 1 to 10 summaryrepeat sum = sum + i i = i + 1until i &gt; 9print(sum) for循环 普通for循环 12345678--1 to 20 with 2 increament_start = 1 --起始值_end = 20 -- 结束值，由start与end构成的_step = 2 -- 每次循环i的增量，可为负值-- !此处的i是局部变量，只在for循环的作用域内起作用for i = _start, _end, _step do print(i)end 范型for循环, 通过ipairs与pairs迭代器 123456789--输出数组中所有的数值tbl = &#123;1, 3, 5, 6; false; "end"&#125;for i, v in ipairs(tbl) do print(v)end--输出表中的keyfor i in pairs(tbl) do print(tbl[i])end ipairs 只能迭代到表中非整数的key为止，并且不返回nil，只返回0，遇到nil就退出pairs 能迭代表中所有的key，并且能返回nil 123456789tbl_es = &#123;[1] = "11", [2] = "22", [5] = "55", ["six"] = false&#125;--只输入11与22，因为迭代到3的时候是nil，遇到nil就直接跳出了for i, v in ipairs(tbl_es) do print(v)end--遍历所有的表中的keyfor i in pairs(tbl_es) do print(tbl_es[i])end break与returnbreak作用与c语言相同都是跳出循环的，在lua中包括while， repeat..while， for循环return是从函数中返回值用的，一般的时候都是出现一个语句块的最后，但是如果有需要在中间需要return的时候需要使用do..end括起来形成一个语句块 123456789function return_test() for i = 1, 100, 2 do if i == 13 then do return end else print(i) end endend]]></content>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序图解]]></title>
    <url>%2F2015%2F03%2F10%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3.html</url>
    <content type="text"><![CDATA[归并排序笔记，记录下来也希望可以帮助他人，尽可能说得明白。 归并排序是一种分治法的典型应用，就是将一个待排序的无序表不停的切割二部分，再对这二部分再切割成二部分，一直进行到每个单独的部分都只剩一个元素（一个元素就可以认为是这个元素是有序的，在代码上也就是使用递归，切分数组为N个小数组，直到每次小数组长度为1），这就是分治（递归）的出口，切割的部分只剩一个元素的时候，每个单独的元素当做一个有序表，开始合并每个切割的部分，每次合并，就相当于把二个有序表合并成一个有序表，上面是“拆分”开来，现在“合并”回去，直接到整个表都合并完成，这样这个无序表就变成了有序表。可能说不是很明白，还是像上次的快速排序，看图可能理解得更快一些。 下面有一个待排序的数组（无序表）： 有一个这样儿的无序数组（叫array），接下来一步一步演示用归并排序把这个无序数组按从小到大的顺序排列。 切分数组，以数组长度的中点为界将数组array切割为二部分，数组长度为11，中点为5，这样数组就被切分为array[0…5]和array[6-10]二部分： 初切分出来的二个子数组长度都大于1，则对其左侧继续切割拆分，左侧与右侧运用相同的分治原则，现在图示只拿左侧部分进行归并演示（右侧与左侧的过程相同），左侧数组长度为6，中点为3，数组被切割为array[0…3]与array[4…5] 左侧依然长度大于1，继续对左侧切割拆分，子数组长度为4，中点为2，则数组拆分为array[0…2],array[3] 左侧数组长度仍然大于1，继续切分，子数组长度为3，中间为1，切分为array[0]与array[1..2] 此时左侧子数组长度为1，只剩下一个元素（一个元素被认为是自有序的），左侧递归完成，开如4步中的右半部分拆分，右半部分数组长度为2，中点为1，数组拆分为array[1]与array[2] 此时左边长度为1，不再递归切分，开始切分右边，右边长度也为1，也不再递归，那么这二个子数组开始合并，二个单独的子数组做排序归并处理（小在前，大在后），合并后的子数组为： 到此相当于第4步中右侧的子数组处理完毕开始返回，开始与第4步中左侧的子数组合并处理： 到此相当于第3步的左侧归并完毕，开始对右侧进行切分，右侧的子数组长度为1，不再进行拆分，直接开始与第7步中刚刚归并处理完的子数组继续归并： 到此相当于第2步的左侧都归并处理完毕，开始对右侧进行切分处理。右侧长度为2，中间为1，数组为array[4]与array[5] 再对左侧进行切分，左侧子数组长度为1，不再递归，对右侧进行切分，右侧长度也为1，不再递归切分，二个子数组开始归并处理： 到此相当于第2步的右侧归并处理完毕，开始与左侧刚才已归并处理好的子数组进行归并处理: 进行到这一步，就已经对第1步的左侧完全合并处理完成，开始对右侧进行切分，右侧也与刚才图示的左侧的切分过程完全相同，切分到子数组长度为1的时候，开始对子数组一路进行归并处理，直到像11步这样对右侧完全归并处理完成，右侧归并完成就是(省略具体切分过程，与上述左侧切分过程完全相同)： 到这里，第1步的右侧归并完成，开始与左侧已经归并处理完成的子数组进行最终的归并处理，最后就得到了一个排好序的数组： 这样儿就是一个完整的归并排序的过程。如果有错误请您指出，非常感谢_。下面是代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;void merge_sorted_array(int *array1, int array1_len, int *array2, int array2_len)&#123; int merge_array[array1_len + array2_len]; int arr1_loc = 0; int arr2_loc = 0; int merge_arr_loc = 0; //二个数组从开始比较，小的放到数组中 while (arr1_loc &lt; array1_len &amp;&amp; arr2_loc &lt; array2_len) &#123; if (array1[arr1_loc] &lt;= array2[arr2_loc]) &#123; merge_array[merge_arr_loc++] = array1[arr1_loc++]; &#125; else &#123; merge_array[merge_arr_loc++] = array2[arr2_loc++]; &#125; &#125; //数组中有剩余，则全部加入到合并数组中 while (arr1_loc &lt; array1_len) &#123; merge_array[merge_arr_loc++] = array1[arr1_loc++]; &#125; while (arr2_loc &lt; array2_len) &#123; merge_array[merge_arr_loc++] = array2[arr2_loc++]; &#125; //最后把辅助数组，覆盖到原数组 for (int i = 0; i &lt; merge_arr_loc; i++) &#123; array1[i] = merge_array[i]; &#125;&#125;void merge_sort(int *array, int size)&#123; if (size &lt; 2) &#123; return ; &#125; else &#123; int *pre_part = array; int *next_part = array + size / 2; int pre_len = size / 2; int next_len = size - pre_len; merge_sort(pre_part, pre_len); merge_sort(next_part, next_len); merge_sorted_array(pre_part, pre_len, next_part, next_len); &#125;&#125;int main(int argc, char *argv[])&#123; int array1[11] = &#123;2, 5, 0, 9, -1, 10, 89, 1, 23, 17, 3&#125;; merge_sort(array1, 11); for (int i = 0; i &lt; 11; i++) &#123; printf("%d\n", array1[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序图解]]></title>
    <url>%2F2015%2F02%2F15%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3.html</url>
    <content type="text"><![CDATA[快速排序原理记录及实现，用了几张图示，虽然是篇笔记，但尽力让所有人明白。 快速排序的原理就是一个数组在单趟的排序中，找到一个基准值，按这个基准值的所在的位置做为分界（下标），这趟排序保证的就是这个基准值位置的左边都是小于（或者大于）基准值的数，而基准值位置的右边都是大于（或者小于）基准值的数，然后再从数组的右边开始扫描，把每个值依次与基准值相比较，大于（或者小于）基准值的值不动，小于（或者大于）基准值的就移到左边，再开始从左边开始扫描， 仍然是把每个值与基准值比较，小于（或者大于）基准值的值不动，大于（或者小于）基准值的值移到右边，接着再进行右边扫描，直到二个扫描下标相遇，这趟排序就完成了，然后再按这个基准值的位置（下标），把这个数组分为左半边与右半边，然后再次使用上面的策略进行排序，这就是快速排序的基本原理，按我的理解就是每一趟的排序找到这个基准值的准确位置（每次确定一个值的排序好之后的位置）。下面看图，一个原始数组，一个左侧的扫描指针，一个右侧的扫描指针，一个基准值，就定为数组0位置的值： 最开始的数组情况就是这样的。（下面的举例是按数组排序从小到大演示），下面开始第一趟排序，就是如上面所说，右侧扫描指针从右侧开始向左移动，并依次取出对应下标的值与基准做比较，如果值大于基准值，指针向左移，过程就是： 第一次：array[10] &gt; 2,指针向左移。 第二次：array[9] &gt; 2, 指针向左移。 第三次：array[8] &gt; 2, 指针向左移。 第四次：array[7] &gt; 2, 指针向左移。 第五次：array[6] &lt; 2, 第五次的时候，对应下标的值不再大于基准值，那么就开始移动这个值到左侧，接下来的数组就是这样： 下面开始左侧指针移动，并依次取出下标对应的值与基准值做比较，如果小于基准值，指针向右移动，如果大于基准值，那么就开始移动这个值到右侧，过程就是： 第一次：array[0] &lt; 2, 指针右移。 第二次：array[1] &gt; 10, 此次左侧指针下取出的值大于基准值2，那么开始把这个值移动到右侧，数组就变成这样： 左侧移动完成，下面又开始移动右侧，如上所述，大于基准值就左移，直到遇到小于基准值的位置，过程如下： 第一次：array[6] &gt; 2, 指针左移。 第二次：array[5] &gt; 2, 指针左移。 第三次：array[4] &gt; 2, 指针左移。 第四次：array[3] &gt; 2, 指针左移。 第五次：array[2] &lt; 2, 此时指针下取出的值小于基准值，这个值要移动到左侧，数组情况如下： 再次开始移动左侧，小于基准值不动，大于基准值向右移，过程如下： 第一次：array[1] &lt; 2, 指针右移。 第二次：array[2], 此时右侧指针也在array[2]处，此趟排序调整到此完成。 二个指针相遇的地方也就是开始确定基准值应该所在的位置，这趟排序过后数组变成： 也就是像上面所说的，每趟的排序都会把排序好之后的基准值的位置找到。 这是第一趟排序，下面就是使用分治，分别对现在基准值的位置的左半部分与右关部分运用像上面一样的策略来分别排序。 那么根据此原理就可以写出代码，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;void quick_sort(int *array, int low, int high)&#123; //保证是左右二个部分 if (low &lt; high) &#123; int left = low; int right = high; //找到基准值 int base_value = array[low]; // 确定每次移动都是左侧与右侧不交叉 while (left &lt; right) &#123; //右侧指针向左移动 while (left &lt; right &amp;&amp; base_value &lt;= array[right]) &#123; right--; &#125; //找到了小于基准值的值，直接移动左侧 array[left] = array[right]; //开始左侧扫描 while (left &lt; right &amp;&amp; base_value &gt;= array[left]) &#123; left++; &#125; //找到大于基准值的值，直接移动到右侧 array[right] = array[left]; &#125; //二个指针相遇，base_value值位置找到 array[left] = base_value; //按base_value所在位置分别按上面的策略进行分别处理 quick_sort(array, low, left - 1); quick_sort(array, left + 1, high); &#125;&#125;int main(int argc, char *argv[])&#123; int unsort_array[10] = &#123;1, 0, 10, 9, 23, -1, 3, 19, 89, 11&#125;; quick_sort(unsort_array, 0, 9); for (int i = 0; i &lt; 10; i++) &#123; printf("%d\n", unsort_array[i]); &#125; return 0;&#125; 这就是快速排序的基本原理与实现图解与代码。]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下编译Clang]]></title>
    <url>%2F2015%2F01%2F07%2FWindows%E4%B8%8B%E7%BC%96%E8%AF%91Clang.html</url>
    <content type="text"><![CDATA[网上最近一直在说Clang这个编译器，说FreeBSD已完全使用Clang为默认编译器，Mac下也是这个编译器，“据说”编译速度比Gcc快出很多，生成出来的可执行文件也比Gcc生成的要小那么几个KB，还有错误提示也要友好很多，更还有各方“大家”对此嗤之以鼻。但是不管如何，做为一个喜欢瞎折腾的码农，不管各个大家是怎么说，自己一定要上手试试的。因为在Windows下没有Clang的二进制包，本着自己动手丰衣足食的原则，决定自己构建一个尝尝鲜（虽然这个’鲜’已然过去很久了）， 其实构建过程很简单，官网上的getting started说得很明确了，这里也只是再用中文重复一下： svn的客户端，大多数都是直接使用TortoiseSVN，也就是那个“小乌龟”，用来check代码的，当然也可以直接去下source包。 cmake，一个跨平台的makefile生成工具，可以生成不同平台的各种makefile或者project文件。 vs2008或者vs2010，这个应该不用多说了，用windows的都知道。 三个工具安装好，并确保cmake的bin目录在path中，就可以开工了。 新建一个文件夹来放由svn检出的代码，比如d:/clang_llvm，之后用TortoiseSVN首先检出llvm的代码到llvm文件夹，然后再检出clang的代码到clang文件夹，再将clang文件夹全部移动到llvm下的tools文件夹下(TortoiseSVN)直接嵌入到右键菜单中，直接在clang_llvm文件夹中check out，填入链接和本地目录，OK即可）。完成后，回到clang_llvm文件夹下，此时文件夹中只有llvm目录，在clang_llvm下新建文件夹build。控制台进入到clang_llvm下的build目录下，执行如下命令： 如果是vs2008，则是：camke –G “Visual Studio 9 2008” ..\llvm 如果是vs2010，则是：cmake –G “Visual Studio 10” ..\llvm 如果运气不错，执行完毕后，生成LLVM.sln。使用vs打开这个解决方案。选择ALL_BUILD构建，漫长的等待… 完成后就可以在build/bin/Debug或者build/bin/Release文件下看到对应的类似clang.exe这样的生成文件了。将可执行文件所在目录加入path，就可以写一个test.c来测试一个clang了 1clang –Wall test.c –o test 下面是一个测试的例子： 12345678910111213#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 2) &#123; printf("%p\n", &amp;i); &#125; printf("%d\n", i + 1); &#125; return 0;&#125; 12gcc –Wall –std=c99 test.c –o test_gcc.execlang –Wall –std=c99 test.c –o test_clang.exe 编译均通过。下面是生成的可执行文件大小截图： 看起来clang生成的可执行文件的确比gcc生成的可执行文件要小，当然，这么一个小例子也说明不了什么。继续…… 现在将源代码改出二个错误[一个算做逻辑错误，一个语法错误]，如下： 12345678910111213#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; for (int i = 0; i &lt; 10; i++) &#123; if (i = 2)//这里改为赋值 &#123; printf("%p\n", &amp;i); &#125; printf("%d\n", i + 1)//这里故意去掉了分号 &#125; return 0;&#125; 先看gcc的错误和警告提示截图[编译命令同上]： gcc在第7行，也就是注释的第1行，给出了一个警告建议，第12行，也就是大括号前给出了一个语法错误提示。 下面再看clang的警告和错误提示截图[编译命令同上]： clang这里给出的语法错误就比较直观了，直接能看到哪里出现了错误，定位到具体位置，而且针对“逻辑错误”，给出修改建议。当然这也只是一个小小的错误，也说明不了什么，码农的尝鲜clang就到此了^_*。]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C99标准笔记]]></title>
    <url>%2F2014%2F06%2F16%2FC99%E6%A0%87%E5%87%86%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[c99标准也就是C语言在99年修订的最新标准，想一下99年我还在上小学-_!，虽然只是一个c99某些新特性的笔记，尽量写清楚，做笔记的同时，也可以对大家有帮助。 个人感觉最常用的莫过于别的语言都已经有的，for循环内变量的初始化，如在c99之前ansi c标准的for循环代码都是这样来写： 12345int i = 0;for (i = 0; i &lt; val; i++)&#123; // some code&#125; 而c99标准里可以将变量放入循环体当中，如下： 1234for (int i = 0; i &lt; val; i++)&#123; // some code&#125; 之所以放在第一位是感觉这个太常用了。 双斜线形式的注释，c99之前的的注释都是 / code comments /，c99标准加入了//这种c++的形式的单行注释。 变长数组，c99之前的数组长度是必须固定的，想要变长就需要使用malloc动态分配动态长度的内存，如下： 123456int *vla = (int *)malloc(sizeof(int) * length);for (int i = 0; i &lt; length; i++)&#123; vla[i] = i;&#125;// 使用完之后free(vla) 有了c99标准就可以直接在使用数组的时候，定义一个数组长度是变量的数组，如： 12345for (int i = 0; i &lt; length; i++)&#123; array[i] = i;&#125;// 只限于在创建时动态指定，后期不可随意变动长度 这样就定义了一个长度为length的数组，length可以手动指定。但是这种变长数组的意思是指在确定数组长度的时候可以动态的（由变量来指定），并不是指在创建数组之后可以随意变动数组的长度。 指定域的初始化，也就是c99中可以对结构体或者数组进行某一部分的初始化，或者是某个成员的初始化。如下： 12345678910111213141516171819202122#include &lt;stdio.h&gt;struct Test&#123; int fir; long sec; struct Test *m_ptr;&#125;;int main(int argc, char *argv[])&#123; //只针对数组中的0，5，8三个下标位置进行初始化，其他都为0 int array[10] = &#123;[0] = 1, [5] = 10, [8] = 12&#125;; for (int i = 0; i &lt; 10; i++) &#123; printf("array[%d] == %d\n", i, array[i]); &#125; //只针对后二个成员进行初始化，第一个默认初始化为0 struct Test t = &#123;.sec = 100L, .m_ptr = NULL&#125;; printf("%d\n", t.fir); return 0;&#125; 可伸缩型的数组成员，这个在gcc中早就有对应的扩展，常见的写法就是： 12345struct fixible&#123; int flag; char ext[0];&#125;; 这样儿的好处就是不用指定ext的最大范围，而是根据需要，灵活指定ext所需要的长度。c99把这个功能加了进来。一个常见的例子就是统计每一行文本的长度与内容，长度未知的情况，可以这么写： 1234567891011121314struct lines_counter&#123; int line_length; char content[];//必须放在成员最后&#125;;void save_content(int line_len)&#123; struct lines_counter *lc = (struct lines_counter *) malloc(sizeof(struct lines_counter) + line_len + 1); //do something lc-&gt;line_length = line_len; //XXX&#125; 这样针对不同长度的文本，都会分配正合适大小的结构来存储长度与内容。 bool类型，c99加入了一个stdbool头文件，里面定义了bool的false与true。这个不用多说，#include &lt;stdbool.h&gt;, 就可以用false与true了。不用自己再define或者enum了。 混合声明，之前的c语言都是一堆变量都在函数开头一股脑的定义好，现在有了c99标准，就可以随时定义变量并使用而不必全部写在开头了。 func内置常量，c99加入了这个常量，义指func所在行所处的函数名。这个对于调试还是相当有用的。可以直接通过调试语句配置LINE打印出log所在的函数。 上面提到了调试语句，就不得不提另一个比较好用的，变参宏，c99加入变参宏，可以让程序员很自由写一些带变参的调试宏，如： 12345678910#include &lt;stdio.h&gt;#define DEBUG(format,...) \ printf("[Debug]: " format " -- %s -- %d \n",##__VA_ARGS__,__func__,__LINE__)int main(int argc, char *argv[])&#123; DEBUG("%d == %s", 10, "debug print"); return 0;&#125; 当然变参部分也可以为空串，为空串那么##VA_ARGS就会直接展开成空的字符串，也就是完全可以DEBUG(); 这样来调用这个调试语句，这只是一个示例，你可以将调试语句写得更精细 复合常量，也就是在c99标准里的c可以定义一个匿名的结构体或者数组，常用的地方应该就是构造一个临时变量，传给函数做参数。 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;struct Point&#123; int x, y;&#125;;struct Rect&#123; struct Point *point; int wid; int len;&#125;;void test_func(int *array, int size)&#123; for (int i = 0; i &lt; size; i++) &#123; printf("%d\n", array[i]); &#125;&#125;void test_func2(struct Rect *rect)&#123; printf("point &#123;%d, %d&#125; %d -- %d\n",rect-&gt;point-&gt;x, rect-&gt;point-&gt;y, rect-&gt;wid, rect-&gt;len);&#125;int main(int argc, char *argv[])&#123; test_func((int [])&#123;1, 2, 3, 5&#125;, 4); test_func2(&amp;(struct Rect)&#123;.point = &amp;(struct Point)&#123;.x = 10, .y = 10&#125;, .wid = 50, .len = 70&#125;); return 0;&#125; 这样在实际项目中可能很少这样来用，但是对于测试代码应该很有帮助，不用再定义一个变量初始化好了再传入参数，直接使用复合变量直接传入就可以了，节省了一步操作。针对团队项目来说，应该是写清楚明了更有助于大家开发。 long long类型，没错，就是c99才开始支持的，scanf和printf的格式化字符串ll或者LL也是c99才开始支持的。同时引用了float，double complex复数，增加了相关复数运算，都在&lt;complex.h&gt;头文件中。 inline关键字，c99为c引入了内联函数，普通的宏只是单纯的字符串展开与替换，内联函数可以进行一些参数检查等相关的一些宏做不到的事。在本文件中使用刚需要声明为static inline，如果需要外部使用则需要在声明中extern inline，否则会出现编译不过的情况。]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile初步-3]]></title>
    <url>%2F2014%2F05%2F01%2FMakefile%E5%88%9D%E6%AD%A5-3.html</url>
    <content type="text"><![CDATA[如果想在一个makefile中引用其他的文件，也就是包含进其他的makefile文件到此Makefile文件，像C语言一样儿，使用include命令 include filename 如：include others.mk 这样就相当于在include文件的地方原封不动的把others.mk的内容展开到此处，filename中可以包含通配符，路径等，如： include *.mk ../make_dir/test.mf 就是包含当前目录下的所有的mk后缀的文件，还有上一层目录下make_dir目录中的test.mf文件。如果make工具在指定的目录中并没有找到对应的文件，那么make就会去下面几个地方继续寻找： 如果在make命令行中指定了—include-dir参数，那make就会去这个参数指定的目录中去寻找对应的文件。 如果usr/local/bin/或者usr/include存在，make也会去这里寻找。 如果找到对应的文件，那么make会继续执行makefile的展开工作，如果没有找到对应的文件，那么make也会继续工作，继续装载其他的文件，只会在此处生成一个警告信息，直到makefile完全读取完成，这时，make会回过头继续寻找刚才没有找到的文件，如果再次没有查找到对应的文件，这是make就会报一条fatal error（致命错误），从而中止make工作。如何使make在最后即使没找到对应的文件报错误之后也继续进行make工作呢，那就是在可能出现错误的include前加上一个-（减号），这样make就是忽略错误继续执行，这个-（减号）可以用在多处，比如用在clean的时候，-rm *.o，这就表明，在删除目录文件的时候如果出现问题也不要理会，继续删除操作。 说到这里不得不说的一个东西就是MAKEFILES环境变量，这个环境变量的值是N个空格分开的文件名，如果系统中有这个环境变量，那么make在执行的时候就会把这个环境变量的值，做一个相当于引入的操作，即把环境变量中定义的几个文件都会引用进来，而且其里面定义的目标不会当做最终目标来构建执行，出现错误也不会停止，官方的说法是不建议使用这个环境变量，尤其在多个makefile时，每个makefile都会读取这个环境变量一次，稍有不慎可能就引起不必要的麻烦，如果想包含什么文件，还是直接include XXX来的好。 说完这个再说一下文件搜索，通常一个工程中，可能头文件会放在一个目录中，实现的对应的文件放在另一个目录中，难道我们还要在编写makefile的时候每一个都手动的去加上一个路径么？当然不必，make工具已经想到这一点了。VPATH变量就是解决这个问题的，如，Makefile所在的当前目录中有source和header二个目录分别放着实现文件与头文件（假设），那么搜索路径就可以这么来写： VPATH = ./source:./header（中间用冒号分隔） 这样儿make在当前目录找不到就会按次序去source和header目录下去寻找文件了。用这个变量有时候可能不太灵活，有时候可能只希望在某个目录下查找指定的文件。那第vapth就该出场了（大小写之分）。 用vpath可以按模式来指定要在某个目录下搜索什么样儿的文件，用法如下： vpath (要搜索的文件) (目录) vapth (目录) vpath 第一种，在指定的目录下搜索指定模式的文件，这里的模式指的是可以使用通配符的匹配模式，目录就是指定的搜索目录。如：vpath %.cpp ./source意思就是在当前目录下的source目录下搜索所有以cpp后缀的文件，如果有多个目录就使用空格或者冒号分隔。 第二种，清除符合某个指定模式的所有目录，如：vpath %.mm 这样就是清除了之前为所有mm后缀的文件设置的搜索的路径。 第三种，直接就一个vpath，意思就是清除所有的文件之前设置的搜索路径。 这大致就是makefile的文件包含与路径搜索设置的简单用法。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile初步-2]]></title>
    <url>%2F2014%2F04%2F03%2FMakefile%E5%88%9D%E6%AD%A5-2.html</url>
    <content type="text"><![CDATA[接上文，假如有如下一个Makefile其中一部分是这样的： 12obj: utils.o display.o edit.o interface.o save.o gcc –std=c99 –g utils.o display.o edit.o interface.o save.o -o main 而且obj的依赖还会不停的变动，增加或者减少，更可能的是这一组依赖还会出现在文件中的其他地方，命令规则的参数也可能有很长一串，那想想，每次都要写这么多的文件名/命令字符串，的确是个很麻烦的事，而且还容易出错，更不容易查错。make已经为我们想到了替代方式，就是用一个变量来替代这一组长长的文件名列表/参数选项列表，在make规则中只使用这个变量来代替那一组文件列表，这样既能减少错误，还能减少工作量。 通常使用变量的使用是OBJ = XXOO OOXX或者FLAG = ZZZZ等形式，在引用的时候使用$(美元符)加以引用，如$(OBJ)，这样儿在引用的时候，就像C语言的宏替换类似，变量所代表的名称列表就会被展开到，对应的位置，如上面的例子就可以写成： 12345678OBJ = utils.o display.o edit.o interface.o save.oCFLAGS = -std=c99 CC = gccmain: main.c $(OBJ) $(CC) $(FLAGS) main.c –o main .PHONY:clean clean: rm $(OBJ) main 这样就可以避免多处引用的时候出现写错的情况。 关于简单的自动推导，就是make工具有一个默认规则，给出目标和依赖，如果没有生成的命令，那么就会默认按照cc –c XXX.c –o XXX.o的形式，自动生成对应的目标文件。那么，在Makefile初步-1中所写的文件，就可以变成这样： 123456789OBJ = utils.o display.omain: main.c $(OBJ) utils.o: utils.h utils.c display.o: display.c display.h .PHONY: clean clean: rm -f $(OBJ) main 虽然能省不少打字的工夫，但是还是写明生成规则比较好，因为有助于后期的维护。这就是Makefile中简单的变量和自动推导规则。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile初步-1]]></title>
    <url>%2F2014%2F03%2F31%2FMakefile%E5%88%9D%E6%AD%A5-1.html</url>
    <content type="text"><![CDATA[在Windows下有诸如vs这样儿“强大”的工具来组织与管理工程，文件层次组织，代码编写，包括选项的设置，编译，链接，都可以在一个窗口中完成（其实背后也是有一个make工具）。Linux下，Unix的哲学，多个不同功能的小工具，组合到一起组成强大的功能，一些小小的文件，我们可以gcc –XXFlags XXOO.c –o XXOO，这样儿来做，但是要是几十个文件，几百个文件呢？还去挨个的输入命令编译？这就是是马上要介绍的make工具，使用make工具，只需要一个命令，就可以构建你的工程。当然，代价就是编写Makefile，make工具就是靠解释Makefile文件来对整个工程进行编译和链接。 这里先给出一个简单的示例，只为说明用法，简单写了几个文件如下： utils.c,utils.h,display.c,display.h,main.c内容如下（非常简单） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#ifndef _UTILS_H_#define _UTILS_H_#include &lt;stdlib.h&gt;float compute_add(float a, float b);int get_rand();#endif// [utils.c]#include "utils.h"float compute_add(float a, float b)&#123; return a + b;&#125;int get_rand()&#123; return rand() % 10;&#125;// [display.h]#ifndef _DISPLAY_H_#define _DISPLAY_H_#include &lt;stdio.h&gt;void print_rand(int rand);void display_float(float res);#endif// [display.c]#include "display.h"void print_rand(int rand)&#123; printf("rand number: %d\n", rand);&#125;void display_float(float res)&#123; printf("result : %f\n", res);&#125;// [main.c]#include "display.h"#include "utils.h"int main(int argc, char *argv[])&#123; print_rand(get_rand()); display_float(compute_add(1.0f, 3.0f)); return 0;&#125; 如果按最平常的方式，怎么做呢？你肯定想到，先编译utils，display和main为目标文件，再链接三个目标文件，生成main。至少三个命令，有人说了，也不多，那再想，如果我改动了utils文件，那就要再编译utils，再链接main。所以，该Makefile上场了： 12345678910111213# makefile for samplemain: main.c utils.o display.o gcc main.c utils.o display.o -o main utils.o: utils.h utils.c gcc -c utils.c -o utils.o display.o: display.c display.h gcc -c display.c -o display.o .PHONY: cleanclean: rm -f *.o main 这就算是一个小小的Makefile了，慢慢看一下它。 首先，#号开头，Makefile的注释，作用从行首到行尾，如果想换行，需要加上\转义换行。 接下来有三个名称然后跟冒号，这三个名称（或者叫文件名）叫做目标，就是要生成的东西，无论是生成的中间文件，还是最终文件，都叫做目标，通常放在第一个位置的都是最终要生成的目标，如本例是main。 之后冒号后跟了几个空格分隔的名称（文件名），这叫做依赖，看名字就是知道，意思就是目标文件要生成，那么就依赖这几个文件，也就是生成这个目标的必要文件，没有先后顺序。 然后，每个目标和依赖的下一行都有一行命令，这个命令就是上面的依赖，通过下面的命令生成目标，需要注意的是，命令需要以Tab开头，不然make不会识别，如果Makefile某个部分过长，可以通过\来转到下一行继续。 根据上面几个部分的具体规则，就可以在本目录下通过make命令构建出最终目标了，默认是生成第一个目标文件，想只生成其中的某个目标，可以使用make obj类似的命令，如本例，如只想生成utils.o文件，则可以用make utils.o命令。每次的构建生成，make工具都会检测每个对应的文件是否是最新生成的，如果某个文件不是最新生的，那么make将重新构建对应的目标，如果某个目标的依赖是这个重新构建的目标，那么同样儿的，这个目标也会被重建。make的工作方式就是解释Makefile，以现第一个目标，然后去寻找它的依赖，如果依赖存在，就寻找下一个依赖，如果这个依赖不存在，就去找对应的依赖的作为目标的构建规则，直到生成这个依赖，有点儿像C语言里面的递归。层层下去，然后最终文件都齐全了，生成最终目标。 再看这个小Makefile的最后三行，.PHONY:XXX指示其冒号后的这个目标是伪目标，也就是防止在make XXX的时候，当前目录下正好有一个叫做XXX的文件，那么make就会现错误或者停止工作了。声明这个伪目标，make XXX的时候，就不会出现上述状况了，而这个例子中clean下面的命令，就是清除生成的文件（包括是中间文件和最终目标，像一般IDE里的清理生成，清理解决方案之类的。），make clean之后，生成的是中间和最终文件就全被删除了，再次make，就是重新构建了。 感兴趣的也可以自己组织一个小“工程”，练习一下Makefile的初级使用。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的隐式类型提升和java的类型兼容]]></title>
    <url>%2F2014%2F02%2F12%2FC%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87%E5%92%8Cjava%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9.html</url>
    <content type="text"><![CDATA[在java里，x += 1与x = x + 1相同，但是是有一点区别，只不过容易被忽略。如下例： 12345678910111213141516171819public class TestCompound&#123; public static void main(String[] args) &#123; short x = 1; x += 1; System.out.println(x); &#125;&#125;//此处x打印的值为2；public class TestCompound2&#123; public static void main(String[] args) &#123; short x = 1; x = x + 1; System.out.println(x); &#125;&#125; 而此处的x = x + 1处就会在编译期报错，因为java编译器认为x + 1是int型的，把int型的赋给short型，类型不兼容，就会报错，要赋值就需要一个强制类型转换，那么在此，二个表达式的区别就看出来了，x += 1，这里暗含了一个自动的类型转换，它会自动把右边的值转换成左边的类型，所以在第一个例子中没有报错，而第二例子中的表达式不会自动转换类型，报错就是必然的了。java的类型转换精度小的向精度大的进行转换，字节长度小的向字节长度大的转换，这里x + 1，x是short类型，x + 1之后编译器认为可能会造成溢出编译器做一个扩宽转换（widening conversion），x + 1的结果值直接向int进行类型，结果在赋值的同时发现x是short类型，这里出现了赋值类型不匹配，造成错误的出现。 C语言中也有一个类型转换的规则在，而且在很多的时候容易引起错误的结果，就是隐式类型提升（TypePromotion），先看一段代码： 123456789101112131415#include &lt;stdio.h&gt;int array[] = &#123;2, 3, 4, 5, 6, 7, 8&#125;;#define GET_LEN (sizeof(array) / sizeof(array[0]))int main(int argc, const char *argv[])&#123; int testValue = 0; int promotion = -1; if (promotion &lt;= GET_LEN) testValue = array[promotion + 1]; else testValue = array[promotion + 2]; printf("testValue == %d\n", testValue); return 0;&#125; 可能有很多像我这样的菜鸟级选手就会说，输出的是2，也就是if判定是成立的，testValue=array[0] 其实并非如此，promotion &lt;= GET_LEN这个表达式包含一个隐式的类型提升，导致结果是testValue == 3，也就是testValue == array[1];因为sizeof的返回一个size_t类型，也就是unsigned int 类型，也就是GET_LEN宏得到的结果就是unsigned int类型，而表达式的左边promotion是一个int，那么在二者比较的时候，编译器会做一个算术的类型转换，右侧的类型unsigned和而promotion是signed的，有符号的会向无符号的类型转换，那么promotion会提升成unsigned int类型，那么编译器就会把-1解释为一个很大的正整数，也就会有testValue == 3的结果了，想要消除这个错误给GET_LEN一个强制类型转换就可以了。同样的例子还有，看代码： 123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main(int argc, char *argv[])&#123; char *str = "12345"; if (strlen(str) - 10 &gt;= 0) &#123; printf("enter forever!\n"); &#125; return 0;&#125; strlen的返回值也是size_t类型，像上边所说的相同，if判定中左边的表达式strlen(str) - 10的结果会被隐式提升为size_t类型，也就是不会出小于0的情况，在这种情况也，if判定永远成立，这种情况下要么改成strlen(str) &gt; 10， 要么对表达式做强制类型转换。很多时候这种错误会浪费我们很多时间，所以尽量显式的保持类型一致。]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给某鸟的Vim初始配置]]></title>
    <url>%2F2014%2F01%2F03%2F%E5%86%99%E7%BB%99%E6%9F%90%E9%B8%9F%E7%9A%84Vim%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[对于文本的编辑器，适合自己才是最好的。 gVim（for windows【下称vim】）的简单初级配置，一些初级常用配置（PS:网上遍地都是）： vim字体选择： 菜单栏菜单edit选项里的select font子项，会弹出字体选择，另一种方式就是命令行里：:set guifont=*，会直接弹出字体选择界面。但是这样儿的修改只对当前vim窗口有效，保持更改就那得写到vimrc文件里(vimrc，windows下vim安装目录根目录下的一个文件)，set guifont=你选择字体的名称:h字号大小:cANSI，如：set guifont=Monaco:h11:cANSI，这样写入vimrc中字体配置就永久有效了。不过还有可能不只在windows下使用可能也会在linux下使用这同一个配置文件，那这个命令就不管用了，怎么办呢，写一段脚本区分系统来使用不同的字体设置如下： 12345if (has('win32') || has('win64')) set guifont=字体名称:h字号大小:cANSIelseif has('unix') let &amp;guifont="字体名称 字号大小"endif 这样添加到vimrc中，vim就会根据系统的不来选择设置好的不同的字体。 主题选择：vim默认的主题看着不怎么舒服，先打开一个代码文件，edit菜单里有color scheme子项，试试每个主题，如果没有合适的就去vim官网官网scripts里搜索一下，找一个适合自己的主题，文件都是vim后缀，下载好的文件放到vimfiles（也就是vim安装根目录下的vimfiles文件夹）文件夹下的color文件夹下（比如我的就是d:/Program Files/Vim/vimfiles/color/下），持久使用就要写入vimrc文件，如下命令：colorscheme 主题名字，此主题就会成为vim默认主题（比如：colorscheme desertEx），可以命令行里查看当前主题名称：:colorscheme。ps：可以自行打开主题文件进行相关配色修改。 行号显示：写代码的时候常常需要查看代码行数，vim内置行号显示，默认不开启，如想显示命令行里输入：:set nu，想永久显示，将此句写入vimrc中(写入vimrc中set前没有冒号，下同)。想关闭行号显示，命令：:set nonu即可，默认的行号显示与vim窗口左边有一段距离，有时候会感觉很不舒服，可以设置行号显示宽度：:set numberwidth=宽度数值，大于0的数值，设置为1即紧靠左边vim窗体。行号的颜色也想更改，怎么办？二个方法，一个是打开对应的使用的主题的文件，找到对应的LineNr项，更改其前景颜色值到满意为止。另一种方法：直接在vimrc里设置LineNr的前景色：:hi LineNr guifg=颜色值（如：:hi LineNr guifg=#555555）。 界面其他设置：默认的vim带菜单栏和工具栏，都是可以去掉的，隐藏工具栏：set guioptions-=T，隐藏菜单栏：set guioptions-=m。（写入vimrc即可）vim的启动位置（相对于windows窗口左上角）：winpos left top（left相对于左边的距离，top相对于上边的距离，像素单位，写入vimrc即可生效）。窗口的大小（以行数和列数来计），set line=行数 columns=列数（写入vimrc）。如果想启动后窗口就是最大化状态，可以写入： autocmd guienter * simalt ~x即可。隐藏底部的滚动条：set guioptions-=b。隐藏左侧的滚动条：set guioptions-=L。设置文本行距：set linespace=整数值。可以高亮显示与光标下匹配的括号：setshowmatch设置光标所在行高亮：set cursorline，设置高亮行的颜色：hi cursorline guibg=颜色值。始终显示状态栏：set statusline=2。所有模式均可使用鼠标：set mouse=n。去掉vim的屏幕闪烁：set novisualbell。去掉vim的错误提示声音：set noerrorbells。设置命令行的高度：set cmdheight=整数值，默认是1。状态栏的显示，状态栏可以自己加以定制，显示不同的内容：这里只给出一种示例：set statusline=%F%m%r%w\ [FORMAT=%{&amp;ff}][TYPE=%Y][POS=%l,%v][ASC=%b][HEX=0X%B]\，给出的是文件名，文件格式，文件类型，光标位置，位置下字符ascii杩，十六进制值，当然还有很多内容可以进行自己定制的显示，例如还可以让状态栏在显示上述的基础上显示当前的时间，set statusline+=[%{strftime(\”%m-%d\ %H:%M:%S\”)}]，这样就会以月日时分秒的方式来显示当前时间（具体其他定制查看帮助：help statusline或者google）。还可以在不同的模式下让状态栏显示不同的颜色，只需要地vimrc中写入一段脚本函数来监视当前的模式是进入何种模式，然后对应改变其状态栏的颜色即可。 其他文件相关设置：默认vim每次打一个文件都会生成一个交换文件一个备份文件，想要关闭可以：set nobackup 。setnoswapfile。set nowb开启语法高亮并开启文件类型的自动检测：syntax on 。filetype on关闭vi兼容模式（即不使用vi的操作方式）：set nocompatible设置自动缩进和智能缩进： set autoindent。set smartindent设置c语言样式的自动缩进：set cindent。设置自动对齐：set autoindent。为对应的文件载入相应的缩进文件： filetype indent on设置缩进的宽度，即一个tab的宽度：set tabstop=4。setsofttabstop=4设置vim的文件编码：set encoding=utf-8（vim自己使用的编码）设置vim保存文件时的文件编码：set fileencoding=utf-8vim检测文件的编码：set fencs=utf-8,ucs-bom,gb18030,cp936,latin-1可以设置vim文本的自动格式化：set formatoptions=tcrqn]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说到烂的面试题-链表是否存在环以及环入口点]]></title>
    <url>%2F2014%2F01%2F01%2F%E8%AF%B4%E5%88%B0%E7%83%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%8E%AF%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%85%A5%E5%8F%A3%E7%82%B9.html</url>
    <content type="text"><![CDATA[一个已经快出到烂的面试题，如何检测到链表中存在环，如果有环，找出环入口点; 一种最简单的情况，假如知道链表的长度，遍历链表，如果得到的长度大于链表长度就存在环； 将链表逆置的方法，每遍历一个结点就将结点反向逆置，如果存在环，最终还会到达链表的头结点(会破坏链表，检测完成后恢复链表环路)； 元素标记法，每个结点加一个域，isVisited，每访问一个结点标记isVisited，直到检测到某一个被标记过的结点，证明有环(最容易想到的); (链表在只读区，不允许加标记.)弄一散列表，或者数组也行，遍历每个结点后放入对应散列表或者数组中，每遍历一个结点都检测一下表或者数组中是否已经有了这个结点，如果检测到说明链表含有环； (内存空间有限，不允许你创建那么大的表或者数组，但是链表长度一定)，弄二个指针，一个指向第一个结点不动，另一个指向其后的结点依次后移并与指向第一个结点的指针做比较，然后指向第一个结点的指针再移向第二个结点，另一个指针再向后移动并与之比较，依次进行，检测到二个指针内容相同，刚链表含有环； (链表长度任意)，网上说得最多的方法，快慢指针的方法，二个指针，ptrPre和ptrBack，同时在头结点向后移动，ptrPre每次移动二个结点，ptrBack每次移动一个结点，二者一快一慢，且只相差一个点(类似操场跑步的扣圈)，如果有环，那必定二个指针会相遇，检测到二个指针相遇，说明链表中存在环； 一个不知道可不可行的方法：用一个指针去遍历整个链表，把其移动的轨迹（即结点）存放到数组里，然后找这个数组里的最长公共子串，找到后第一个结点就是入口点。 另一种不太常规的方法，也是在找到重合点后，在环的重合点部分断开链表，形成二个相交的链表，找入口问题就转化成了找二个链表的公共交点，不过需要注意的是这种会破坏链表的完整，需要在找到入口点后恢复链表环路。找二个相交链表的公共结点就容易多了，分别拿到二个链表的长度，并算出长度差值，二个指针分别指向二个链表的头，要长的链表先移动长度差值个结点，然后二者同时移动，当检测到二个指针内容相同的时候，即是二个链表相交的结点，也就是原带环链表的入口点。 找到环的入口点：说得最多的方法就是快慢指针找到重合的结点后，重置某一个指针到链表头，二个指针同时移动，每次移动一个结点，当二者相遇的结点处就是环的入口点: 数学解释就是：设链表头到环入口距离是entry_len,，环入口到二个指针重合的位置距离是intersect_len，环的周长是circle_len，相遇时慢指针移动的距离是back_len，那么快指针在相遇的时候移动的距离是2 * back_len，就有： intersect_len + entry_len = back_len;2 back_len = N circle_len + back_len;换算 =&gt; N * circle = intersect_len + entry_len; 也就是entry_len = N * circle - intersect_len 且circle是环的周长，即重合位置与入口点剩余的距离与entry_len相同。代码也就是在返回相交点的指针时，用另一个指针同时指针链表头，二个同时移动，直到ptr1 == ptr2，这个结点就是环入口点，实现很简单。下为测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node&#123; int data; struct Node *next;&#125; Node, *LinkedList;//==============================链表生成代码_BEGIN_================================//检测内存分配void checkMemoryMalloc(LinkedList mem)&#123; if (!mem) &#123; printf("内存分配失败！\n"); exit(-1); &#125;&#125;//头插法创建一个指定长度的链表LinkedList createList(int length)&#123; LinkedList head = (LinkedList)malloc(sizeof(Node)); checkMemoryMalloc(head); head-&gt;next = NULL; for (int i = 0; i &lt; length; i++) &#123; printf("输入结点数据：\t"); LinkedList pTemp = (LinkedList)malloc(sizeof(Node)); checkMemoryMalloc(pTemp); scanf("%d", &amp;pTemp-&gt;data); pTemp-&gt;next = head-&gt;next; head-&gt;next = pTemp; &#125; return head;&#125;//找到尾结点LinkedList getTailNode(LinkedList list)&#123; LinkedList tail = list-&gt;next; while (tail-&gt;next) tail = tail-&gt;next; return tail;&#125;//计算链表长度int getListLength(LinkedList list)&#123; int length = 0; LinkedList temp = list-&gt;next; while (temp) &#123; length++; temp = temp-&gt;next; &#125; return length;&#125;//根据location，返回对应的结点LinkedList getNodeByLocation(LinkedList list, int location)&#123; int count = 1; LinkedList temp = list-&gt;next; while (count != location &amp;&amp; temp) &#123; count++; temp = temp-&gt;next; &#125; if (count == location) return temp; else return NULL;&#125;//根据结点返回位置int getLocationByNode(LinkedList list, LinkedList node)&#123; LinkedList temp = list-&gt;next; int location = 1; if (!node) return -1; while (temp &amp;&amp; temp != node) &#123; temp = temp-&gt;next; location++; &#125; return location;&#125;//做出一个链表的环（部分）LinkedList makeCycleInList(LinkedList list, int location)&#123; LinkedList tailNode = getTailNode(list); LinkedList tailNext = getNodeByLocation(list, location); if (!tailNext) &#123; printf("位置不正确！\n"); exit(0); &#125; tailNode-&gt;next = tailNext; return list;&#125;//输出链表元素void printList(LinkedList list)&#123; LinkedList temp = list-&gt;next; while (temp) &#123; printf("%d--", temp-&gt;data); temp = temp-&gt;next; &#125; printf("\n");&#125;//构造一个带环链表LinkedList getSpecialCycleList(int listLength, int cycleLocation)&#123; LinkedList cycleList = createList(listLength); cycleList = makeCycleInList(cycleList, cycleLocation); return cycleList;&#125;//======================================链表生成代码_END_============================//判定一个链表是否含有环LinkedList getListIntersectNode(LinkedList list)&#123; //二个指针起始偏移相同 LinkedList pBack = list; LinkedList pPre = list; while (pPre != NULL &amp;&amp; pPre-&gt;next != NULL) &#123; pBack = pBack-&gt;next;//慢的指针，每次移动一个结点 pPre = pPre-&gt;next-&gt;next;//快的指针，每次移动二个结点 if (pBack == pPre)//二个结点相同的时候，证明有环 return pPre; //将交点返回 &#125; return NULL;&#125;//首次相交的结点切断，成为二个与第一个链表相交的链表LinkedList cutListOnIntersectNode(LinkedList list)&#123; LinkedList cutList = getListIntersectNode(list); if (!cutList) &#123; printf("链表无环！\n"); return NULL; &#125; //为切断后的结点新建立一个头结点 LinkedList newHead = (LinkedList)malloc(sizeof(Node)); checkMemoryMalloc(newHead); newHead-&gt;next = cutList-&gt;next;//保存交点处下一个结点位置 cutList-&gt;next = NULL;//切断交点处指针 return newHead;&#125;//得到二个链表公共的结点， 即带环链表的环入口LinkedList getListsCommonNode(LinkedList first, LinkedList second)&#123; int firLength = getListLength(first); int secLength = getListLength(second); int diffValue = 0;//保存二个链表长度差值 LinkedList firPtr = first; LinkedList secPtr = second; //长的链表指针先移动二个链表长度之差个单位 if (firLength &gt; secLength) &#123; diffValue = firLength - secLength; for (; diffValue--; firPtr = firPtr-&gt;next); &#125; else &#123; diffValue = secLength - firLength; for (; diffValue--; secPtr = secPtr-&gt;next); &#125; //查找同一个结点， 二个结点同时移动 while (firPtr &amp;&amp; secPtr) &#123; firPtr = firPtr-&gt;next; secPtr = secPtr-&gt;next; if (firPtr == secPtr) return firPtr; &#125; return NULL;&#125;int main(int argc, const char *argv[])&#123; //测试代码 LinkedList firList = getSpecialCycleList(16, 5); LinkedList secList = cutListOnIntersectNode(firList); printList(firList); printf("===============================\n"); printList(secList); printf("===============================\n"); LinkedList intersectNode = getListsCommonNode(firList, secList); printf("intersectData == %d\n", intersectNode-&gt;data); printf("firLoc == %d\nsecLoc == %d\n", getLocationByNode(firList, intersectNode), getLocationByNode(secList, intersectNode)); if (getListsCommonNode(firList, secList)) printf("链表交点：%p\n", getListsCommonNode(firList, secList)); else printf("无交点！\n");&#125;]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
