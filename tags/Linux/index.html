<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="keep coding, keep moving..."><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>bugcode's note</title><link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="author"><div class="author-name"><a href="/">bugcode's note</a></div><div class="about-me">keep coding, keep moving...</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">Archives</a></li><li><a href="/about">About</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.jpg"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/bugcoding"></span><a href="https://github.com/bugcoding" target="_blank" title="https://github.com/bugcoding">https://github.com/bugcoding</a></li></ul></div></div></div></header><div class="container"><div class="year-wrap"><div class="year"><a class="title" href="/archives/2016">2016</a></div></div><div class="archives"><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">09-04</div><div class="post-archive__body"><a class="post-archive__title" href="/2016/09/04/CR-LF小坑.html">CR/LF小坑</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><h3 id="CR、LF、CR-LF"><a href="#CR、LF、CR-LF" class="headerlink" title="CR、LF、CR/LF"></a>CR、LF、CR/LF</h3><p>不同系统对“换行”的表示，详情可以看<a href="https://en.wikipedia.org/wiki/Newline" target="_blank" rel="noopener">这里</a>。</p></div></div></div></div></div><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">06-16</div><div class="post-archive__body"><a class="post-archive__title" href="/2016/06/16/好用的shell命令和常用的SVN命令记录.html">好用的shell命令和常用的SVN命令记录</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><h2 id="常用的命令行SVN命令"><a href="#常用的命令行SVN命令" class="headerlink" title="常用的命令行SVN命令"></a>常用的命令行SVN命令</h2><p>现在的版本管理工具都有相当人性化的GUI版本，无论是免费的收费的，都做得相当好，点几个按钮，选几个文件，提交，回退，更新，一步就完成了，但是最近在公司的Mac下(低配Mac mini，你懂的…)，很多GUI版本的工具都非常慢，卡顿非常严重，而且对SVN的外链(external)支持不好(像CornerStone这个SVN的GUI工具)，也就是在版本管理工具的内部的文件视图里，看不到external属性下的文件，只能看到最上级的目录，而实际的目录中却有对应的文件，只是不能在GUI的版本工具中进行操作，这个情况下就只能在对应的外链目录下通过终端进行提交了。一段时间下来，发现一堆命令都忘了，只会在GUI工具上点来点去，一旦遇到上面那种情况，就得傻眼半天，这里记录一下常用的SVN命令行命令。</p></div></div></div></div></div></div><div class="year-wrap"><div class="year"><a class="title" href="/archives/2015">2015</a></div></div><div class="archives"><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">05-16</div><div class="post-archive__body"><a class="post-archive__title" href="/2015/05/16/Linux下的umask.html">Linux下的umask</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>​        偶然看到一本书上写umask(掩码)的计算，说是用户的实际文件(夹)权限是通过默认文件(夹)权限与掩码相减得到的。感觉不太对。</p></div></div></div></div></div><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">04-19</div><div class="post-archive__body"><a class="post-archive__title" href="/2015/04/19/使用SIGCHLD信号异步清理子进程.html">使用SIGCHLD信号异步清理子进程</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>首先说为什么要清理子进程（由父进程），在Unix系统中经常会听到一个词“僵尸进程”(Zombie Process[可不是植物大战僵尸^_*])，而“僵尸进程”就是由子进程而来的。</p></div></div></div></div></div></div><div class="year-wrap"><div class="year"><a class="title" href="/archives/2014">2014</a></div></div><div class="archives"><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">05-01</div><div class="post-archive__body"><a class="post-archive__title" href="/2014/05/01/Makefile初步-3.html">Makefile初步-3</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>如果想在一个makefile中引用其他的文件，也就是包含进其他的makefile文件到此Makefile文件，像C语言一样儿，使用include命令</p></div></div></div></div></div><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">04-03</div><div class="post-archive__body"><a class="post-archive__title" href="/2014/04/03/Makefile初步-2.html">Makefile初步-2</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>接上文，假如有如下一个Makefile其中一部分是这样的：</p></div></div></div></div></div><div class="post-archive"><div class="post-archive__content"><div class="post-archive__month">03-31</div><div class="post-archive__body"><a class="post-archive__title" href="/2014/03/31/Makefile初步-1.html">Makefile初步-1</a><div class="post-archive__excerpt"><div class="post-archive__excerpt-content"><p>在Windows下有诸如vs这样儿“强大”的工具来组织与管理工程，文件层次组织，代码编写，包括选项的设置，编译，链接，都可以在一个窗口中完成（其实背后也是有一个make工具）。Linux下，Unix的哲学，多个不同功能的小工具，组合到一起组成强大的功能，一些小小的文件，我们可以<em>gcc –XXFlags XXOO.c –o XXOO</em>，这样儿来做，但是要是几十个文件，几百个文件呢？还去挨个的输入命令编译？这就是是马上要介绍的make工具，使用make工具，只需要一个命令，就可以构建你的工程。当然，代价就是编写Makefile，make工具就是靠解释Makefile文件来对整个工程进行编译和链接。</p></div></div></div></div></div></div></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><center class="span">2014-2018 bugcode.</center></div></footer><script src="/script/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/script/index.js"></script></body></html>